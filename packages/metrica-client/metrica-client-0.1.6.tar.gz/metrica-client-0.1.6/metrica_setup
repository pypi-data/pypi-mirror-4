#!/usr/bin/env python

import getpass
import os
import pwd
import requests
import stat
import subprocess
import sys
import time
from Crypto.PublicKey import RSA
from datetime import datetime

try:
    import json
except:
    try:
        import simplejson as json
    except:
        print ''.join(["ERROR: This program requires simplejson.  Please try ",
                       "'pip install simplejson'."])
        sys.exit(1)

if os.getuid() != 0:
    sys.stderr.write("Must be run as root.\n")
    exit(1)


class Logger():
    def __init__(self):
        self.filename = 'metrica_setup.log'
        self.logfile = open(self.filename, 'w')

    def log(self, message):
        for line in message.split('\n'):
            self.logfile.write('[' + str(datetime.now()) + '] ')
            self.logfile.write(line)
            self.logfile.write('\n')

        self.logfile.flush()

    def delete(self):
        self.logfile.close()
        os.remove(self.filename)


logger = Logger()


def ensureDir(path):
    try:
        os.mkdir(path)
    except OSError as e:
        if e.errno is not 17:
            raise
    return True


def send_error_report(failed_request):
    sys.stderr.write(str(r.status_code) + "\n")
    sys.stderr.write(str(r.headers) + "\n")
    sys.stderr.write(r.text)


class Progress:
    @staticmethod
    def add(description):
        logger.log(description)
        print description

    @staticmethod
    def error(description):
        logger.log('ERROR - ' + description)
        sys.stderr.write(description)
        sys.stderr.write("\n")

    @staticmethod
    def prompt(text):
        try:
            logger.log('PROMPT - ' + text)
            sys.stdout.write(text + ': ')
            response = sys.stdin.readline()[:-1]
            logger.log('RESPONSE - ' + response)
            return response
        except KeyboardInterrupt:
            sys.stdout.write('\n')
            sys.exit(1)

    @staticmethod
    def prompt_password(text):
        try:
            return getpass.getpass(text + ': ')
        except getpass.GetPassWarning:
            pass


class Config(object):
    def __init__(self, path, **kwargs):
        self.path = path
        self.attrs = {}
        try:
            config_file = open(path, 'r')
            for line in config_file.readlines():
                key, value = line.strip().split('=', 1)
                self.attrs[key] = value
            config_file.close()
        except IOError:
            pass

        for key in kwargs:
            self.attrs[key] = kwargs[key]

    def write(self):
        config_file = open(self.path, 'w')
        for key in self.attrs:
            config_file.write('%s=%s\n' % (key, self.attrs[key]))
        config_file.close()

    def __getitem__(self, key):
        return self.attrs[key]

    def get(self, key, default):
        try:
            return self.attrs[key]
        except KeyError:
            return default


def handle_error(failed_request):
#    Progress.error(''.join(["Sorry!  We're having trouble connecting to the ",
#                            "Metrica servers.  Would you like to send ",
#                            "troubleshooting data to the Metrica support team?"
#                            ]))
#    send_report = Progress.prompt('[Y/n]')
#    if send_report == '' or send_report.lower() == 'y':
#        send_error_report(failed_request)

    Progress.error(''.join(["Sorry!  We're having trouble connecting to the ",
                            "Metrica servers.  Troubleshooting data has been "
                            "logged to %s." % logger.filename,
                            ]))
    logger.log(str(r.status_code))
    logger.log(str(r.headers))
    logger.log(r.text)
    sys.exit(1)

base_path = os.path.join(os.environ['HOME'], '.metrica')
config_path = os.path.join(base_path, 'config')
ssh_path = os.path.join(base_path, 'ssh')
pubkey_path = os.path.join(ssh_path, 'id_rsa.pub')
privkey_path = os.path.join(ssh_path, 'id_rsa')

Progress.add('Adding directories...')
ensureDir(base_path)
ensureDir(ssh_path)

try:
    os.stat(privkey_path)
    with open(pubkey_path, 'r') as pubkey_file:
        pubkey = '\n'.join(pubkey_file.readlines())
    Progress.add('Found metrica keys')
except OSError as e:
    if e.errno == os.errno.ENOENT:
        Progress.add('Generating keys...')
        key = RSA.generate(2048, os.urandom)
        pubkey = key.exportKey('OpenSSH')
        with open(pubkey_path, 'w') as pubkey_file:
            pubkey_file.write(pubkey)
        with open(privkey_path, 'w') as privatekey_file:
            privatekey_file.write(key.exportKey('PEM', pkcs=8))
        os.chmod(privkey_path, stat.S_IRUSR | stat.S_IWUSR)
        Progress.add('Key generated.')
    else:
        raise

port = Progress.prompt('Port mongo is listening on')

api_url = 'http://www.getmetrica.com/api/v1/'
# api_url = 'http://test.getmetrica.com/api/v1/'
# api_url = 'http://www.localhost.com:8000/api/v1/'

use_auth = Progress.prompt('Does this mongo instance use authentication')
use_auth = use_auth and use_auth.lower()[0] == 'y'
if use_auth:
    mongo_user = Progress.prompt('Mongo username')
    mongo_password = Progress.prompt('Mongo password')

uid = None
while uid is None:
    proc_user = Progress.prompt(
        'System user to run metrica process as [nobody]')
    if proc_user == '':
        proc_user = 'nobody'
    try:
        user_info = pwd.getpwnam(proc_user)
        uid = user_info.pw_uid
    except KeyError:
        Progress.add('No user with that name.')

success = False
while not success:
    username = Progress.prompt('Metrica username')
    password = Progress.prompt_password('Metrica password')
    auth = (username, password)
    #TODO: Check for auth failures and ask to re-type
    Progress.add('Sending data...')
    data = {'ssh_key': pubkey,
            'remote_port': port,
            'use_auth': use_auth}
    if use_auth:
        data['remote_user'] = mongo_user
        data['remote_password'] = mongo_password

    headers = {'content-type': 'application/json'}
    r = requests.post(api_url + 'server/', data=json.dumps(data), auth=auth,
                      headers=headers)
    if r.status_code >= 300:
        if r.status_code == 401:
            Progress.add("We couldn't log you in.  Please try again.")
        else:
            handle_error(r)
    else:
        success = True

server_uri = r.headers['Location']
r = requests.get(server_uri, auth=(username, password))
if r.status_code >= 300:
    handle_error(r)

port = r.json['relay_port']
relay_user = r.json['relay_user']
relay_host = r.json['relay_host']

c = Config(config_path, port=port, relay_user=relay_user,
           relay_host=relay_host, server_uri=server_uri, uid=uid)
c.write()

os.chown(base_path, uid, -1)
os.chown(config_path, uid, -1)
os.chown(ssh_path, uid, -1)
os.chown(privkey_path, uid, -1)

Progress.add('SSH configured.  Testing now...')

import pdb
pdb.set_trace()
args = [
    'metrica_connect',
    'start']

subprocess.Popen(args, stderr=subprocess.STDOUT)

Progress.add('Establishing connection...')

time.sleep(3)

r = requests.get(server_uri, auth=auth)
if r.status_code >= 300:
    handle_error(r)

if r.json['connect_status'] == 'could_not_connect':
    Progress.error(''.join([
        "Looks like there's a problem connecting to your server.  Please ",
        "check that mongod is running on the port you specified, and that ",
        "this machine allows reverse ssh tunneling out of your network."]))
    sys.exit(1)
elif r.json['connect_status'] != 'success':
    handle_error(r)
else:
    Progress.add('Connected successfully!')
    logger.delete()
