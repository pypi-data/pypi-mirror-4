Metadata-Version: 1.1
Name: z3c.schema
Version: 1.0.0
Summary: Additional schema fields for Zope 3
Home-page: http://pypi.python.org/pypi/z3c.schema
Author: Zope Community
Author-email: zope-dev@zope.org
License: ZPL 2.1
Description: This package provides different additional Zope 3 schema fields.
        
        
        .. contents::
        
        =======
        CHANGES
        =======
        
        1.0.0 (2013-03-01)
        ------------------
        
        - Added support for Python 3.3.
        
        - Replaced deprecated ``zope.interface.implements`` usage with equivalent
          ``zope.interface.implementer`` decorator.
        
        - Dropped support for Python 2.4 and 2.5.
        
        
        0.7.2 (2011-04-03)
        ------------------
        
        - Fixed i18n files after something injected 'fuzzy' into the PO files.
        
        
        0.7.1 (2011-04-03)
        ------------------
        
        - Add nl translations.
        
        
        0.7.0 (2010-10-18)
        ------------------
        
        - Updated tests to run with `zope.schema` >= 3.6, thus requiring at least
          this version.
        
        - Using Python's ``doctest`` module instead of depreacted
          ``zope.testing.doctest[unit]``.
        
        
        0.6.1 (2010-10-18)
        ------------------
        
        - Added french translations.
        
        - Added doctests to ``long_description`` so they appear on PyPI.
        
        
        0.6.0 (2009-01-26)
        ------------------
        
        - Humanized exception's doc strings.
        - Added translations support.
        - Added german translations.
        - Added russian translations.
        - Changed mailing list address to zope-dev at zope.org, as
          zope3-dev is retired now.
        
        0.5.0 (2008-10-21)
        ------------------
        
        - Initial release on PyPI.
        
        
        0.2.0 (2007-09-21)
        ------------------
        
        - Feature: Added ``DateSelect`` field.
        
        
        0.1.0 (2007-06-04)
        ------------------
        
        - Initial release.
        
        
        ========
        BaseURL
        ========
        
        A base url field is useful if you need to append view names to a url and 
        doesn't like to check every time if the url ends with a backslash before you 
        append the view name.
        
        Let's first create the BaseURL field:
        
          >>> from z3c.schema.baseurl import BaseURL
          >>> baseURL = BaseURL()
        
        Let's first check the validation of some common base urls.
        
          >>> baseURL.validate("http://www.python.org/")
          >>> baseURL.validate("http://www.python.org/foo/")
          >>> baseURL.validate("http://123.123.123.123/")
          >>> baseURL.validate("http://123.123.123.123/foo/")
        
        A port specification is also allowed:
        
          >>> baseURL.validate("http://www.python.org:389/")
          >>> baseURL.validate("http://www.python.org:389/foo/")
        
        However, a missing backslash is not permitted:
        
          >>> baseURL.validate("http://www.python.org/foo")
          Traceback (most recent call last):
          ...
          InvalidBaseURL: http://www.python.org/foo
        
        And a missing protocol is also not permitted:
        
          >>> baseURL.validate("www.python.org/foo/")
          Traceback (most recent call last):
          ...
          InvalidBaseURL: www.python.org/foo/
        
        Let's check some other invalid forms:
        
          >>> baseURL.validate("$www.python.org/")
          Traceback (most recent call last):
          ...
          InvalidBaseURL: $www.python.org/
        
          >>> baseURL.validate("333.123.123.123/")
          Traceback (most recent call last):
          ...
          InvalidBaseURL: 333.123.123.123/
        
        Let's also ensure that we can convert to base urls from unicode:
        
          >>> baseURL.fromUnicode("http://www.python.org:389/")
          'http://www.python.org:389/'
          >>> baseURL.fromUnicode("          http://www.python.org:389/")
          'http://www.python.org:389/'
          >>> baseURL.fromUnicode("      \n    http://www.python.org:389/\n")
          'http://www.python.org:389/'
        
          >>> baseURL.fromUnicode("http://www.pyt hon.org:389/")
          Traceback (most recent call last):
          ...
          InvalidBaseURL: http://www.pyt hon.org:389/
        
        
        ========================
        The Date Selection Field
        ========================
        
        The date selection field was designed to support the UI requirement of
        allowing users to select a date using multi-select input fields. The
        ``DateSelect`` field extends the ``Date`` field merely by a few additional
        attributes.
        
          >>> from z3c.schema.dateselect import field
        
        the first attribute is the range of years that will be offered to the user:
        
          >>> birthday = field.DateSelect(
          ...     title=u'Birthday',
          ...     yearRange=list(range(1920, 2007)))
        
        In this case the user will be offered all years from 1920 to 2007.
        
          >>> birthday.yearRange
          [1920, ..., 2006]
        
        The second attribute allows you to specify an initial date for the selection:
        
          >>> import datetime
          >>> birthday = field.DateSelect(
          ...     title=u'Birthday',
          ...     yearRange=range(1920, 2007),
          ...     initialDate=datetime.date(2000, 1, 1))
        
          >>> birthday.initialDate
          datetime.date(2000, 1, 1)
        
        And this is really it. Please read the documentation on the ``Date`` for more
        information.
        
        
        ====================
        RFC 822 Mail Address
        ====================
        
        Let's first generate an E-mail field:
        
          >>> from z3c.schema.email import RFC822MailAddress
          >>> email = RFC822MailAddress()
        
        Check that the constraints of the value are fulfilled:
        
          >>> email.constraint('foo\n')
          False
          >>> email.constraint('foo\r')
          False
          >>> email.constraint('foo')
          True
        
        Now make sure the E-mail addresses validate:
        
          >>> email.validate(10)
          Traceback (most recent call last):
          ...
          WrongType: (10, <type 'unicode'>, '')
        
          >>> email.validate(u'foo@bar.')
          Traceback (most recent call last):
          ...
          NotValidRFC822MailAdress: foo@bar.
        
          >>> email.validate(u'foo@bar.com')
        
        Since the field uses a simple function to validate its E-mail fields, it is
        easier to use it for the tests:
        
          >>> from z3c.schema.email import isValidMailAddress
          >>> isValidMailAddress(u'foo@bar.com')
          True
          >>> isValidMailAddress(u'foo.blah@bar.com')
          True
        
          # Name failures
        
          >>> isValidMailAddress(u'foo\r@bar.com')
          False
          >>> isValidMailAddress(u'foo<@bar.com')
          False
          >>> isValidMailAddress(u'foo:@bar.com')
          False
        
          # Overall failures
        
          >>> isValidMailAddress(u'')
          False
          >>> isValidMailAddress(u'foo.')
          False
          >>> isValidMailAddress(u'foo.@bar.com')
          False
          >>> isValidMailAddress(u'.foo@bar.com')
          False
          >>> isValidMailAddress(u'foo@bar.com.')
          False
        
          # Domain failures
        
          >>> isValidMailAddress(u'foo@')
          False
          >>> isValidMailAddress(u'foo@bar.')
          False
          >>> isValidMailAddress(u'foo@bar')
          False
          >>> isValidMailAddress(u'foo@bar..com')
          False
          >>> isValidMailAddress(u'foo@bar\r.com')
          False
          >>> isValidMailAddress(u'foo@bar<.com')
          False
          >>> isValidMailAddress(u'foo@bar:.com')
          False
        
        
        ========
        Hostname
        ========
        
        Let's first create the hostname field:
        
          >>> from z3c.schema.hostname import HostName
          >>> hostname = HostName()
        
        Let's first check the validation of some common hostnames. Hostnames can be
        either domain or IP addresses.
        
          >>> hostname.validate("www.python.org")
          >>> hostname.validate("123.123.123.123")
        
        A port specification is also allowed:
        
          >>> hostname.validate("www.python.org:389")
        
        However, the protocol is not permitted:
        
          >>> hostname.validate("http://www.python.org")
          Traceback (most recent call last):
          ...
          InvalidHostName: http://www.python.org
        
          >>> hostname.validate("ldap://www.python.org/foo")
          Traceback (most recent call last):
          ...
          InvalidHostName: ldap://www.python.org/foo
        
        Let's check some other invalid forms:
        
          >>> hostname.validate("$www.python.org")
          Traceback (most recent call last):
          ...
          InvalidHostName: $www.python.org
        
          >>> hostname.validate("333.123.123.123")
          Traceback (most recent call last):
          ...
          InvalidHostName: 333.123.123.123
        
        Let's also ensure that we can convert to hostnames from unicode:
        
          >>> hostname.fromUnicode("www.python.org:389")
          'www.python.org:389'
          >>> hostname.fromUnicode("          www.python.org:389")
          'www.python.org:389'
          >>> hostname.fromUnicode("      \n    www.python.org:389\n")
          'www.python.org:389'
        
          >>> hostname.fromUnicode("www.pyt hon.org:389")
          Traceback (most recent call last):
          ...
          InvalidHostName: www.pyt hon.org:389
        
        
        ================
        IP Address Field
        ================
        
        This module provides a field for IP addresses. Let's first generate an IP
        field:
        
          >>> from z3c.schema import ip
          >>> myip = ip.IPAddress()
        
        Now make sure the IP addresses validate:
        
          >>> myip.validate(10)
          Traceback (most recent call last):
          ...
          WrongType: (10, <type 'str'>, '')
        
          >>> myip.validate('12.123.231.wee')
          Traceback (most recent call last):
          ...
          NotValidIPAdress: 12.123.231.wee
        
          >>> myip.validate('10.0.0.1')
        
        Since the field uses a simple function to validate its IP addresses, it is
        easier to use it for the tests:
        
          >>> from z3c.schema.ip import isValidIPAddress
          >>> isValidIPAddress('0.0.0.0')
          True
          >>> isValidIPAddress('255.255.255.255')
          True
        
          # Number of pieces failures
        
          >>> isValidIPAddress('12.3.1')
          False
          >>> isValidIPAddress('1.0.0.0.0')
          False
          >>> isValidIPAddress('1.0.0.0.')
          False
        
          # Not integers failures
        
          >>> isValidIPAddress('x.0.0.0')
          False
          >>> isValidIPAddress('0x8.0.0.0')
          False
        
          # Not in range failures
        
          >>> isValidIPAddress('-1.0.0.0')
          False
          >>> isValidIPAddress('256.0.0.0')
          False
          >>> isValidIPAddress('1.-1.256.0')
          False
        
        
        ================
        Optional Choices
        ================
        
        The optional choice field is desiged to offer a set of default choices or
        allow, optionally, to enter a custom value. The custom value has to conform to
        a specified field.
        
        Here is an example of creating such a field:
        
          >>> import zope.schema
          >>> from z3c.schema.optchoice import OptionalChoice
        
          >>> optchoice = OptionalChoice(
          ...     title=u'Occupation',
          ...     values=(u'Programmer', u'Designer', u'Project Manager'),
          ...     value_type=zope.schema.TextLine())
        
        Note that the value type *must* be a field:
        
          >>> OptionalChoice(
          ...     title=u'Occupation',
          ...     values=(u'Programmer', u'Designer', u'Project Manager'),
          ...     value_type=object())
          Traceback (most recent call last):
          ValueError: 'value_type' must be field instance.
        
        Let's now ensure that we can validate not only choices, but also custom
        values:
        
          >>> optchoice.validate(u'Programmer')
          >>> optchoice.validate(u'Project Manager')
          >>> optchoice.validate(u'Scripter')
        
          >>> optchoice.validate(u'Scripter\nHTML\n')
          Traceback (most recent call last):
          ...
          ConstraintNotSatisfied: Scripter
          HTML
        
        Let's now ensure that we can convert values from unicode to a real value as
        well. To demonstrate this feature, we have to create a more restrictive
        optional choice field:
        
          >>> optchoice = OptionalChoice(
          ...     title=u'Age',
          ...     values=(10, 20, 30, 40, 50),
          ...     value_type=zope.schema.Int(min=0))
        
          >>> optchoice.fromUnicode(u'10')
          10
          >>> optchoice.fromUnicode(u'40')
          40
          >>> optchoice.fromUnicode(u'45')
          45
        
          >>> optchoice.fromUnicode(u'-10')
          Traceback (most recent call last):
          ...
          TooSmall: (-10, 0)
        
        
        ===================
        z3c.schema.payments
        ===================
        
        z3c.schema.payments provides some level of error detection in payment data
        prior to storing the information or sending it to a payment processor.
        Currently this module only supports validation of credit card numbers, but
        this could conceivably be extended to other payment forms
        
        
        Credit Cards
        ------------
        
        Credit card numbering specifications are defined in ISO 7812-1:1983. Verifying
        that the credit card number supplied by a user conforms to the ISO standard
        provides some error checking which can catch typographical errors,
        transposition, etc. This does not validate the card against the financial
        networks as a valid account. However, verifying that the card number is well
        formed is fast and catching typographical errors in this way is much faster
        than sending the card number to a credit card processor.
        
        First, let's setup a credit card field:
        
            >>> from z3c.schema.payments import CreditCard
            >>> from z3c.schema.payments import interfaces
            >>> cc = CreditCard()
            >>> interfaces.IISO7812CreditCard.providedBy(cc)
            True
        
        The simple restrictions are quick to check. Credit cards should be all numeric, no alpha characters allowed:
        
            >>> cc.constraint('44444444444AAAA8')
            False
        
            >>> cc.constraint('4444444444444448')
            True
        
        Also, we can't have any returns or line endings in the number:
        
            >>> cc.constraint('444444444444\n4448')
            False
        
            >>> cc.constraint('44444444\r44444448')
            False
        
        One of the first specifications of ISO 7812 is a "Major Industry Identifier,"
        which is the first number of an ISO 7812 compliant account number. Originally,
        banking, financial, and merchandizing (store account) cards were limited to
        the  major industry identifiers 4, 5, and 6. However American Express, Diner's
        Club, and Carte Blanche were all assigned a major industry number 3. So a
        valid card must start with one of these numbers:
        
            >>> cc.validate(u'0000000000000000')
            Traceback (most recent call last):
            ...
            NotValidISO7812CreditCard: 0000000000000000
        
            >>> cc.validate(u'1111111111111117')
            Traceback (most recent call last):
            ...
            NotValidISO7812CreditCard: 1111111111111117
        
            >>> cc.validate(u'2222222222222224')
            Traceback (most recent call last):
            ...
            NotValidISO7812CreditCard: 2222222222222224
        
            >>> cc.validate(u'3333333333333331')
            >>> cc.validate(u'4444444444444448')
            >>> cc.validate(u'5555555555555557')
            >>> cc.validate(u'3333333333333331')
            >>> cc.validate(u'6666666666666664')
        
            >>> cc.validate(u'7777777777777771')
            Traceback (most recent call last):
            ...
            NotValidISO7812CreditCard: 7777777777777771
        
            >>> cc.validate(u'8888888888888888')
            Traceback (most recent call last):
            ...
            NotValidISO7812CreditCard: 8888888888888888
        
            >>> cc.validate(u'9999999999999995')
            Traceback (most recent call last):
            ...
            NotValidISO7812CreditCard: 9999999999999995
        
        The ISO specification also defines a check digit which should always
        be the last digit of a card number. The check digit is calculated using the
        Luhn (Mod 10) formula. In this way, each credit card number contains its own
        CRC of sorts. This is our main validation that a credit card number is well
        formed.
        
        Validating a number with a check digit that uses the LUHN formula:
        
        Step 1:
        Starting with the next-to-last digit and moving left, double the value of
        every other digit. The calculation starts with the next-to-last digit because
        the last digit is the check digit.
        
        * When selecting every other digit, always work right-to-left and do not start
          with the rightmost digit (since that is the check digit).
        
        * The last digit (check digit) is considered #1 (odd number) and the
          next-to-last digit is #2 (even number). You will only double the values of
          the even-numbered digits.
        
        Step 2:
        Add all unaffected digits to the values obtained in Step 1.
        
        * If any of the values resulting from Step 1 are double-digits, do not add
          the double-digit value to the total, but rather add the two digits, and
          add this sum to the total.
        
        Result:
        The total obtained in Step 2 must be a number ending in zero (exactly
        divisible by 10) for the number to be valid.
        
        The validate method of z3c.schema.payments.ISO7812CreditCard does the Luhn
        calculation on the provided card number. If the calculation fails, there is
        either an error in the number or the card is simply not valid. We use in our
        tests here and above numbers that technically meet the criteria of the ISO
        specification without the risk of the number actually being a valid card
        number registered with a financial institution:
        
            >>> cc.validate(u'4444444444444448')
            >>> cc.validate(u'4444444444444449')
            Traceback (most recent call last):
            ...
            NotValidISO7812CreditCard: 4444444444444449
        
        
        
        ========================
        Regular expression field
        ========================
        
        Let's first create the regex field.
        
          >>> from z3c.schema.regex import Regex
          >>> regex = Regex()
        
        The regex field only allows compilable regular expressions.
        
          >>> regex.validate(r'.*')
          >>> regex.validate(r'^\s+$')
        
        It does not validate regular expressions that do not compile.
        
          >>> regex.validate('(i')
          Traceback (most recent call last):
          ...
          InvalidRegex: '(i', unbalanced parenthesis
        
        
        
        
Keywords: zope zope3 z3c schema
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Environment :: Web Environment
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Zope Public License
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.6
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.3
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Natural Language :: English
Classifier: Operating System :: Microsoft :: Windows
Classifier: Topic :: Internet :: WWW/HTTP
Classifier: Framework :: Zope3
