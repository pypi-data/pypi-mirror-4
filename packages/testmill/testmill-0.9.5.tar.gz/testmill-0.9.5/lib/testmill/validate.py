# Copyright 2012-2013 Ravello Systems, Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import inspect


class ValidationError(RuntimeError):
    """Validation Error."""


def pathref(path):
    """Return a path reference for node path ``path``."""
    path = ['[{0}]'.format(pe) if isinstance(pe, int) else pe
            for pe in path]
    return '/' + '/'.join(path)


def generate_nodes(node, path, nodepath=None):
    """Generate (node, path) tuples for all children of ``node`` that satisfy
    the  ``path`` expression.  The ``nodepath`` parameter specifies the path of
    ``node`` itself, and it defaults to the root.
    """
    if nodepath is None:
        nodepath = []
    if not path:
        yield node, nodepath
        return
    elif path and not (isinstance(node, list) or isinstance(node, dict)):
        return
    depth = len(nodepath)
    name = path[0]
    if name == '*':
        if isinstance(node, list):
            depth += 1
            nodepath.append(None)
            for ix,elem in enumerate(node):
                nodepath[-1] = ix
                for res in generate_nodes(elem, path[1:], nodepath):
                    yield res
                del nodepath[depth:]
        elif isinstance(node, dict):
            depth += 1
            nodepath.append(None)
            for key,value in node.items():
                nodepath[-1] = key
                for res in generate_nodes(value, path[1:], nodepath):
                    yield res
                del nodepath[depth:]
        else:
            msg = "Expecting list/dict (got '{.__name__}')." \
                        .format(type(node))
            raise ValidationError(msg, nodepath)
    elif name.startswith('!'):
        name = name[1:]
        if name not in node:
            msg = "Mandatory key '{0}' missing.".format(name)
            raise ValidationError(msg, nodepath)
        nodepath.append(name)
        node = node.get(name)
        for res in generate_nodes(node, path[1:], nodepath):
            yield res
    elif name in node:
        nodepath.append(name)
        node = node.get(name)
        for res in generate_nodes(node, path[1:], nodepath):
            yield res


def validate_node(node, path, check):
    """Validate the node ``node``.
    
    A note is valid if all children that are generated by ``path`` pass the
    condition ``check``. 
    
    The path expression ``path`` is of the following form:

      /foo           one node at the root, called 'foo'
      /foo/bar       the node 'bar' in the node 'foo'
      /foo/*         generate all children of the list 'foo'
      /foo/!bar/baz  the node 'baz'. It is an error if  'bar' does not exist

    The ``check`` parameter must be a type or a function.  If it is a type, the
    node is valid if is an instance of the type. If it is a function, the node
    is valid if function returns nonzero.
    """
    path = path.strip('/').split('/')
    for node,nodepath in generate_nodes(node, path):
        if isinstance(check, type) or isinstance(check, tuple):
            if not isinstance(node, check):
                msg = "Expecting {.__name__} (got '{.__name__}')." \
                            .format(check, type(node))
                raise ValidationError(msg, nodepath)
        else:
            if not check(node, nodepath):
                msg = "'{0}' failed".format(chk.__name__)
                raise ValidationError(msg, nodepath)
