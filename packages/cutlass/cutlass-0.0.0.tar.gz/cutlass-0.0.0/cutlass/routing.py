#!/usr/bin/python
"""Dispatch requests to WSGI callables.
"""
import re
import logging
try:
    basestring
except NameError:
    basestring = str
try:
    callable
except NameError:
    callable = lambda f: hasattr(f, "__call__")


class DispatchError(Exception):
    """Base class for exceptions generated by dispatch operations.
    """
    def __init__(self, message):
        Exception.__init__(self)
        self.message = message

    def __str__(self):
        return "%s" % self.message


class BadRequestError(DispatchError):
    """Dispatch problem due to bad request (like no REQUEST_METHOD).

    This doesn't mean the HTTP request was bad, just that the information seen
    by the dispatch library was bad. This could also be due to server or
    middleware misbehavior.
    """
    pass


class BadMappingError(DispatchError):
    """Dispatch problem due to bad mapping.

    These are generated when dispatch has some problem finding a handler due to
    a problem in the mapper configuration. For example, perhaps there was no
    mapper object to use.  For problems with specific patterns or handlers, use
    BadPatternError or BadHandlerError.
    """
    def __init__(self, message, mapping=None):
        DispatchError.__init__(self, message)
        self.mapping = mapping
        self.old_error = None

    def __str__(self):
        return "%s: %s" % (self.message, self.mapping)


class BadPatternError(BadMappingError):
    """Dispatch problem due to bad pattern.

    These are generated when a mapper has some problem working with
    a pattern. For example, a RegexMapper may raise it when it is given
    a string that isn't a valid regex. Mapper classes should raise this
    for any invalid pattern specification.
    """
    pass


class BadHandlerError(BadMappingError):
    """Dispatch problem due to bad handler.

    These are generated when dispatch fails due to some problem with the
    handler.
    """
    pass


class Mapper(object):
    """Interface class for mappers.

    You can subclass this to define your own way of mapping request URIs to
    WSGI callables, but you don't have to; it's really just a reference for the
    interface.
    """
    def __init__(self, mappings, canonicalize=None):
        # Mapper classes should usually self.add(mappings) but override this if
        # you have to. n.b.: set up anything required for self.add() BEFORE
        # base class init.
        self.canonicalize = canonicalize
        self.add(mappings)

    def map(self, environ, debug=False):
        """Find a handler which wants the specified request.

        :arg environ:
            WSGI environ dict representing the request.

        :arg debug:
            parameter indicating whether to generate log output tracing
            the match process; defaults to False (no logging).

        Should return a tuple: (handler, args, kwargs). handler is the matched
        handler if there was a match - otherwise None. The other two are
        captured arguments from the request: args is ordered arguments, and
        kwargs is keyword arguments. Using RegexMapper as an example of
        argument capturing, a match of the string 'foo' against "(?P<bonk>.+?)"
        might return {'bonk':'foo'}. With FriendlyMapper, that pattern is just
        "{bonk}"
        """
        raise NotImplementedError

    def add(self, mappings):
        """Add the given sequence of mappings to this mapper instance.

        Each mapping is a 3-tuple: (method, obj, handler): method is a string
        representation of an HTTP method (or '*' to mean 'ignore method'), obj
        can be anything recognized by the underlying mapper, and handler is
        a WSGI callable.

        This method should raise BadPatternError for patterns which don't
        make sense for the specific subclass, BadHandlerError for handlers
        which fail some requirement imposed by the subclass (unnecessary),
        BadMappingError for a bad pairing.
        """
        raise NotImplementedError

    def reverse(self, handler, *args, **kwargs):
        """For a given handler, return the URI for reaching it.

        args and kwargs will be made available to fill in the pattern as
        a template to produce the URI. mappers should preferentially use the
        provided kwargs, and not use args at all if they don't define unnamed
        capture groups in the pattern.

        Subclasses which can't or choose not to support this should raise
        NotImplementedError. If the subclass supports reversing but can't
        do a particular reversal, it should return None.
        """
        raise NotImplementedError


def extract_re_args(matcher, match):
    # Get captured args. Getting out the ordered ones is a little
    # contorted and they can't be interleaved with kwargs in the
    # handler call; don't know if it's really worth it.
    if match.lastindex is not None:
        arg_indices = [i for i in range(1, match.lastindex + 1) \
                       if i not in matcher.groupindex.values()]
        args = [match.group(i) for i in arg_indices]
    else:
        args = []
    kwargs = match.groupdict()
    return (args, kwargs)


class RegexMapper(Mapper):
    """Map URIs to handlers using an ordered sequence of regular expressions.
    """
    def __init__(self, mappings=None, canonicalize=None):
        self.canonicalize = canonicalize
        # Sequence of (method, pattern, matcher, handler) tuples
        # for mapping requests to handlers by serial matching
        # (400 rules could be 400 sequential matches...)
        self._forward_mappings = []
        # Map each handler to a list of (method, pattern, matcher) tuples
        # for URL reversal and finding handler's accepted methods
        self._reverse_mappings = {}
        # Set of (method, pattern) tuples representing what's already here,
        # for avoiding dupes
        self._added_mappings = set([])
        if mappings is not None:
            self.add(mappings)

    def _path(self, environ):
        path = environ.get('PATH_INFO')
        return path

    def map(self, environ, debug=False):
        # This mapper only cares about method and path.
        request_method = environ.get('REQUEST_METHOD')
        path = self._path(environ)

        # Scan the stored mappings looking for a match.
        match, handler = None, None
        if debug and not self._forward_mappings:
            logging.warning("Mapper is empty and therefore cannot match")
        for mapping in self._forward_mappings:
            method, pattern, matcher, handler = mapping
            if method != "*" and request_method != method:
                if debug:
                    logging.debug("rejected %s: method %s (expected %s)",
                                  repr(pattern), request_method, method)
                continue
            match = matcher.match(path)
            if not match:
                if debug:
                    logging.debug("rejected %s: path %s",
                                  repr(pattern), repr(path))
                continue
            else:
                args, kwargs = extract_re_args(matcher, match)
                if debug:
                    logging.debug("matched %s %s to %s -> handler %s (%s, %s)",
                            repr(request_method), repr(path), repr(pattern),
                            repr(handler), repr(args), repr(kwargs))
                break

        # Always return a 3-tuple representing the call to be made
        if match:
            return handler, args, kwargs
        else:
            return None, None, None

    def add(self, mappings):
        if not mappings:
            return
        for mapping in mappings:
            if len(mapping) == 3:
                method, pattern, handler = mapping
            elif len(mapping) == 2:
                pattern, handler = mapping
                method = '*'
            else:
                raise BadMappingError("Couldn't unpack mapping tuple",
                                      mapping)
            if not callable(handler):
                raise BadHandlerError(
                    "attempt to use non-callable as a handler: %s",
                    str(handler))
            if (method, pattern) in self._added_mappings:
                continue
            matcher = self._compile_pattern(pattern)
            self._forward_mappings.append((method, pattern, matcher, handler))
            self._reverse_mappings[handler] = (method, pattern, matcher)
            self._added_mappings.add((method, pattern))

    @classmethod
    def _compile_pattern(cls, pattern):
        """Internal use only: Check pattern type and try to compile it to re.
        """
        _compiled_re_type = type(re.compile(""))
        # if pattern is a string, compile it to a regex
        if isinstance(pattern, basestring):
            try:
                pattern = re.compile(pattern)
            except re.error:
                raise BadPatternError("regex did not compile")
        # if not a string or regex, throw up hands
        elif not isinstance(pattern, _compiled_re_type):
            raise BadPatternError("pattern has unrecognized type")
        return pattern

    def reverse(self, handler, **kwargs):
        method, pattern, matcher = self._reverse_mappings[handler]
        uri = _reverse_regex(pattern, matcher, kwargs)
        return uri


def _split_by_re_match(regex, original):
    """Split out text in a regex's groups vs. text not in its groups.

    This is a helper for friendly_to_re, which converts strings like
    "/action/{foo}/{bar}/*" into regular expressions for FriendlyMapper.

    This can be helpful when you want both all the grouped text and all the
    ungrouped text without two passes over the input. For example, you can use
    this on a string, process each kind of text differently and then recombine
    using zip() or izip().

    :returns: a tuple: (list of unmatched strings, list of matched strings)
    such that running zip() on the resulting tuple will give all the pieces of
    text in original order. (It's still up to you to join them if you want to)
    """
    if isinstance(regex, basestring):
        regex = re.compile(regex)
    unmatched = []
    matched = []
    position = 0
    for match in regex.finditer(original):
        unmatched.append(original[position:match.start()])
        matched.append(match.group(1))
        position = match.end()
    unmatched.append(original[position:])
    matched.append("")
    return unmatched, matched


def _reverse_regex(pattern, regex, kwparms):
    """Internal: 'reverse' a regex with named capture groups.
    This WON'T handle unnamed capture groups.
    This can be expected to fail for many possible regexps.
    This can't be expected to do ANYTHING for other classes and I don't
    really recommend using it
    """
    # Algorithm by Gerald Thibault,
    # http://stackoverflow.com/questions/4927971/
    # don't bother importing sre_parse unless this is used, please...
    import sre_parse
    if hasattr(regex.groupindex, "iteritems"):
        cache = dict((v, k) for k, v in regex.groupindex.iteritems())
    else:
        # Python 3
        cache = dict((v, k) for k, v in regex.groupindex.items())
    return "".join(
        [chr(i[1]) if i[0] == 'literal' else str(kwparms[cache[i[1][0]]]) \
         for i in sre_parse.parse(pattern) if i[0] != 'at'])


def friendly_tagname(something):
    "Turn a friendlycapture group name into a regex capture group."
    if not something:
        return ""
    if something == "*":
        return "(.+?)"
    tag = something[1:-1]
    first = ''
    if tag[0] in ('.', '/'):
        first = tag[0]
        tag = tag[1:]
    if first:
        return "(?:[%s](?P<%s>.*?))?" % (first, tag)
    return "(?P<%s>.+?)" % something.strip("{}")


def friendly_to_re(pattern):
    """Converts strings with * globs and {name} groups into regex strings.

    At this point it's just a helper for FriendlyMapper, but if you want to use
    the same expression language for something else it might be handy.
    """
    group_name_re = re.compile("({[/.]?[^/.]+?}|\*)")

    # Split out the stuff from pattern into two streams: the stuff which is
    # * or in {}, and everything else. The first are tags, the second literal
    # text.
    unmatched, matched = _split_by_re_match(group_name_re, pattern)
    matched = [friendly_tagname(item) for item in matched]
    unmatched = [re.escape(item) for item in unmatched]
    regex = "".join(["".join(item) for item in zip(unmatched, matched)])
    return "^%s\Z" % regex


class _FriendlyReverseHelper(object):
    """Internal object used by FriendlyMapper.reverse.

    return "{0}" ... "{6}" if called six times, so re.sub
    can replace each * with a string reflecting its numeric index.
    """
    def __init__(self):
        self.position = 0

    def __call__(self, match):
        buf = "{%d}" % self.position
        self.position += 1
        return buf


class FriendlyMapper(RegexMapper):
    """Map URIs to handler using friendly expressions.

    Regex is usable for this purpose (and very flexible), but it is often not
    optimal. Usually, (?P<foo>.+) is just too verbose and easy to mess up.
    Also, a lot of beginner-to-intermediate programmers are not intimately
    comfortable with regex, and the algorithm for producing URLs given patterns
    (reverse mapping) is fairly complex.

    So this class expresses a more 'friendly' set of rules which are internally
    converted to a subset of regex for fast matching. These rules are also far
    less complex to reverse.

    "*" is used as a wildcard which matches one or more printable characters
    non-greedily, as in the regex (.+?). Matching starts from the beginning of
    the string and ends at the end, implicitly bracketing the pattern with
    ^ and \Z. Capture groups are delimited by {}, with the name inside the
    braces, e.g. {name}; those are also (.+?).

    So for example, this string defines groups slug and page::

        /articles/{slug}/{page}

    This string defines a named group and two unnamed groups::

        /*_{suffix}/*

    """
    def __init__(self, mappings=None, canonicalize=None):
        self._readable_mappings = set([])
        self._reverse_friendly_dict = {}
        if not mappings:
            mappings = []
        RegexMapper.__init__(self, canonicalize=canonicalize)
        self.add(mappings)

    def add(self, mappings):
        if not mappings:
            return
        mappings = [(('*',) + mapping) if len(mapping) == 2 else mapping
                    for mapping in mappings]
        # if we know about a canonicalize function, check that we aren't
        # making any patterns unreachable with that canonicalize function
        if self.canonicalize:
            for mapping in mappings:
                method, pattern, handler = mapping
                # generate a string which will match with 'X' in each group
                interpolated = re.sub("({.*?}|\*)", "X", pattern)
                # if canonicalize changes this, it won't match
                if self.canonicalize(interpolated) != interpolated:
                    raise BadPatternError(
                            "pattern cannot match with canonicalize=%s. "
                            "Make sure pattern is in matching canonical form."
                            % (repr(self.canonicalize)),
                            mapping)
        RegexMapper.add(self, self._convert_mappings(mappings))
        for readable in mappings:
            method, pattern, handler = readable
            if readable not in self._readable_mappings:
                self._readable_mappings.add(readable)
                self._reverse_friendly_dict[handler] = (method, pattern)

    @classmethod
    def _convert_mappings(cls, mappings):
        """Change a sequence of mappings into a list of mappings which
        RegexMapper can handle.
        """
        return [(method, friendly_to_re(pattern), handler)
                for (method, pattern, handler) in mappings]

    def reverse(self, handler, *args, **kwargs):
        """For a given handler, return the URI for reaching it.

        args and kwargs will be made available to fill in the pattern as
        a template to produce the URI.

        If a handler takes a parameter as an optional/keyword argument, that
        parameter MUST be passed to reverse as a keyword argument, or the
        result will be wrong.
        """
        pattern = self._reverse_friendly_dict[handler][1]
        # First substitute in the kwargs
        try:
            uri = pattern.format(**kwargs)
        except AttributeError as exception:
            if isinstance(pattern, str) \
               and re.match("'.+' object has no attribute 'format'",
                        exception.message):
                # I am not implementing new-style formatting in 2.5, so...
                raise NotImplementedError("FriendlyMapper.reverse is not "
                                          "available in Python < 2.6")
            raise
        # Now substitute the ordered args
        try:
            uri = re.sub("(\*)", _FriendlyReverseHelper(), uri).format(*args)
        except IndexError as exception:
            if re.match("tuple index out of range", exception.message):
                raise Exception("reverse() needs more ordered args "
                                "to reconstruct URLs for this handler")
            raise
        return uri


def default_not_found(environ, start_response):
    """Default handler function for not-found (404)
    """
    logging.error("Handler not found for path: %s",
                  repr(environ.get('PATH_INFO', None)))
    status = "404 Not Found"
    headers = []
    start_response(status, headers)
    return [b"404: Not Found"]


# Any number of path segments terminated by one with no . and no trailing slash
NO_TRAILING_SLASH_RE = re.compile("^((?:/[^/]*)*)(/[^\./]+)\Z")


def ensure_trailing_slash(path):
    """Ensure that a path ends with a slash if it doesn't look like 'foo.bar'.

    Suitable as a 'canonicalize' function.
    """
    if NO_TRAILING_SLASH_RE.match(path):
        path = path + '/'
    return path


def no_trailing_slash(path):
    """Ensure that a path never ends with a slash.

    Suitable as a 'canonicalize' function.
    """
    if path[-1] == '/':
        path = path[:-1]
    return path


def consume_prefix(prefix, environ):
    """Shift the prefix (if present) from PATH_INFO to SCRIPT_NAME.

    This changes the environ. If you don't want that, don't use it, or
    use it on a copy.

    As compared with the similar wsgiref.util.shift_path_info, this does
    less work and does not generate SCRIPT_NAME values ending in /.
    """
    assert not prefix.endswith('/')
    path = environ.get('PATH_INFO', '')
    if path == '' or not path.startswith(prefix):
        return
    position = len(prefix)
    script_name = environ.get('SCRIPT_NAME', '')
    environ['SCRIPT_NAME'] = script_name + path[:position]
    environ['PATH_INFO'] = path[position:]


def dispatch(environ, start_response, mappings=None, mapper=None, default=None,
             canonicalize=None, canonical_redirect=True, debug=False,
             prefix='', **kwargs):
    """Find a WSGI handler to handle a request.

    This is an imperative function for cases where you do not need an object or
    want to implement your own without reinventing the wheel.

    :arg environ:
        WSGI environ dict, to pass to the handler.

    :arg start_response:
        WSGI start_response callable, to pass to the handler.

    :arg mappings: sequence of tuples for the mapper. For example,
        ('GET', r'fooba.+', some_handler_function) works for RegexMapper.
        If not specified, the dispatcher won't be able to find a handler for
        any request. If mappings contain named capture groups, the captured
        values will be passed to the handler as keyword arguments.

    :arg mapper: as an alternative to passing mappings (that will be used
        internally to construct a mapper), you can specify an arbitrary mapper
        object to be used by the dispatcher. If this argument is not specified,
        an instance of FriendlyMapper will be created using the mappings
        arg.

    :arg default: set this to a WSGI callable to use your own 404
        handling when the mapper cannot find a handler.

    :arg canonicalize:
        A function used to convert incoming request paths to
        a normalized form before trying to match them. Supplied
        functions include ensure_trailing_slash and no_trailing_slash
        but you can also write your own function; it must take
        a PATH_INFO value and return a corrected one.

        Not applicable if a mapper is passed in.

        Warning: be careful that the canonicalize function does not
        generate patterns which are unmatchable by your mapper. For
        example, if you tell the mapper to match '/foo' but canonicalize
        incoming '/foo' requests to '/foo/', then they will not match.

    :arg canonical_redirect:
        If True (default), generate 301 redirects from non-canonical request
        paths to correct ones. Use False to just serve the request (thus, /a
        and /a/ will work the same, which may look like duplicate documents to
        search engines).
        Not applicable if a mapper is passed in, and does nothing if
        canonicalize=None.

    :arg debug:
        If True, trace what happens during dispatch. This generates
        a lot of noisy log output, but can be helpful in finding problems.

    :arg prefix:
        PATH_INFO prefix to shift to SCRIPT_NAME. If not present, will
        dispatch to default handler.

    :returns:
        Whatever value it got from the handler or default handler.
    """
    # Make a mapper object if one was not passed in.
    if not mapper:
        if not mappings:
            raise BadMappingError("no mapper or mappings")
        if debug:
            logging.debug("no mapper specified, creating")
        mapper = FriendlyMapper(mappings, canonicalize=canonicalize)

    # Sanity check: must have a method
    method = kwargs.get('method', environ.get('REQUEST_METHOD', None))
    if not method:
        raise BadRequestError("no HTTP method")

    if prefix:
        if not environ.get('PATH_INFO', '').startswith(prefix):
            return default(environ, start_response)
        consume_prefix(prefix, environ)

    # Normalize the path, if requested, before trying to map
    canonicalized = False
    if canonicalize:
        request_path = environ.get('PATH_INFO')
        normalized_path = canonicalize(request_path)
        if normalized_path != request_path:
            # The mapper and downstream may use any part of environ,
            # so it's either in-place modification or a copy.
            # WSGI says: 'the application is allowed to modify the
            # dictionary in any way it desires'
            environ['PATH_INFO'] = normalized_path
            if debug:
                logging.debug("normalized %s to %s", repr(request_path),
                              repr(normalized_path))
            canonicalized = True
            del request_path

    handler, args, kwargs = mapper.map(environ, debug=debug)

    # Generate a permanent redirect iff requested, the canonicalization
    # was any different, and there is a handler to receive redirect
    if canonical_redirect and canonicalized and handler:
        if debug:
            logging.debug("redirecting to canonical path")
        start_response("301 Use Canonical URL",
                       [('Location', normalized_path)])
        return ['']

    # Make information extracted during routing available to WSGI handlers
    # without introducing weird signature or global/threadlocal state
    if environ:
        environ['wsgiorg.routing_args'] = (args, kwargs)

    # Defer to a default handler if we can't find another handler
    if not handler:
        default = default if default is not None else default_not_found
        if not callable(default):
            raise BadMappingError("uncallable default handler",
                    repr(default))
        if debug:
            logging.debug("no matches found, defaulting to %s",
                          repr(default))
        return default(environ, start_response)

    return handler(environ, start_response)


def _route_decorator(*methods):
    """Create a route decorator method for a particular set of HTTP
    methods.

    This is neither a method nor a class method and should not be used as
    such, it's just a function which happens to be an attribute of the
    class and is used to generate methods.
    """
    def decorator(self, obj):
        "Generate the decorator which will be bound as a method."
        def wrapper(function):
            # n.b. if this wrapper is applied to a method in a class
            # definition, function will be an unbound method right now and
            # calling it without a self will fail. The self should be an
            # instance of the class the wrapped method is defined on.
            # So ideally we'd bind it to the instance but we do not have that
            # instance, only the dispatcher which shouldn't be used for that.
            # well, one way of doing this is with a descriptor at the time of
            # attribute access, but if other decorators are stacked on top,
            # THEY will wrap something which is not bound yet. the best chance
            # is for them to wrap something which will wrap exactly as expected
            # sometime after they might be accessed as attributes,
            # i.e. at the time they're called.
            self.add([(method, obj, function) for method in methods])
            return function
        wrapper.__doc__ = (
            "Register route for '{0} {1}' on this dispatcher."
            .format(", ".join(methods), obj))
        return wrapper
    decorator.__doc__ = ("Generate route decorator for HTTP %s"
                         % (", ".join(methods)))
    return decorator


class Dispatcher(object):
    """Object for dispatch, used to find and run request handlers.

    Works as a WSGI app object, so you can (for example) pass one of these as
    the entry point to your application.

    If you just want to query routes, use a Mapper directly.
    By default, this uses a FriendlyMapper, but any mapper will work.
    """
    def __init__(self, *mappings, **kwargs):
        """Create a Dispatcher object.

        :arg *mappings:
            rule-defining items for the mapper.
            For example, the 3-tuple ('GET', r'fooba.+', some_handler_function)
            works for RegexMapper. If not specified, the dispatcher won't be
            able to find a handler for any request. If mappings contain named
            capture groups, the captured values will be passed to the handler
            as keyword arguments.
            Not applicable if a mapper is passed in.

        :arg mapper:

        :arg default: WSGI callable to invoke instead of a handler,
            when there is no match and no handler can be found to run.

        :arg canonicalize:
            A function used to convert an incoming PATH_INFO to a correct
            'canonical' form, e.g. by transforming case and fixing trailing
            slash, before looking for matches.
            Not applicable if a mapper is passed in.

        :arg canonical_redirect:
            If True, generate 301 redirects from non-canonical request
            paths to correct ones.
            Not applicable if a mapper is passed in.

        :arg debug:
            If True, trace what happens during dispatch.

        :arg wrap:
            A callable taking a handler argument and returning a wrapped
            version of the same handler. The returned one is what will
            be run by the Dispatcher but is not seen externally. The
            inner, unwrapped handler is what reverse() uses.
        """
        defaults = dict(
                canonicalize=None,
                canonical_redirect=True,
                debug=False,
                default=None,
                mapper=None,
                prefix='',
                wrap=None,
                )
        # Python 2 doesn't allow (*args, foo=None) but emulation with
        # kwargs should not fail silently when given unexpected
        # arguments, so manually check given args against expectations.
        for key in kwargs.keys():
            if key not in defaults:
                raise TypeError(
                    "__init__() got an unexpected keyword argument '%s'", key)
        for key in defaults.keys():
            setattr(self, key, kwargs.get(key, defaults[key]))
        self.wrappers = {}
        if self.mapper is None:
            self.mapper = FriendlyMapper([], canonicalize=self.canonicalize)
            self.add(mappings)

    def add(self, mappings):
        """Add sequence of mappings to this dispatcher (i.e., its mapper).

        Each mapping is a 3-tuple: (method, obj, handler): method is a string
        representation of an HTTP method (or '*' to mean 'ignore method'), obj
        can be anything recognized by the underlying mapper, and handler is
        a WSGI callable.
        """
        if not mappings:
            return
        if self.wrap:
            for i, mapping in enumerate(mappings):
                if len(mapping) == 2:
                    method, obj, original = ('*',) + mapping
                else:
                    method, obj, original = mapping
                wrapper = self.wrap(original)
                self.wrappers[original] = wrapper
                mappings[i] = method, obj, wrapper
        return self.mapper.add(mappings)

    def route(self, methods, mapping):
        """Generate decorator to route specified HTTP methods to the given
        handler assuming a match to the given object.

        Normally you'd use the constructor or add() method or a specific
        shorcut decorator like @GET, but sometimes it is also necessary to
        route a particular combination of methods or implement a rarer method
        like TRACE.
        """
        def wrapper(function):
            self.add([(method, mapping, function) for method in methods])
        return wrapper

    GET = _route_decorator('GET', 'HEAD')
    POST = _route_decorator('POST')
    PUT = _route_decorator('PUT')
    DELETE = _route_decorator('DELETE')
    HEAD = _route_decorator('HEAD')
    OPTIONS = _route_decorator('OPTIONS')
    PATCH = _route_decorator('PATCH')

    def route_decorator(self, *methods):
        """Create a decorator which adds decorated handlers to this Dispatcher
        for the given methods.

        Example::

            d = Dispatcher()
            PUT_OR_DELETE = d.route_decorator(['PUT', 'DELETE'])
            @PUT_OR_DELETE('/everything')
            def destroy_everything(environ, start_response):
                ...

        """
        # _route_decorator is not a method. Use it to make an unbound method.
        # Then bind that unbound method to self to make it self's bound method.
        f = _route_decorator(*methods)
        return f.__get__(self, Dispatcher)

    def __call__(self, environ, start_response, **kwargs):
        """Find a handler and run it.

        This method makes a Dispatcher object a WSGI application callable, so
        you can give the dispatcher to your server as an entry point for your
        app. If you need to customize behavior by passing other arguments, you
        can call the dispatcher manually to pass them.
        """
        return dispatch(environ=environ, start_response=start_response,
                        mapper=self.mapper, default=self.default,
                        canonicalize=self.canonicalize,
                        canonical_redirect=self.canonical_redirect,
                        debug=self.debug, prefix=self.prefix,
                        **kwargs)

    def reverse(self, handler, *args, **kwargs):
        """Do a reverse mapping for the given handler.
        """
        if not hasattr(self.mapper, "reverse"):
            return None
        # If user provided something we wrapped, look up the wrapped one.
        handler = self.wrappers.get(handler, None) or handler
        path = self.mapper.reverse(handler, *args, **kwargs)
        return self.prefix + path


class _DummyStartResponse(object):
    """Simple dummy callable for intercepting status data from handlers'
    start_response calls.

    Used by Cascade, to detect when a handler has returned 404.

    If you want something like this to import, look at the nicer
    wsgi.StartResponse instead; this is here just to avoid an internal
    dependency.
    """
    def __init__(self):
        self.called = False
        self.status = ""
        self.headers = []
        self.exc_info = None

    def __call__(self, status, headers, exc_info=None):
        self.called = True
        self.status = status
        self.headers = headers
        self.exc_info = exc_info


class Cascade(object):
    """Set up a chain of handlers, each defaulting to the next in the case that
    it 404s (communicates a failure to match).

    This lets each handler refuse responsibility for a request by returning
    404, without halting all work and presenting a 404 to the user; instead the
    dispatch to the failed handler can be 'backed out' and others can be tried
    before really failing in the end.

    Errors should not be suppressed, and therefore do not cascade.
    Each handler does have to be run to discover whether or not it will 404, so
    it's up to you to ensure that handlers earlier in the chain do not
    invisibly make inappropriate changes.
    """
    def __init__(self, *handlers, **kwargs):
        self.handlers = handlers
        default = kwargs.get('default', None)
        self.default = default if default is not None else default_not_found

    def __call__(self, environ, start_response):
        interceptor = _DummyStartResponse()
        iterable = None

        for handler in self.handlers:
            iterable = handler(environ, interceptor)

            # If handler fails at WSGI, BadHandlerError (as in dispatch)
            # rather than mysteriously skipping to next handler.
            if not interceptor.called:
                raise BadHandlerError("Handler did not call start_response")
            try:
                iter(iterable)
            except TypeError:
                raise BadHandlerError("Handler returned non-iterable")
            # If we got here, we should have data for a response.

            # Stop cascade and return results if not 404
            status_code = int(interceptor.status.split(" ", 1)[0])
            if interceptor.exc_info or status_code != 404:
                break
            # If this is the last iteration, the below will just send the last
            # returned data.

        # If we got a non-404 OR if the last returned response is a 404,
        # deliver whatever we have, as long as we have something.
        if interceptor.called and iterable is not None:
            start_response(interceptor.status, interceptor.headers,
                           exc_info=interceptor.exc_info)
            return iterable

        # Worst case of no usable data: default to the hard-coded 404.
        return self.default(environ, start_response)


class Resource(object):
    """HTTP method dispatcher which can handle 405s.

    To just bundle up some handlers, you want the resource() convenience
    function. For more customizability, you can subclass Resource.
    Either way, you end up with a class object which will serve as a
    WSGI app object, called (i.e., instantiated) by the server.

    Making the class itself the app (and its instances the iterables)
    helps to prevent the security and threading problems caused by the
    temptation to store request data on 'self'.

    If you like class-based handlers but don't want internal method
    dispatch or 405s, you can wrap a class with @WSGI; just make sure
    that __init__ takes environ and that the instance is a response
    object or iterable.
    """
    # This class variable can be changed to some arbitrary WSGI callable
    # to customize 'wrong method' handling.
    default = None
    # Whitelist to avoid letting clients send arbitrary nonsense; change
    # this in subclass if you need to use some other set of methods.
    recognized_methods = set(["GET", "HEAD", "POST", "PUT", "DELETE",
                              "OPTIONS", "TRACE", "CONNECT"])
    handlers = {}

    def __init__(self, *args, **kwargs):
        """What happens when the class is called by server to handle a request.

        This method handles configuration of an instance and should not
        normally need to be overridden; run behavior is in the
        instance's __call__.
        """
        # make a copy of the class dict on the instance, for local
        # changes; can't reference bound methods at class level
        self.handlers = self.handlers.copy()
        # inspect self for methods with names of recognized methods (in
        # lowercase), if present then insert them in handlers. this
        # allows Resource app classes to be written simply.
        for name in self.recognized_methods:
            value = getattr(self, name.lower(), None)
            if value:
                self.handlers[name] = value

        # If no class default set for handling 'wrong method', use
        # self.wrong_method().
        if not self.default:
            self.default = self.wrong_method
        # Override __call__ in subclass to customize run behavior, not config.
        result = self(*args)
        self.iterable = result

    def __call__(self, *args, **kwargs):
        """Implement a callable (e.g. WSGI) interface for the instance,
           mapping to the same interface for each method.

        This is the method you want to override if you do not like the
        provided behavior. __init__ is for internal bookkeeping.
        """
        # Allow first arg to be environ-like or just a method string
        # (gotta have at least that to do internal method dispatch).
        try:
            first = args[0]
            request_method = first.get('REQUEST_METHOD', '')
        except AttributeError:
            request_method = first
        # Internal method dispatch.
        if request_method in self.recognized_methods:
            handler = self.handlers.get(request_method.upper()) or self.default
        else:
            handler = self.default
        # The Resource instance itself will be the iterable. Resist the urge to
        # use a non-WSGI calling convention here because it would preclude the
        # use of any handlers not specifically written for this class.
        result = handler(*args, **kwargs)
        assert result
        return result

    def __iter__(self):
        return iter(self.iterable)

    def wrong_method(self, environ, start_response):
        """Specify what to do when we can't handle the REQUEST_METHOD.

        If the class variable 'default' is set to something other than
        None, this won't necessarily be called.
        """
        # no need to quote the method, that would allow arbitrary data to be
        # put in the returned status
        status = "405 Method not allowed"
        allow_value = ','.join(sorted(self.handlers.keys()))
        headers = [('Allow', allow_value)]
        body = b'405: Method not allowed'
        start_response(status, headers)
        return [body]

    @classmethod
    def add(cls, **handlers):
        """Add or change handlers.
        """
        cls.handlers.update(handlers)


def resource(name="App", default=None, recognized_methods=None, **handlers):
    """Shortcut to make a Resource subclass inline.

    For example::

        resource(GET=foo, POST=baz)

    returns a class object which is a subclass of Resource. The returned
    class is the WSGI app object; its instances are just iterables for
    the server to iterate over.

    You can pass the 'default' or 'recognized_methods' arguments to
    configure the generated app without subclass-and-override.
    """
    class Cls(Resource):
        handlers = {}
        methods = set([])
    Cls.__name__ = name
    if recognized_methods:
        Cls.recognized_methods = recognized_methods
    Cls.default = default
    Cls.handlers = handlers
    return Cls
