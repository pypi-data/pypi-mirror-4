

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tabular.tab &mdash; tabular v0.0.8 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="tabular v0.0.8 documentation" href="../index.html" />
    <link rel="next" title="tabular.io" href="tabular.io.html" />
    <link rel="prev" title="Web &amp; HTML" href="../reference/web.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tabular.io.html" title="tabular.io"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../reference/web.html" title="Web &amp; HTML"
             accesskey="P">previous</a> |</li>
    
        <li><a href="../index.html">tabular</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-tabular.tab">
<span id="tabular-tab"></span><h1><a class="reference internal" href="#module-tabular.tab" title="tabular.tab"><tt class="xref py py-mod docutils literal"><span class="pre">tabular.tab</span></tt></a><a class="headerlink" href="#module-tabular.tab" title="Permalink to this headline">¶</a></h1>
<p>Class and functions pertaining to the tabular.tabarray class.</p>
<p>The <a class="reference internal" href="#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabarray</span></tt></a> class is a column-oriented hierarchical data object and 
subclass of <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html?highlight=ndarray#numpy.ndarray">numpy.ndarray</a>.</p>
<p>The basic structure of this module is that it contains:</p>
<ul class="simple">
<li>The tabarray class.</li>
<li>Some helper functions for tabarray.  The helper functions are precisely 
those necessary to wrap functions from the <a class="reference internal" href="tabular.spreadsheet.html#module-tabular.spreadsheet" title="tabular.spreadsheet"><tt class="xref py py-mod docutils literal"><span class="pre">tabular.spreadsheet</span></tt></a> 
module that operate on lists of arrays, to handle tabular&#8217;s additional 
structure.  These functions are named with the convention &#8220;tab_FNAME&#8221;, e.g. 
&#8220;tab_rowstack&#8221;, &#8220;tab_join&#8221; &amp;c.  The functions in <a class="reference internal" href="tabular.spreadsheet.html#module-tabular.spreadsheet" title="tabular.spreadsheet"><tt class="xref py py-mod docutils literal"><span class="pre">tabular.spreadsheet</span></tt></a> 
that only take a single array are all wrapped JUST as methods of tabarray, 
and not as separate functions.</li>
</ul>
<dl class="class">
<dt id="tabular.tab.tabarray">
<em class="property">class </em><tt class="descclassname">tabular.tab.</tt><tt class="descname">tabarray</tt><a class="headerlink" href="#tabular.tab.tabarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt></p>
<p>Subclass of the numpy ndarray with extra structure and functionality.</p>
<p>tabarray is a column-oriented data object based on the numpy ndarray with
structured dtype, with added functionality and ability to define named 
groups of columns.</p>
<p>tabarray supports several i/o methods to/from a number of file formats, 
including (separated variable) text (e.g. <tt class="docutils literal"><span class="pre">.txt</span></tt>, <tt class="docutils literal"><span class="pre">.tsv</span></tt>, <tt class="docutils literal"><span class="pre">.csv</span></tt>), 
numpy binary (<tt class="docutils literal"><span class="pre">.npz</span></tt>) and hierarchical separated variable (<tt class="docutils literal"><span class="pre">.hsv</span></tt>).</p>
<p>Added functionality includes spreadsheet style operations such as &#8220;pivot&#8221;, 
&#8220;aggregate&#8221; and &#8220;replace&#8221;.</p>
<p>See docstring of the tabarray.__new__ method, or the Tabular reference documentation, for data on constructing a tabarrays.</p>
<dl class="staticmethod">
<dt id="tabular.tab.tabarray.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>subtype</em>, <em>array=None</em>, <em>records=None</em>, <em>columns=None</em>, <em>SVfile=None</em>, <em>binary=None</em>, <em>HSVfile=None</em>, <em>HSVlist=None</em>, <em>shape=None</em>, <em>dtype=None</em>, <em>formats=None</em>, <em>names=None</em>, <em>titles=None</em>, <em>aligned=False</em>, <em>byteorder=None</em>, <em>buf=None</em>, <em>offset=0</em>, <em>strides=None</em>, <em>comments=None</em>, <em>delimiter=None</em>, <em>lineterminator='n'</em>, <em>escapechar=None</em>, <em>quoting=None</em>, <em>quotechar=None</em>, <em>doublequote=True</em>, <em>skipinitialspace=False</em>, <em>skiprows=0</em>, <em>uselines=None</em>, <em>usecols=None</em>, <em>excludecols=None</em>, <em>toload=None</em>, <em>metametadata=None</em>, <em>kvpairs=None</em>, <em>namesinheader=True</em>, <em>headerlines=None</em>, <em>valuefixer=None</em>, <em>linefixer=None</em>, <em>colfixer=None</em>, <em>delimiter_regex=None</em>, <em>coloring=None</em>, <em>inflines=2500</em>, <em>wrap=None</em>, <em>typer=None</em>, <em>missingvalues=None</em>, <em>fillingvalues=None</em>, <em>renamer=None</em>, <em>verbosity=5</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.__new__" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Unified constructor for tabarrays.</p>
<p><strong>Specifying the data:</strong></p>
<blockquote>
<div><p>Data can be passed to the constructor, or loaded from several 
different file formats.</p>
<p><strong>array</strong> :  two-dimensional arrays (<tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>)</p>
<blockquote>
<div><div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; import numpy
&gt;&gt;&gt; x = numpy.array([[1, 2], [3, 4]])
&gt;&gt;&gt; tabarray(array=x)
tabarray([(1, 2), (3, 4)], 
      dtype=[(&#39;f0&#39;, &#39;&lt;i4&#39;), (&#39;f1&#39;, &#39;&lt;i4&#39;)])
</pre></div>
</div>
<p><strong>See also:</strong>  <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromrecords.html#numpy.core.records.fromrecords">numpy.rec.fromrecords</a></p>
</div></blockquote>
<p><strong>records</strong> :  python list of records (elemets can be tuples or lists)</p>
<blockquote>
<div><div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; tabarray(records=[(&#39;bork&#39;, 1, 3.5), (&#39;stork&#39;, 2, -4.0)], names=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;])
tabarray([(&#39;bork&#39;, 1, 3.5), (&#39;stork&#39;, 2, -4.0)], 
      dtype=[(&#39;x&#39;, &#39;|S5&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;), (&#39;z&#39;, &#39;&lt;f8&#39;)])
</pre></div>
</div>
<p><strong>See also:</strong>  <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromrecords.html#numpy.core.records.fromrecords">numpy.rec.fromrecords</a></p>
</div></blockquote>
<p><strong>columns</strong> :  list of python lists or 1-D numpy arrays</p>
<blockquote>
<div><p>Fastest when passed a list of numpy arrays, rather than
a list of lists.</p>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; tabarray(columns=[[&#39;bork&#39;, &#39;stork&#39;], [1, 2], [3.5, -4.0]], names=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]) 
tabarray([(&#39;bork&#39;, 1, 3.5), (&#39;stork&#39;, 2, -4.0)], 
      dtype=[(&#39;x&#39;, &#39;|S5&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;), (&#39;z&#39;, &#39;&lt;f8&#39;)])
</pre></div>
</div>
</div></blockquote>
<p><strong>kvpairs</strong> : list of list of key-value pairs</p>
<blockquote>
<div>For loading key-value pairs (e.g. as from an XML file).    Missing values can be specified using the <strong>fillingvalues</strong> argument.</div></blockquote>
<p><strong>See also:</strong>  <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.core.records.fromrecords.html#numpy.core.records.fromarrays">numpy.rec.fromarrays</a></p>
<p><strong>SVfile</strong> :  string</p>
<blockquote>
<div><p>File path to a separated variable (CSV) text file.  
Load data from a CSV by calling:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.loadSV(SVfile, comments, delimiter, 
lineterminator, skiprows, usecols, metametadata, 
namesinheader, valuefixer, linefixer)
</pre></div>
</div>
<p><strong>See also:</strong>  <a class="reference internal" href="#tabular.tab.tabarray.saveSV" title="tabular.tab.tabarray.saveSV"><tt class="xref py py-func docutils literal"><span class="pre">saveSV()</span></tt></a>, 
<a class="reference internal" href="tabular.io.html#tabular.io.loadSV" title="tabular.io.loadSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadSV()</span></tt></a></p>
</div></blockquote>
<p><strong>binary</strong> :  string</p>
<blockquote>
<div><p>File path to a binary file. Load a <tt class="docutils literal"><span class="pre">.npz</span></tt> binary file 
created by the <a class="reference internal" href="#tabular.tab.tabarray.savebinary" title="tabular.tab.tabarray.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">savebinary()</span></tt></a> by calling:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.loadbinary(binary)
</pre></div>
</div>
<p>which uses <tt class="xref py py-func docutils literal"><span class="pre">numpy.load()</span></tt>.</p>
<p><strong>See also:</strong> <a class="reference internal" href="#tabular.tab.tabarray.savebinary" title="tabular.tab.tabarray.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">savebinary()</span></tt></a>, 
<a class="reference internal" href="tabular.io.html#tabular.io.loadbinary" title="tabular.io.loadbinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadbinary()</span></tt></a></p>
</div></blockquote>
<p><strong>HSVfile</strong> :  string</p>
<blockquote>
<div><p>File path to a hierarchical separated variable 
(<tt class="docutils literal"><span class="pre">.hsv</span></tt>) directory, or a comma separated variable 
(<tt class="docutils literal"><span class="pre">.csv</span></tt>) text file inside of a HSV directory 
corresponding to a single column of data.  Load a 
structured directory or single file defined by the 
<a class="reference internal" href="#tabular.tab.tabarray.saveHSV" title="tabular.tab.tabarray.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">saveHSV()</span></tt></a> method by calling:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.loadHSV(HSVfile, toload)
</pre></div>
</div>
<p><strong>See also:</strong> <a class="reference internal" href="#tabular.tab.tabarray.saveHSV" title="tabular.tab.tabarray.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">saveHSV()</span></tt></a>, 
<a class="reference internal" href="tabular.io.html#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a>, 
<a class="reference internal" href="tabular.io.html#tabular.io.loadHSVlist" title="tabular.io.loadHSVlist"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSVlist()</span></tt></a></p>
</div></blockquote>
<p><strong>HSVlist</strong> :  list of strings</p>
<blockquote>
<div><p>List of file paths to hierarchical separated variable
(<tt class="docutils literal"><span class="pre">.hsv</span></tt>) files and/or individual comma separated
variable (<tt class="docutils literal"><span class="pre">.csv</span></tt>) text files inside of HSV 
directories, all with the same number of records.  Load 
a list of file paths created by the <a class="reference internal" href="#tabular.tab.tabarray.saveHSV" title="tabular.tab.tabarray.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">saveHSV()</span></tt></a> 
method by calling:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.loadHSVlist(HSVlist)
</pre></div>
</div>
<p><strong>See also:</strong>  <a class="reference internal" href="#tabular.tab.tabarray.saveHSV" title="tabular.tab.tabarray.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">saveHSV()</span></tt></a>,  
<a class="reference internal" href="tabular.io.html#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a>, 
<a class="reference internal" href="tabular.io.html#tabular.io.loadHSVlist" title="tabular.io.loadHSVlist"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSVlist()</span></tt></a></p>
</div></blockquote>
</div></blockquote>
<p><strong>Additional parameters:</strong></p>
<blockquote>
<div><blockquote>
<div><p><strong>names</strong> : list of strings</p>
<blockquote>
<div>Sets the names of the columns of the resulting tabarray.   If not specified, <cite>names</cite> value is determined first by looking for metadata in the header of the file, and if that is not found, are assigned by NumPy&#8217;s <cite>f0, f1, ... fn</cite> convention.     See <strong>namesinheader</strong> parameter below.</div></blockquote>
<p><strong>formats</strong> :  string or list of strings</p>
<blockquote>
<div><p>Sets the datatypes of the columns.  The value of <cite>formats</cite> can be a list or comma-delimited string of values describing values for each column (e.g. &#8220;str,str,int,float&#8221; or [&#8220;str&#8221;, &#8220;str&#8221;, &#8220;int&#8221;, &#8220;float&#8221;]), a single value to apply to all columns, or anything that can be used in numpy.rec.array constructor.</p>
<p>If the <strong>formats</strong> (or <strong>dtype</strong>) parameter are not  specified, typing is done by inference.   (See also <strong>typer</strong> parameter below).</p>
</div></blockquote>
<p><strong>dtype</strong> : numpy dtype object</p>
<blockquote>
<div>Sets the numpy dtype of the resulting tabarray, combining 
column format and column name information.  If dtype is set, any <strong>names</strong> and <strong>formats</strong> specifications will be overriden.   If the <strong>dtype</strong> (or <strong>formats</strong>) parameter are not  specified, typing is done by inference.   (See also <strong>typer</strong> parameter below).</div></blockquote>
<p>The <strong>names</strong>, <strong>formats</strong> and <strong>dtype</strong> parameters duplicate parameters of the NumPy record array creation inferface.   Additional paramters of the NumPy inferface that are passed through are <strong>shape</strong>, <strong>titles</strong>, <strong>byteorder</strong> and <strong>aligned</strong> (see NumPy documentation for more information.)</p>
<p><strong>delimiter</strong> : single-character string</p>
<blockquote>
<div>When reading text file, character to use as delimiter to split fields.  If not specified, the delimiter is determined first by looking for special-format metadata specifying the delimiter, and then if no specification is found, attempts are made to infer delimiter from file contents.   (See <strong>inflines</strong> parameter below.)</div></blockquote>
<p><strong>delimiter_regex</strong> :  regular expression (compiled or in string format)</p>
<blockquote>
<div>Regular expression to use to recognize delimiters, in place of a single character.   (For instance, to have whitespace delimiting, using delimiter_regex = &#8216;[s*]+&#8217; )</div></blockquote>
<p><strong>lineterminator</strong> : single-character string</p>
<blockquote>
<div>Line terminator to use when reading in using SVfile</div></blockquote>
<dl class="docutils">
<dt><strong>skipinitialspace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>If true, strips whitespace following the delimiter from field.</dd>
</dl>
</div></blockquote>
<p>The <strong>delimiter</strong>, <strong>linterminator</strong> and <strong>skipinitialspace</strong> 
parameters are passed on as parameters to the python CSV module, 
which is used for reading in delimited text files.   Additional 
parameters from that interface that are replicated in this constructor include <strong>quotechar</strong>, <strong>escapechar</strong>, <strong>quoting</strong>, <strong>doublequote</strong> and <strong>dialect</strong> (see CSV module documentation for more information.)</p>
<blockquote>
<div><p><strong>skiprows</strong> :  non-negative integer, optional</p>
<blockquote>
<div>When reading from a text file, the first <cite>skiprows</cite> lines are ignored.  Default is 0, e.g no rows are skipped.</div></blockquote>
<p><strong>uselines</strong> : pair of non-negative integer, optional</p>
<blockquote>
<div>When reading from a text file, range of lines of data to load.  (In constrast to <strong>skiprows</strong>, which specifies file rows to ignore before looking for header information, <strong>uselines</strong> specifies which data (non-header) lines to use, after header has been striped and processed.)   See <strong>headerlines</strong> below.</div></blockquote>
<p><strong>usecols</strong> :  sequence of non-negative integers or strings, optional</p>
<blockquote>
<div>When reading from a text file, only the columns in <em>usecols</em> are loaded and processed.   Columns can be described by number, with 0 being the first column; or if name metadata is present, then by name ; or, if color group information is present in the file, then by color group name.   (Default is None, e.g. all columns are loaded.)</div></blockquote>
<p><strong>excludecols</strong> :  sequence of non-negative integers or strings, optional</p>
<blockquote>
<div>Converse of <strong>usecols</strong>, e.g. all columns EXCEPT those listed will be loaded.</div></blockquote>
<p><strong>comments</strong> : single-character string, optional</p>
<blockquote>
<div>When reading from a text file, character used to distinguish header lines.  If specified, any lines beginning with this character at the top of the file are assumed to contain header information and not row data.</div></blockquote>
<p><strong>headerlines</strong> : integer, optional</p>
<blockquote>
<div>When reading from a text file, the number of lines at the top of the file (after the first  <cite>skiprows</cite> lines) corresponding to the header of the file, where metadata can be found.   Lines after headerlines are assumed to contain row contents.   If not specified, value is determined first by looking for special metametadata  in first line of file (see Tabular reference documentation for more information about this), and if no such metadata is found, is inferred by looking at file contents.</div></blockquote>
<p><strong>namesinheader</strong> : Boolean, optional</p>
<blockquote>
<div>When reading from a text file, if <cite>namesinheader == True</cite>, then assume the column names are in the last header line (unless overridden by existing metadata or metametadata directive).    Default is True.</div></blockquote>
<p><strong>linefixer</strong> : callable, optional</p>
<blockquote>
<div>When reading from a text file, this callable is applied to every line in the file.  This option is passed on all the way to the call to <cite>io.loadSVrecord</cite> function, and is applied directly to the strings in the file, after they&#8217;re split in lines but before they&#8217;re split into fields or any typing is done.   The purpose is to make lines with errors or mistakes amenable to delimiter inference and field-splitting.</div></blockquote>
<p><strong>valuefixer</strong>  :  callable, or list or dictionary of callables, optional</p>
<blockquote>
<div>When reading from a text file, these callable(s) are applied to every value in each field.   The application is done after line strings are loaded and split into fields, but before any typing or missing-value imputation is done.  The purpose of the <strong>valuefixer</strong> is to prepare column values for typing and imputation.   The valuefixer callable can return a string or a python object.   If <cite>valuefixer</cite> is a single callable, then that same callable is applied to values in all column; if it is a dictionary, then the keys can be either numbers or names and the value for the key will be applied to values in the corresponding column with that name or number; if it is a list, then the list elements must be in 1-1 correponsdence with the loaded columns, and are applied to each respectively.</div></blockquote>
<p><strong>colfixer</strong> : callable, or list or dictionary of callables, optional</p>
<blockquote>
<div>Same as <strong>valuefixer</strong>,  but instead of being applied to individual values, are applied to whole columns (and must return columns or numpy arrays of identical length).    Like valuefixer, colfixer callable(s) are applied before typing and missing-value imputation.</div></blockquote>
<p><strong>missingvalues</strong> : string, callable returning string, or list or dictionary of strings or string-valued callable</p>
<blockquote>
<div>When reading from text file, string value to consider as &#8220;missing data&#8221; and to be replaced before typing is done.   If specified as a callable, the callable will be applied to the column(s) to determine missing value.   If specified as a dictionary, keys are expected to be numbers of names of columns, and values are individual missing values for those columns (like <strong>valuefixer</strong> inferface).</div></blockquote>
<p><strong>fillingvalues</strong> : string, pair of strings, callable returning string, or list or dictionary of strings or string-valued callable</p>
<blockquote>
<div>When reading from text file, values to be used to replace missing data before typing is done.   If specified as a  single non-callable, non-tuple value, this value is used to replace all missing data.  If specified as a callable, the callable is applied to the column and returns the fill value (e.g. to allow the value to depend on the column type).    If specified as a pair of values, the first value acts as the missing value and the second as the value to replace with.   If a dictionary or list of values, then values are applied to corresponding columns.</div></blockquote>
<p>NOTE:  all the <strong>missingvalues</strong> and <strong>fillingvalues</strong> functionalities can be replicated (and generalized) using the <strong>valuefixer</strong> or <strong>colfixer</strong> parameters, by specifying function(s) which identify and replace missing values.   While more limited, using <strong>missingvalues</strong> and <strong>fillingvalues</strong>  interface is easier and gives better performance.</p>
<p><strong>typer</strong>  :   callable taking python list of strings (or other values) and returning 1-dnumpy array ; or list dictionary of such callables</p>
<blockquote>
<div>Function used to infer type and convert string lists into typed numpy arrays, if no format information has been provided.   When applied at all, this function is applied after string have been loaded and split into fields.   This function is expected to impute missing values as well, and will override any setting of <strong>missingvalues</strong> or <strong>fillingvalues</strong>.    If a callable is passed,  it is used as typer for all columns, while if a dictionary (or list) of callables is passed, they&#8217;re used on corresponding columns.    If needed (e.g. because formatting information hasn&#8217;t been supplied) but <strong>typer</strong> isn&#8217;t specified (at least, for a given column), the constructor defaults to using the <cite>utils.DEFAULT_TYPEINFERER</cite> function.</div></blockquote>
<p><strong>inflines</strong> :  integer, optional</p>
<blockquote>
<div>Number of lines of file to use as sample data when inferring delimiter and header.</div></blockquote>
<p><strong>metametadata</strong> :  dictionary of integers or pairs of integers</p>
<blockquote>
<div>Specifies supplementary metametadata information for use 
with SVfile loading.  See Tabular reference documentation for more information</div></blockquote>
<p><strong>coloring</strong>:  dictionary</p>
<blockquote>
<div><blockquote>
<div>Hierarchical column-oriented structure.</div></blockquote>
<ul class="simple">
<li>Colorings can be passed as argument:<ul>
<li>In the <em>coloring</em> argument, pass a dictionary. Each 
key is a string naming a color whose corresponding
value is a list of column names (strings) in that 
color.</li>
<li>If colorings are passed as argument, they override
any colorings inferred from the input data.</li>
</ul>
</li>
<li>Colorings can be inferred from the input data:<ul>
<li>If constructing from a <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory, 
colorings will be automatically inferred from the 
directory tree.</li>
<li>If constructing from a CSV file (e.g. <tt class="docutils literal"><span class="pre">.tsv</span></tt>, 
<tt class="docutils literal"><span class="pre">.csv</span></tt>) created by <a class="reference internal" href="#tabular.tab.tabarray.saveSV" title="tabular.tab.tabarray.saveSV"><tt class="xref py py-func docutils literal"><span class="pre">saveSV()</span></tt></a>, colorings are 
automatically parsed from the header when present.</li>
<li>If constructing from a numpy binary file (e.g. 
<tt class="docutils literal"><span class="pre">.npz</span></tt>) created by <a class="reference internal" href="#tabular.tab.tabarray.savebinary" title="tabular.tab.tabarray.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">savebinary()</span></tt></a>, colorings 
are automatically loaded from a binary file 
(<tt class="docutils literal"><span class="pre">coloring.npy</span></tt>) in the <tt class="docutils literal"><span class="pre">.npz</span></tt> directory.</li>
</ul>
</li>
</ul>
</div></blockquote>
<p><strong>wrap</strong>:  string</p>
<blockquote>
<div>Adds a color with name  <em>wrap</em> listing all column 
names. (When this  <a class="reference internal" href="#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabarray</span></tt></a> is saved to a
<tt class="docutils literal"><span class="pre">.hsv</span></tt> directory, all columns will be nested in an
additional directory, <tt class="docutils literal"><span class="pre">wrap.hsv</span></tt>.)</div></blockquote>
<p><strong>verbosity</strong> :  integer, optional</p>
<blockquote>
<div>Sets how much detail from messages will be printed.</div></blockquote>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p><strong>Special column names:</strong></p>
<blockquote>
<div><p>Column names that begin and end with double
underscores, e.g. &#8216;__column_name__&#8217; are used
to hold row-by-row metadata and specify  arbitrary higher-level groups of rows, in analogy to how the <cite>coloring</cite> attribute specifies groupings of columns.</p>
<p>One use of this is for formatting
and communicating &#8220;side&#8221; information to other
<a class="reference internal" href="#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabarray</span></tt></a> methods.  For instance:</p>
<ul class="simple">
<li>A &#8216;__color__&#8217; column is interpreted by the</li>
</ul>
<blockquote>
<div>tabular.web.tabular2html function to specify row color in making html representations of tabarrays.   It is expected in each row to contain a web-safe hex triplet color specification, e.g. a string of the form &#8216;#XXXXXX&#8217; (see  <a class="reference external" href="http://en.wikipedia.org/wiki/Web_colors">http://en.wikipedia.org/wiki/Web_colors</a>).</div></blockquote>
<ul class="simple">
<li>The &#8216;__aggregates__&#8217; column is used to disambiguate
rows that are aggregates of data in other sets of
rows for the <tt class="docutils literal"><span class="pre">.aggregate_in</span></tt> method (see comments 
on that method).</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.__array_finalize__">
<tt class="descname">__array_finalize__</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.__array_finalize__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set default attributes (e.g. <cite>coloring</cite>) if <cite>obj</cite> does not have them.</p>
<p>Note:  this is called when you view a numpy ndarray as a tabarray.</p>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>ind</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subrectangle of the table.</p>
<p>The representation of the subrectangle depends on <cite>type(ind)</cite>. Also, 
whether the returned object represents a new independent copy of the 
subrectangle, or a &#8220;view&#8221; into this self object, depends on 
<cite>type(ind)</cite>.</p>
<ul class="simple">
<li>If you pass the name of an existing coloring, you get a tabarray 
consisting of copies of columns in that coloring.</li>
<li>If you pass a list of existing coloring names and/or column names, 
you get a tabarray consisting of copies of columns in the list 
(name of coloring is equivalent to list of names of columns in that 
coloring; duplicate columns are deleted).</li>
<li>If you pass a <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>, you get a tabarray consisting 
a subrectangle of the tabarray, as handled by  
<tt class="xref py py-func docutils literal"><span class="pre">numpy.ndarray.__getitem__()</span></tt>:<ul>
<li>if you pass a 1D NumPy ndarray of booleans of <cite>len(self)</cite>,    
the rectangle contains copies of the rows for which the 
corresponding entry is <cite>True</cite>.</li>
<li>if you pass a list of row numbers, you get a tabarray
containing copies of these rows.</li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.__getslice__">
<tt class="descname">__getslice__</tt><big>(</big><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.__getslice__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__getslice__(i, j) &lt;==&gt; x[i:j]</p>
<p>Use of negative indices is not supported.</p>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the tabarray.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is actually automatically inherited from
the NumPy ndarray, but is explicitly included here to
emphasize its utility.  This documentation is modified
from NumPy&#8217;s.</p>
</div>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>This is like:</p>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; tb.tabarray(array=a, dtype=a.dtype, copy=True)
</pre></div>
</div>
</div></blockquote>
<p><strong>Examples</strong></p>
<blockquote>
<div><p>Create an array x, with a reference y and a copy z:</p>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; x = tb.tabarray(records=[(1,2,3),(4,5,6)])
&gt;&gt;&gt; y = x
&gt;&gt;&gt; z = x.copy()
</pre></div>
</div>
<p>Note that, when we modify x, y changes, but not z:</p>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; x[0] = (0,0,0)
&gt;&gt;&gt; x[0] == y[0]
True
&gt;&gt;&gt; x[0] == z[0]
False
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.tolist">
<tt class="descname">tolist</tt><big>(</big><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the array as a possibly nested list.</p>
<p>Return a copy of the array data as a (nested) Python list.
Data items are converted to the nearest compatible Python type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is actually automatically inherited from
the NumPy ndarray, but is explicitly included here to
emphasize its utility.  This documentation is modified
from NumPy&#8217;s.</p>
</div>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>y</strong> : list</p>
<blockquote>
<div>The possibly nested list of array elements.</div></blockquote>
</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div>The array may be recreated, <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">tb.tabarray(records=a.tolist())</span></tt>.</div></blockquote>
<p><strong>Examples</strong></p>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; a = tb.tabarray(records=[(&#39;a&#39;, 2), (&#39;c&#39;, 1)])
&gt;&gt;&gt; list(a)
[(&#39;a&#39;, 2), (&#39;c&#39;, 1)]
&gt;&gt;&gt; type(list(a)[0])
<span class="nt">&lt;class &#39;numpy.core.records.record&#39;&gt;</span>
&gt;&gt;&gt; a.tolist()
[(&#39;a&#39;, 2), (&#39;c&#39;, 1)]
&gt;&gt;&gt; atype(a.tolist()[0])
<span class="nt">&lt;type &#39;tuple&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.sort">
<tt class="descname">sort</tt><big>(</big><em>kind='quicksort'</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort an array, in-place.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is actually automatically inherited from
the NumPy ndarray, but is explicitly included here to
emphasize its utility.  This documentation is modified
from NumPy&#8217;s.</p>
</div>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>kind</strong> : {&#8216;quicksort&#8217;, &#8216;mergesort&#8217;, &#8216;heapsort&#8217;}, optional</p>
<blockquote>
<div>Sorting algorithm. Default is &#8216;quicksort&#8217;.</div></blockquote>
<p><strong>order</strong> : string or list, optional</p>
<blockquote>
<div>This argument specifies which fields to compare first,
second, and so on.  This can be a string corresponding
to a single column name, or a list of column names.
This list does not need to include all of the column names.</div></blockquote>
</div></blockquote>
<p><strong>See Also</strong></p>
<blockquote>
<div>numpy.sort : Return a sorted copy of an array.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in sorted array.</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div>See <tt class="docutils literal"><span class="pre">numpy.sort</span></tt> for notes on the different sorting algorithms.</div></blockquote>
<p><strong>Examples</strong></p>
<blockquote>
<div><p>Use the <cite>order</cite> keyword to specify a column name (or list
of columns) to use:</p>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; a = tabarray(records=[(&#39;a&#39;, 2), (&#39;c&#39;, 1)], names=[&#39;x&#39;, &#39;y&#39;])
&gt;&gt;&gt; a.sort(order=&#39;y&#39;)
&gt;&gt;&gt; a
tabarray([(&#39;c&#39;, 1), (&#39;a&#39;, 2)],
          dtype=[(&#39;x&#39;, &#39;|S1&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.repeat">
<tt class="descname">repeat</tt><big>(</big><em>repeats</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat elements of a tabarray.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is actually automatically inherited from
the NumPy ndarray, but is explicitly included here to
emphasize its utility.  This documentation is modified
from NumPy&#8217;s.</p>
</div>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>repeats</strong> : {int, array of ints}</p>
<blockquote>
<div>The number of repetitions for each element.  <cite>repeats</cite> is broadcasted
to fit the number of records.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>repeated_array</strong> : tabarray</p>
<blockquote>
<div>Output array which has the same number of columns as
the origial tabarray.</div></blockquote>
</div></blockquote>
<p><strong>See Also</strong></p>
<blockquote>
<div>numpy.repeat :  function called by this method</div></blockquote>
<p><strong>Examples</strong></p>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; x = tb.tabarray(records=[(1,2),(3,4)])
&gt;&gt;&gt; x.repeat(2)
tabarray([(1, 2), (1, 2), (3, 4), (3, 4)],
          dtype=[(&#39;f0&#39;, &#39;&lt;i4&#39;), (&#39;f1&#39;, &#39;&lt;i4&#39;)])
&gt;&gt;&gt; x.repeat([1, 2])
tabarray([(1, 2), (3, 4), (3, 4)],
          dtype=[(&#39;f0&#39;, &#39;&lt;i4&#39;), (&#39;f1&#39;, &#39;&lt;i4&#39;)])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.put">
<tt class="descname">put</tt><big>(</big><em>ind</em>, <em>v</em>, <em>mode='raise'</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes specific elements of one array by replacing from another array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is actually automatically inherited from
the NumPy ndarray, but is explicitly included here to
emphasize its utility.  This documentation is modified
from NumPy&#8217;s.</p>
</div>
<p>The indexing works on the flattened target array, <cite>put</cite> is roughly
equivalent to:</p>
<div class="highlight-rest"><div class="highlight"><pre>for i, val in zip(ind, v):
        x.flat[i] = val
</pre></div>
</div>
<p><strong>Parameters</strong></p>
<p><strong>ind</strong> : array_like</p>
<blockquote>
<div>Target indices, interpreted as integers.</div></blockquote>
<p><strong>v</strong> : array_like</p>
<blockquote>
<div>Values to place in the original array at target indices.
If <cite>v</cite> is shorter than <cite>ind</cite> it will be repeated as necessary.</div></blockquote>
<p><strong>mode</strong> : {&#8216;raise&#8217;, &#8216;wrap&#8217;, &#8216;clip&#8217;}, optional</p>
<blockquote>
<div><p>Specifies how out-of-bounds indices will behave.</p>
<ul class="simple">
<li>&#8216;raise&#8217; &#8211; raise an error (default)</li>
<li>&#8216;wrap&#8217; &#8211; wrap around</li>
<li>&#8216;clip&#8217; &#8211; clip to the range</li>
</ul>
<p>&#8216;clip&#8217; mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
</div></blockquote>
<p><strong>See Also</strong></p>
<blockquote>
<div>putmask, place</div></blockquote>
<p><strong>Examples</strong></p>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; x = tb.tabarray(columns=[range(5)])
&gt;&gt;&gt; y = tb.tabarray(columns=[range(10,15)])
&gt;&gt;&gt; x.put([0, 2], y)
&gt;&gt;&gt; x
tabarray([(10,), (1,), (11,), (3,), (4,)],
      dtype=[(&#39;f0&#39;, &#39;&lt;i4&#39;)])
</pre></div>
</div>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; x = tb.tabarray(columns=[range(5)])
&gt;&gt;&gt; y = tb.tabarray(columns=[range(10,15)])
&gt;&gt;&gt; x.put(22, y, mode=&#39;clip&#39;)
&gt;&gt;&gt; x
tabarray([(0,), (1,), (2,), (3,), (10,)],
          dtype=[(&#39;f0&#39;, &#39;&lt;i4&#39;)])
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.addcols">
<tt class="descname">addcols</tt><big>(</big><em>cols</em>, <em>names=None</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.addcols" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Add one or more new columns.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.spreadsheet.addcols(self, cols, names)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.addcols" title="tabular.spreadsheet.addcols"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.addcols()</span></tt></a>:</p>
</div></blockquote>
<p>Add one or more columns to a numpy ndarray.</p>
<p>Technical dependency of <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.aggregate_in" title="tabular.spreadsheet.aggregate_in"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate_in()</span></tt></a>.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="#tabular.tab.tabarray.addcols" title="tabular.tab.tabarray.addcols"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.addcols()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The recarray to add columns to.</div></blockquote>
<p><strong>cols</strong> :  numpy ndarray, or list of arrays of columns</p>
<blockquote>
<div>Column(s) to add.</div></blockquote>
<p><strong>names</strong>:  list of strings, optional</p>
<blockquote>
<div>Names of the new columns. Only applicable when <cite>cols</cite> is a 
list of arrays.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>New numpy array made up of <cite>X</cite> plus the new columns.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong>  <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.colstack" title="tabular.spreadsheet.colstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.colstack()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.addrecords">
<tt class="descname">addrecords</tt><big>(</big><em>new</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.addrecords" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Append one or more records to the end of the array.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.spreadsheet.addrecords(self, new)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.addrecords" title="tabular.spreadsheet.addrecords"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.addrecords()</span></tt></a>:</p>
</div></blockquote>
<p>Append one or more records to the end of a numpy recarray or ndarray .</p>
<p>Can take a single record, void or tuple, or a list of records, voids or 
tuples.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="#tabular.tab.tabarray.addrecords" title="tabular.tab.tabarray.addrecords"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.addrecords()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The array to add records to.</div></blockquote>
<p><strong>new</strong> :  record, void or tuple, or list of them</p>
<blockquote>
<div>Record(s) to add to <cite>X</cite>.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>New numpy array made up of <cite>X</cite> plus the new records.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong>  <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.rowstack" title="tabular.spreadsheet.rowstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.rowstack()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.aggregate">
<tt class="descname">aggregate</tt><big>(</big><em>On=None</em>, <em>AggFuncDict=None</em>, <em>AggFunc=None</em>, <em>AggList=None</em>, <em>returnsort=False</em>, <em>KeepOthers=True</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Aggregate a tabarray on columns for given functions.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.spreadsheet.aggregate(self, On, AggFuncDict, AggFunc, returnsort)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.aggregate" title="tabular.spreadsheet.aggregate"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate()</span></tt></a>:</p>
</div></blockquote>
<p>Aggregate a ndarray with structured dtype (or recarray) on columns for 
given functions.</p>
<p>Aggregate a numpy recarray (or tabular tabarray) on a set of specified 
factors, using specified aggregation functions.</p>
<p>Intuitively, this function will aggregate the dataset <cite>X</cite> on a set of 
columns, whose names are listed in <cite>On</cite>, so that the resulting aggregate 
data set has one record for each unique tuples of values in those columns.</p>
<p>The more factors listed in <cite>On</cite> argument, the &#8220;finer&#8221; is the aggregation, 
the fewer factors, the &#8220;coarser&#8221; the aggregation.  For example, if:</p>
<div class="highlight-rest"><div class="highlight"><pre>On = [&#39;A&#39;,&#39;B&#39;]
</pre></div>
</div>
<p>the resulting data set will have one record for each unique value of pairs 
(a,b) in:</p>
<div class="highlight-rest"><div class="highlight"><pre>X[[&#39;A&#39;,&#39;B&#39;]]
</pre></div>
</div>
<p>The <cite>AggFuncDict</cite> argument specifies how to aggregate the factors _not_ 
listed in <cite>On</cite>, e.g. the so-called <cite>Off</cite> columns.  For example, if</p>
<blockquote>
<div>On = [&#8216;A&#8217;,&#8217;B&#8217;]</div></blockquote>
<p>and <cite>C</cite> is some other column, then:</p>
<div class="highlight-rest"><div class="highlight"><pre>AggFuncDict[&#39;C&#39;]
</pre></div>
</div>
<p>is the function that will be used to reduce to a single value the 
(potentially multiple) values in the <cite>C</cite> column corresponding to unique 
values in the <cite>A</cite>, <cite>B</cite> columns.  For instance, if:</p>
<div class="highlight-rest"><div class="highlight"><pre>AggFuncDict[&#39;C&#39;] = numpy.mean
</pre></div>
</div>
<p>then the result will be that the values in the <cite>C</cite> column corresponding to 
a single <cite>A</cite>, <cite>B</cite> value will be averaged.</p>
<p>If an <cite>Off</cite> column is _not_ provided as a key in <cite>AggFuncDict</cite>, a default 
aggregator function will be used:  the sum function for numerical columns, 
concatenation for string columns.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="#tabular.tab.tabarray.aggregate" title="tabular.tab.tabarray.aggregate"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.aggregate()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The data set to aggregate.</div></blockquote>
<p><strong>On</strong> :  list of  strings, optional</p>
<blockquote>
<div>List of column names in <cite>X</cite>.</div></blockquote>
<p><strong>AggFuncDict</strong> :  dictionary, optional</p>
<blockquote>
<div><p>Dictionary where</p>
<ul class="simple">
<li>keys are some (all) column names of <cite>X</cite> that are NOT
in <cite>On</cite></li>
<li>values are functions that can be applied to lists or
numpy arrays.</li>
</ul>
<p>This specifies how to aggregate the factors _not_ listed in
<cite>On</cite>, e.g. the so-called <cite>Off</cite> columns.</p>
</div></blockquote>
<p><strong>AggFunc</strong> :  function, optional</p>
<blockquote>
<div>Function that can be applied to lists or numpy arrays,
specifying how to aggregate factors not listed in either
<cite>On</cite> or the keys of <cite>AggFuncDict</cite>, e.g. a &#8220;default&#8221;
aggregation function for the <cite>Off</cite> columns not explicitly
listed in <cite>AggFuncDict</cite>.</div></blockquote>
<p><strong>returnsort</strong> :        Boolean, optional</p>
<blockquote>
<div>If <cite>returnsort == True</cite>, then return a list of indices
describing how <cite>X</cite> was sorted as a result of aggregation.
Default value is <cite>False</cite>.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>agg</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Aggregated data set.</div></blockquote>
<p><strong>index_array</strong> :  numpy ndarray (int, 1D)</p>
<blockquote>
<div>Returned only if <cite>returnsort == True</cite>.  List of indices
describing how <cite>X</cite> was sorted as a result of aggregation.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.aggregate_in" title="tabular.spreadsheet.aggregate_in"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate_in()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.aggregate_in">
<tt class="descname">aggregate_in</tt><big>(</big><em>On=None</em>, <em>AggFuncDict=None</em>, <em>AggFunc=None</em>, <em>AggList=None</em>, <em>interspersed=True</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.aggregate_in" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Aggregate a tabarray and include original data in the result.</p>
<p>See the <a class="reference internal" href="#tabular.tab.tabarray.aggregate" title="tabular.tab.tabarray.aggregate"><tt class="xref py py-func docutils literal"><span class="pre">aggregate()</span></tt></a> method.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.summarize.aggregate_in(self, On, AggFuncDict, AggFunc, interspersed)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.aggregate_in" title="tabular.spreadsheet.aggregate_in"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate_in()</span></tt></a>:</p>
</div></blockquote>
<p>Aggregate a ndarray with structured dtype or recarray
and include original data in the result.</p>
<p>Take aggregate of data set on specified columns, then add the resulting 
rows back into data set to make a composite object containing both original 
non-aggregate data rows as well as the aggregate rows.</p>
<p>First read comments for <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.aggregate" title="tabular.spreadsheet.aggregate"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate()</span></tt></a>.</p>
<p>This function returns a numpy ndarray, with the number of rows equaling:</p>
<div class="highlight-rest"><div class="highlight"><pre>len(Data) + len(A)
</pre></div>
</div>
<p>where <cite>A</cite> is the the result of:</p>
<div class="highlight-rest"><div class="highlight"><pre>Data.aggregate(On,AggFuncDict)
</pre></div>
</div>
<p><cite>A</cite> represents the aggregate rows; the other rows were the original data 
rows.</p>
<p>This function supports _multiple_ aggregation, meaning that one can first 
aggregate on one set of factors, then repeat aggregation on the result for 
another set of factors, without the results of the first aggregation 
interfering the second.  To achieve this, the method adds two new columns:</p>
<ul class="simple">
<li>a column called &#8220;__aggregates__&#8221; specifying on which factors the rows 
that are aggregate rows were aggregated.  Rows added by aggregating on 
factor <cite>A</cite> (a column in the original data set) will have <cite>A</cite> in the 
&#8220;__aggregates__&#8221; column.  When multiple factors <cite>A1</cite>, <cite>A2</cite> , ... are 
aggregated on, the notation is a comma-separated list:  <cite>A1,A2,...</cite>.  
This way, when you call <cite>aggregate_in</cite> again, the function only 
aggregates on the columns that have the empty char &#8216;&#8217; in their 
&#8220;__aggregates__&#8221; column.</li>
<li>a column called &#8216;__color__&#8217;, specifying Gray-Scale colors for 
aggregated rows that will be used by the Data Environment system 
browser for colorizing the  data.   When there are multiple levels of 
aggregation, the coarser aggregate groups (e.g. on fewer factors) get 
darker gray color then those on finer aggregate groups (e.g. more 
factors).</li>
</ul>
<p>Implemented by the tabarray method 
<a class="reference internal" href="#tabular.tab.tabarray.aggregate_in" title="tabular.tab.tabarray.aggregate_in"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.aggregate_in()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>Data</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The data set to aggregate in.</div></blockquote>
<p><strong>On</strong> :  list of  strings, optional</p>
<blockquote>
<div>List of column names in <cite>X</cite>.</div></blockquote>
<p><strong>AggFuncDict</strong> :  dictionary, optional</p>
<blockquote>
<div><p>Dictionary where</p>
<ul class="simple">
<li>keys are some (all) column names of <cite>X</cite> that are NOT in 
<cite>On</cite></li>
<li>values are functions that can be applied to lists or
numpy arrays.</li>
</ul>
<p>This specifies how to aggregate the factors _not_ listed in
<cite>On</cite>, e.g. the so-called <cite>Off</cite> columns.</p>
</div></blockquote>
<p><strong>AggFunc</strong> :  function, optional</p>
<blockquote>
<div>Function that can be applied to lists or numpy arrays,
specifying how to aggregate factors not listed in either 
<cite>On</cite> or the keys of <cite>AggFuncDict</cite>, e.g. a &#8220;default&#8221;
aggregation function for the <cite>Off</cite> columns not explicitly
listed in <cite>AggFuncDict</cite>.</div></blockquote>
<p><strong>interspersed</strong> :  boolean, optional</p>
<blockquote>
<div><ul class="simple">
<li>If <cite>True</cite>, aggregate rows are interleaved with the data 
of which they are aggregates.</li>
<li>If <cite>False</cite>, all aggregate rows placed at the end of the 
array.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>agg</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Composite aggregated data set plus original data set.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.aggregate" title="tabular.spreadsheet.aggregate"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.appendHSV">
<tt class="descname">appendHSV</tt><big>(</big><em>fname</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.appendHSV" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Append the tabarray to an existing on-disk HSV representation.</p>
<p>Like <a class="reference internal" href="#tabular.tab.tabarray.saveHSV" title="tabular.tab.tabarray.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">saveHSV()</span></tt></a> but for appending instead of writing from scratch.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.appendHSV(fname, self, order)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.io.html#tabular.io.appendHSV" title="tabular.io.appendHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.appendHSV()</span></tt></a>:</p>
</div></blockquote>
<p>Append records to an on-disk tabarray, e.g. HSV directory.</p>
<p>Function for appending records to an on-disk tabarray, used when one wants 
to write a large tabarray that is not going to be kept in memory at once.</p>
<p>If the tabarray is not there already, the function intializes the tabarray 
using the tabarray <cite>__new__</cite> method, and saves it out.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path of hierarchical separated variable (<tt class="docutils literal"><span class="pre">.hsv</span></tt>) file to
which to append records in <cite>RecObj</cite>.</div></blockquote>
<p><strong>RecObj</strong> :  array or dictionary</p>
<ul>
<li><p class="first">Either an array with complex dtype (e.g. tabarray, recarray or 
ndarray), or</p>
</li>
<li><p class="first">a dictionary (ndarray with structured dtype, e.g. a tabarray) 
where</p>
<blockquote>
<div><ul class="simple">
<li>keys are names of columns to append to, and</li>
<li>the value on a column is a list of values to be 
appended to that column.</li>
</ul>
</div></blockquote>
</li>
</ul>
<p><strong>order</strong> :  list of strings</p>
<blockquote>
<div>List of column names specifying order in which the columns 
should be written; only used when the HSV does not exist 
and the header specifying order needs to be written.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.io.html#tabular.io.appendcolumns" title="tabular.io.appendcolumns"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.appendcolumns()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.appendcolumns">
<tt class="descname">appendcolumns</tt><big>(</big><em>fname</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.appendcolumns" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Append the tabarray to an existing on-disk flat HSV representation.</p>
<p>Like <a class="reference internal" href="#tabular.tab.tabarray.savecolumns" title="tabular.tab.tabarray.savecolumns"><tt class="xref py py-func docutils literal"><span class="pre">savecolumns()</span></tt></a> but for appending instead of writing from 
scratch.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.appendcolumns(fname, self, order)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.io.html#tabular.io.appendcolumns" title="tabular.io.appendcolumns"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.appendcolumns()</span></tt></a>:</p>
</div></blockquote>
<p>Append records to a flat on-disk tabarray, e.g. HSV without subdirectories.</p>
<p>Function for appending columnns a flat on-disk tabarray, (e.g. no colors), 
used when one wants to write a large tabarray that is not going to be kept 
in memory at once.</p>
<p>If the tabarray is not there already, the function intializes the tabarray 
using the tabarray __new__ method, and saves it out.</p>
<p>See <a class="reference internal" href="tabular.io.html#tabular.io.appendHSV" title="tabular.io.appendHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.appendHSV()</span></tt></a> for a more general method.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path of hierarchical separated variable (.hsv) file of 
which to append.</div></blockquote>
<p><strong>RecObj</strong> :  array or dictionary</p>
<ul>
<li><p class="first">Either an array with complex dtype (e.g. tabarray, recarray or 
ndarray), or</p>
</li>
<li><p class="first">a dictionary (ndarray with structured dtype, e.g. a tabarray) 
where</p>
<blockquote>
<div><ul class="simple">
<li>keys are names of columns to append to, and</li>
<li>the value on a column is a list of values to be 
appended to that column.</li>
</ul>
</div></blockquote>
</li>
</ul>
<p><strong>order</strong> :  list of strings</p>
<blockquote>
<div>List of column names specifying order in which the columns 
should be written; only used when the HSV does not exist 
and the header specifying order needs to be written.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.io.html#tabular.io.appendHSV" title="tabular.io.appendHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.appendHSV()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.argsort">
<tt class="descname">argsort</tt><big>(</big><em>axis=-1</em>, <em>kind='quicksort'</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would sort an array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method wraps <cite>numpy.argsort</cite>.  This documentation is 
modified from that of <cite>numpy.argsort</cite>.</p>
</div>
<p>Perform an indirect sort along the given axis using the algorithm 
specified by the <cite>kind</cite> keyword.  It returns an array of indices of the 
same shape as the original array that index data along the given axis 
in sorted order.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>axis</strong> : int or None, optional</p>
<blockquote>
<div>Axis along which to sort.  The default is -1 (the last 
axis). If <cite>None</cite>, the flattened array is used.</div></blockquote>
<p><strong>kind</strong> : {&#8216;quicksort&#8217;, &#8216;mergesort&#8217;, &#8216;heapsort&#8217;}, optional</p>
<blockquote>
<div>Sorting algorithm.</div></blockquote>
<p><strong>order</strong> : list, optional</p>
<blockquote>
<div>This argument specifies which fields to compare first, 
second, etc.  Not all fields need be specified.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>index_array</strong> : ndarray, int</p>
<blockquote>
<div>Array of indices that sort the tabarray along the 
specified axis.  In other words, <tt class="docutils literal"><span class="pre">a[index_array]</span></tt> 
yields a sorted <cite>a</cite>.</div></blockquote>
<p><strong>See Also</strong></p>
<blockquote>
<div>sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div>See <cite>numpy.sort</cite> for notes on the different sorting 
algorithms.</div></blockquote>
<p><strong>Examples</strong></p>
<blockquote>
<div><p>Sorting with keys:</p>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; x = tabarray([(1, 0), (0, 1)], dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])
&gt;&gt;&gt; x
tabarray([(1, 0), (0, 1)], 
      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])
</pre></div>
</div>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; x.argsort(order=(&#39;x&#39;,&#39;y&#39;))
array([1, 0])
</pre></div>
</div>
<div class="highlight-rest"><div class="highlight"><pre>&gt;&gt;&gt; x.argsort(order=(&#39;y&#39;,&#39;x&#39;))
array([0, 1])
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.colstack">
<tt class="descname">colstack</tt><big>(</big><em>new</em>, <em>mode='abort'</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.colstack" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Horizontal stacking for tabarrays.</p>
<p>Stack tabarray(s) in <cite>new</cite> to the right of <cite>self</cite>.</p>
<p><strong>See also</strong></p>
<blockquote>
<div><tt class="xref py py-func docutils literal"><span class="pre">tabular.tabarray.tab_colstack()</span></tt>, 
<a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.colstack" title="tabular.spreadsheet.colstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.colstack()</span></tt></a></div></blockquote>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.colstack" title="tabular.spreadsheet.colstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.colstack()</span></tt></a>:</p>
</div></blockquote>
<p>Horizontally stack a sequence of numpy ndarrays with structured dtypes</p>
<p>Analog of numpy.hstack for recarrays.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="#tabular.tab.tabarray.colstack" title="tabular.tab.tabarray.colstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.colstack()</span></tt></a> which uses 
<tt class="xref py py-func docutils literal"><span class="pre">tabular.tabarray.tab_colstack()</span></tt>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>seq</strong> :  sequence of numpy ndarray with structured dtype</p>
<blockquote>
<div>List, tuple, etc. of numpy recarrays to stack vertically.</div></blockquote>
<p><strong>mode</strong> :  string in [&#8216;first&#8217;,&#8217;drop&#8217;,&#8217;abort&#8217;,&#8217;rename&#8217;]</p>
<blockquote>
<div><p>Denotes how to proceed if when multiple recarrays share the 
same column name:</p>
<ul class="simple">
<li>if <cite>mode</cite> == <tt class="docutils literal"><span class="pre">first</span></tt>, take the column from the first
recarray in <cite>seq</cite> containing the shared column name.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">abort</span></tt>, raise an error when the 
recarrays to stack share column names; this is the
default mode.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">drop</span></tt>, drop any column that shares    
its name with any other column among the sequence of 
recarrays.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">rename</span></tt>, for any set of all columns
sharing the same name, rename all columns by appending 
an underscore, &#8216;_&#8217;, followed by an integer, starting 
with &#8216;0&#8217; and incrementing by 1 for each subsequent 
column.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Result of horizontally stacking the arrays in <cite>seq</cite>.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong>  <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.hstack.html">numpy.hstack</a>.</p>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.deletecols">
<tt class="descname">deletecols</tt><big>(</big><em>cols</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.deletecols" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Delete columns and/or colors.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.spreadsheet.deletecols(self, cols)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.deletecols" title="tabular.spreadsheet.deletecols"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.deletecols()</span></tt></a>:</p>
</div></blockquote>
<p>Delete columns from a numpy ndarry or recarray.</p>
<p>Can take a string giving a column name or comma-separated list of column 
names, or a list of string column names.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="#tabular.tab.tabarray.deletecols" title="tabular.tab.tabarray.deletecols"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.deletecols()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy recarray or ndarray with structured dtype</p>
<blockquote>
<div>The numpy array from which to delete columns.</div></blockquote>
<p><strong>cols</strong> :  string or list of strings</p>
<blockquote>
<div>Name or list of names of columns in <cite>X</cite>.  This can be
a string giving a column name or comma-separated list of 
column names, or a list of string column names.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>New numpy ndarray with structured dtype
given by <cite>X</cite>, excluding the columns named in <cite>cols</cite>.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.extract">
<tt class="descname">extract</tt><big>(</big><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a copy of this tabarray in the form of a numpy ndarray.</p>
<p>Useful if you want to do math on array elements, e.g. if you have a 
subset of the columns that are all numerical, you can construct a 
numerical matrix and do matrix operations.</p>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.join">
<tt class="descname">join</tt><big>(</big><em>ToMerge</em>, <em>keycols=None</em>, <em>nullvals=None</em>, <em>renamer=None</em>, <em>returnrenaming=False</em>, <em>selfname=None</em>, <em>Names=None</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for spreadsheet.join, but handles coloring attributes.</p>
<p>The <cite>selfname</cite> argument allows naming of <cite>self</cite> to be used if <cite>ToMerge</cite> 
is a dictionary.</p>
<p><strong>See also:</strong> <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.join" title="tabular.spreadsheet.join"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.join()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">tab_join()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.pivot">
<tt class="descname">pivot</tt><big>(</big><em>a</em>, <em>b</em>, <em>Keep=None</em>, <em>NullVals=None</em>, <em>order=None</em>, <em>prefix='_'</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.pivot" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Pivot with <cite>a</cite> as the row axis and <cite>b</cite> values as the column axis.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.spreadsheet.pivot(X, a, b, Keep)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.pivot" title="tabular.spreadsheet.pivot"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.pivot()</span></tt></a>:</p>
</div></blockquote>
<p>Implements pivoting on numpy ndarrays (with structured dtype) or recarrays.</p>
<p>See <a class="reference external" href="http://en.wikipedia.org/wiki/Pivot_table">http://en.wikipedia.org/wiki/Pivot_table</a> for information about pivot 
tables.</p>
<p>Returns <cite>X</cite> pivoted on (a,b) with <cite>a</cite> as the row axis and <cite>b</cite> values as the 
column axis.</p>
<p>So-called &#8220;nontrivial columns relative to <cite>b</cite>&#8221; in <cite>X</cite> are added as 
color-grouped sets of columns, and &#8220;trivial columns relative to <cite>b</cite>&#8221; are 
also retained as cross-grouped sets of columns if they are listed in <cite>Keep</cite> 
argument.</p>
<p>Note that a column <cite>c</cite> in <cite>X</cite> is &#8220;trivial relative to <cite>b</cite>&#8221; if for all rows 
i, X[c][i] can be determined from X[b][i], e.g the elements in X[c] are in 
many-to-any correspondence with the values in X[b].</p>
<p>The function will raise an exception if the list of pairs of value in 
X[[a,b]] is not the product of the individual columns values, e.g.:</p>
<div class="highlight-rest"><div class="highlight"><pre>X[[a,b]] == set(X[a]) x set(X[b])
</pre></div>
</div>
<p>in some ordering.</p>
<p>Implemented by the tabarray method <a class="reference internal" href="#tabular.tab.tabarray.pivot" title="tabular.tab.tabarray.pivot"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.pivot()</span></tt></a></p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The  data set to pivot.</div></blockquote>
<p><strong>a</strong> : string</p>
<blockquote>
<div>Column name in <cite>X</cite>.</div></blockquote>
<p><strong>b</strong> : string</p>
<blockquote>
<div>Another column name in <cite>X</cite>.</div></blockquote>
<p><strong>Keep</strong> :  list of strings, optional</p>
<blockquote>
<div>List of other columns names in <cite>X</cite>.</div></blockquote>
<p><strong>NullVals</strong> :  optional</p>
<blockquote>
<div><p>Dictionary mapping column names in <cite>X</cite> other than <cite>a</cite> or 
<cite>b</cite> to appropriate null values for their types.</p>
<p>If <cite>None</cite>, then the null values defined by the <cite>nullvalue</cite>
function are used, see
<tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.nullvalue()</span></tt>.</p>
</div></blockquote>
<p><strong>prefix</strong> :  string, optional</p>
<blockquote>
<div>Prefix to add to <cite>coloring</cite> keys corresponding to 
cross-grouped &#8220;trivial columns relative to <cite>b</cite>&#8221;.  Default 
value is an underscore, &#8216;_&#8217;.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>ptable</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>The resulting pivot table.</div></blockquote>
<p><strong>coloring</strong> :  dictionary</p>
<blockquote>
<div><p>Dictionary whose keys are strings and corresponding values 
are lists of column names (e.g. strings).</p>
<p>There are two groups of keys:</p>
<ul>
<li><p class="first">So-called &#8220;nontrivial columns relative to <cite>b</cite>&#8221; in <cite>X</cite>.  
These correspond to columns in:</p>
<div class="highlight-rest"><div class="highlight"><pre>set(<span class="nv">`X.dtype.names`</span>) - set([a, b])
</pre></div>
</div>
</li>
<li><p class="first">Cross-grouped &#8220;trivial columns relative to <cite>b</cite>&#8221;.  The 
<cite>prefix</cite> is used to distinguish these.</p>
</li>
</ul>
<p>The <cite>coloring</cite> parameter is used by the the tabarray pivot 
method, <a class="reference internal" href="#tabular.tab.tabarray.pivot" title="tabular.tab.tabarray.pivot"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.pivot()</span></tt></a>.</p>
<p>See <a class="reference internal" href="#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more
information about coloring.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.renamecol">
<tt class="descname">renamecol</tt><big>(</big><em>old</em>, <em>new</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.renamecol" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Rename column or color in-place.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.spreadsheet.renamecol(self, old, new)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.renamecol" title="tabular.spreadsheet.renamecol"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.renamecol()</span></tt></a>:</p>
</div></blockquote>
<p>Rename column of a numpy ndarray with structured dtype, in-place.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="#tabular.tab.tabarray.renamecol" title="tabular.tab.tabarray.renamecol"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.renamecol()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>The numpy array for which a column is to be renamed.</div></blockquote>
<p><strong>old</strong> :  string</p>
<blockquote>
<div>Old column name, e.g. a name in <cite>X.dtype.names</cite>.</div></blockquote>
<p><strong>new</strong> :  string</p>
<blockquote>
<div>New column name to replace <cite>old</cite>.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.replace">
<tt class="descname">replace</tt><big>(</big><em>old</em>, <em>new</em>, <em>strict=True</em>, <em>cols=None</em>, <em>rows=None</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.replace" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Replace <cite>old</cite> with <cite>new</cite> in the rows <cite>rows</cite> of columns <cite>cols</cite>.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.spreadsheet.replace(self, old, new, strict, cols, rows)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.replace" title="tabular.spreadsheet.replace"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.replace()</span></tt></a>:</p>
</div></blockquote>
<p>Replace value <cite>old</cite> with <cite>new</cite> everywhere it appears in-place.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="#tabular.tab.tabarray.replace" title="tabular.tab.tabarray.replace"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.replace()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Numpy array for which in-place replacement of <cite>old</cite> with 
<cite>new</cite> is to be done.</div></blockquote>
<p><strong>old</strong> : string</p>
<p><strong>new</strong> : string</p>
<p><strong>strict</strong> :  boolean, optional</p>
<ul class="simple">
<li>If <cite>strict</cite> = <cite>True</cite>, replace only exact occurences of <cite>old</cite>.</li>
<li>If <cite>strict</cite> = <cite>False</cite>, assume <cite>old</cite> and <cite>new</cite> are strings and   
replace all occurences of substrings (e.g. like 
<tt class="xref py py-func docutils literal"><span class="pre">str.replace()</span></tt>)</li>
</ul>
<p><strong>cols</strong> :  list of strings, optional</p>
<blockquote>
<div>Names of columns to make replacements in; if <cite>None</cite>, make 
replacements everywhere.</div></blockquote>
<p><strong>rows</strong> : list of booleans or integers, optional</p>
<blockquote>
<div>Rows to make replacements in; if <cite>None</cite>, make replacements 
everywhere.</div></blockquote>
</div></blockquote>
<p>Note:  This function does in-place replacements.  Thus there are issues 
handling data types here when replacement dtype is larger than original 
dtype.  This can be resolved later by making a new array when necessary ...</p>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.rowstack">
<tt class="descname">rowstack</tt><big>(</big><em>new</em>, <em>mode='nulls'</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.rowstack" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Vertical stacking for tabarrays.</p>
<p>Stack tabarray(s) in <cite>new</cite> below <cite>self</cite>.</p>
<p><strong>See also</strong></p>
<blockquote>
<div><tt class="xref py py-func docutils literal"><span class="pre">tabular.tabarray.tab_rowstack()</span></tt>, 
<a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.rowstack" title="tabular.spreadsheet.rowstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.rowstack()</span></tt></a></div></blockquote>
<p>Documentation from <a class="reference internal" href="tabular.spreadsheet.html#tabular.spreadsheet.rowstack" title="tabular.spreadsheet.rowstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.rowstack()</span></tt></a>:</p>
</div></blockquote>
<p>Vertically stack a sequence of numpy ndarrays with structured dtype</p>
<p>Analog of numpy.vstack</p>
<p>Implemented by the tabarray method
<a class="reference internal" href="#tabular.tab.tabarray.rowstack" title="tabular.tab.tabarray.rowstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.rowstack()</span></tt></a> which uses 
<tt class="xref py py-func docutils literal"><span class="pre">tabular.tabarray.tab_rowstack()</span></tt>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>seq</strong> :  sequence of numpy recarrays</p>
<blockquote>
<div>List, tuple, etc. of numpy recarrays to stack vertically.</div></blockquote>
<p><strong>mode</strong> :  string in [&#8216;nulls&#8217;, &#8216;commons&#8217;, &#8216;abort&#8217;]</p>
<blockquote>
<div><p>Denotes how to proceed if the recarrays have different
dtypes, e.g. different sets of named columns.</p>
<ul class="simple">
<li>if <cite>mode</cite> == <tt class="docutils literal"><span class="pre">nulls</span></tt>, the resulting set of columns is
determined by the union of the dtypes of all recarrays
to be stacked, and missing data is filled with null 
values as defined by 
<tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.nullvalue()</span></tt>; this is the 
default mode.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">commons</span></tt>, the resulting set of 
columns is determined by the intersection of the dtypes 
of all recarrays to be stacked, e.g. common columns.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">abort</span></tt>, raise an error when the
recarrays to stack have different dtypes.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Result of vertically stacking the arrays in <cite>seq</cite>.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong>  <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.vstack.html">numpy.vstack</a>.</p>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.saveHSV">
<tt class="descname">saveHSV</tt><big>(</big><em>fname</em>, <em>printheaderfile=True</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.saveHSV" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Save the tabarray to a hierarchical separated variable (HSV) directory.</p>
<p>Save the tabarray to a <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory.  Each column is saved as a 
separate comma-separated variable file (<tt class="docutils literal"><span class="pre">.csv</span></tt>), whose name includes 
the column name and data type of the column (e.g. <tt class="docutils literal"><span class="pre">name.int.csv</span></tt>, 
<tt class="docutils literal"><span class="pre">name.float.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.str.csv</span></tt>).</p>
<p>Hierarchical structure on the columns, i.e. <tt class="xref py py-attr docutils literal"><span class="pre">coloring</span></tt>, is
preserved by the file directory structure, with subdirectories named 
<tt class="docutils literal"><span class="pre">color.hsv</span></tt> and containing <tt class="docutils literal"><span class="pre">.csv</span></tt> files corrseponding to columns of 
data grouped by that color.</p>
<p>Finally, <tt class="xref py py-attr docutils literal"><span class="pre">rowdata</span></tt> is stored as a dump of a pickled object in the 
top level directory <cite>fname</cite>.</p>
<p>The <tt class="docutils literal"><span class="pre">.hsv</span></tt> can later be loaded back by passing the file path <cite>fname</cite> 
to the <cite>HSV</cite> argument of the <a class="reference internal" href="#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabarray</span></tt></a> constructor.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.saveHSV(fname, self, printheaderfile)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.io.html#tabular.io.saveHSV" title="tabular.io.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveHSV()</span></tt></a>:</p>
</div></blockquote>
<p>Save a tabarray to a hierarchical separated variable (HSV) directory.</p>
<p>The tabarray can later be loaded back from the <tt class="docutils literal"><span class="pre">.hsv</span></tt> by passing <cite>fname</cite> 
to the <cite>HSV</cite> argument of the tabarray constructor 
<a class="reference internal" href="#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a>.</p>
<p>This function is used by the tabarray method
<a class="reference internal" href="#tabular.tab.tabarray.saveHSV" title="tabular.tab.tabarray.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.saveHSV()</span></tt></a>.</p>
<p>Each column of data in the tabarray is stored inside of the <tt class="docutils literal"><span class="pre">.hsv</span></tt> 
directory to a separate comma-separated variable text file (<tt class="docutils literal"><span class="pre">.csv</span></tt>), 
whose name includes the column name and data type of the column (e.g. 
<tt class="docutils literal"><span class="pre">name.int.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.float.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.str.csv</span></tt>).</p>
<p>Coloring information, i.e.  hierarchical structure on the columns, is 
stored in the file directory structure of the <tt class="docutils literal"><span class="pre">.hsv</span></tt>, where <tt class="docutils literal"><span class="pre">.hsv</span></tt> 
subdirectories correspond to colors in the coloring dictionary:</p>
<div class="highlight-rest"><div class="highlight"><pre>X.coloring.keys()
</pre></div>
</div>
<p>e.g. a subdirectory named <tt class="docutils literal"><span class="pre">color.hsv</span></tt> contains <tt class="docutils literal"><span class="pre">.csv</span></tt> files
corrseponding to columns of data grouped by that color:</p>
<div class="highlight-rest"><div class="highlight"><pre>X[&#39;color&#39;]
</pre></div>
</div>
<p>See <a class="reference internal" href="#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more information about 
coloring.</p>
<p>Note that when the file structure is not flat,
<a class="reference internal" href="tabular.io.html#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> calls itself recursively.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path to a <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory or individual <tt class="docutils literal"><span class="pre">.csv</span></tt> text 
files, corresponding to individual columns of data inside 
of a <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory.</div></blockquote>
<p><strong>X</strong> :  tabarray</p>
<blockquote>
<div>The actual data in a <a class="reference internal" href="#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a>.</div></blockquote>
<p><strong>printheaderfile</strong> : boolean, optional</p>
<blockquote>
<div><p>Whether or not to print an ordered list of columns names in 
an additional file <tt class="docutils literal"><span class="pre">header.txt</span></tt> in all <tt class="docutils literal"><span class="pre">.hsv</span></tt> 
directories. The order is given by:</p>
<div class="highlight-rest"><div class="highlight"><pre>X.dtype.names
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">header.txt</span></tt> file is used by 
<a class="reference internal" href="tabular.io.html#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> to load the columns of data in 
the proper order, but is not required.</p>
</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a>, <a class="reference internal" href="tabular.io.html#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a>, <a class="reference internal" href="tabular.io.html#tabular.io.savecolumns" title="tabular.io.savecolumns"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savecolumns()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.saveSV">
<tt class="descname">saveSV</tt><big>(</big><em>fname</em>, <em>comments=None</em>, <em>metadata=None</em>, <em>printmetadict=None</em>, <em>dialect=None</em>, <em>delimiter=None</em>, <em>doublequote=True</em>, <em>lineterminator='n'</em>, <em>escapechar=None</em>, <em>quoting=0</em>, <em>quotechar='&quot;'</em>, <em>skipinitialspace=False</em>, <em>stringifier=None</em>, <em>verbosity=5</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.saveSV" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Save the tabarray to a single flat separated variable (CSV) text file.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.saveSV.      
</pre></div>
</div>
<p>See docstring of tabular.io.saveSV, or Tabular reference documentation,  for more information.</p>
<p>Documentation from <a class="reference internal" href="tabular.io.html#tabular.io.saveSV" title="tabular.io.saveSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveSV()</span></tt></a>:</p>
</div></blockquote>
<p>Save a tabarray to a separated-variable (CSV) file.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path to a separated variable (CSV) text file.</div></blockquote>
<p><strong>X</strong> :  tabarray</p>
<blockquote>
<div>The actual data in a <a class="reference internal" href="#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a>.</div></blockquote>
<p><strong>comments</strong> :  string, optional</p>
<blockquote>
<div>The character to be used to denote the start of a header (non-data) line, e.g. &#8216;#&#8217;.  If not specified, it is determined according to the following rule:  &#8216;#&#8217; if <cite>metadata</cite> argument is set, otherwise &#8216;&#8217;.</div></blockquote>
<p><strong>delimiter</strong> :  string, optional</p>
<blockquote>
<div>The character to beused to separate values in each line of text, e.g. &#8216;,&#8217;.  If not specified, by default, this is inferred from the file extension: if the file ends in <cite>.csv</cite>, the delimiter is &#8216;,&#8217;, otherwise it is &#8216;t.&#8217;</div></blockquote>
<p><strong>linebreak</strong> :  string, optional</p>
<blockquote>
<div>The string separating lines of text.  By default, this is assumed to be &#8216;n&#8217;, and can also be set to be &#8216;r&#8217; or &#8216;rn&#8217;.</div></blockquote>
<p><strong>metadata</strong> :  list of strings or Boolean, optional</p>
<blockquote>
<div><p>Allowed values are True, False, or any sublists of the list 
<cite>[&#8216;names&#8217;, &#8216;formats&#8217;, &#8216;types&#8217;, &#8216;coloring&#8217;, &#8216;dialect&#8217;]</cite>.  These keys indicate what special metadata is printed in the header.</p>
<ul class="simple">
<li>If a sublist of [&#8216;names&#8217;, &#8216;formats&#8217;, &#8216;types&#8217;, &#8216;coloring&#8217;, &#8216;dialect&#8217;], then the indicated types of metadata are written out.</li>
<li>If <cite>True</cite>, this is the same as 
<cite>metadata = [&#8216;coloring&#8217;, &#8216;types&#8217;, &#8216;names&#8217;,&#8217;dialect&#8217;]</cite>, e.g. as many types of metadata as this algorithm currently knows how to write out.</li>
<li>If &#8216;False&#8217;, no metadata is printed at all, e.g. just the data.</li>
<li>If <cite>metadata</cite> is not specified, the default is   <cite>[&#8216;names&#8217;]</cite>, &#8211; that is, just column names are written out.</li>
</ul>
</div></blockquote>
<p><strong>printmetadict</strong> :  Boolean, optional</p>
<blockquote>
<div><p>Whether or not to print a string representation of the
<cite>metadatadict</cite> in the first line of the header.</p>
<p>If <cite>printmetadict</cite> is not specified, then:</p>
<ul class="simple">
<li>If <cite>metadata</cite> is specified and is not <cite>False</cite>, then
<cite>printmetadata</cite> defaults to <cite>True</cite>.</li>
<li>Else if <cite>metadata</cite> is <cite>False</cite>, then <cite>printmetadata</cite>
defaults to <cite>False</cite>.</li>
<li>Else <cite>metadata</cite> is not specified, and <cite>printmetadata</cite>
defaults to <cite>False</cite>.</li>
</ul>
<p>See the <a class="reference internal" href="tabular.io.html#tabular.io.loadSV" title="tabular.io.loadSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadSV()</span></tt></a> for more information
about <cite>metadatadict</cite>.</p>
</div></blockquote>
<p><strong>stringifier</strong> : callable taking 1-d numpy array and returning python list of strings of same length, or dictionary or tuple of such callables.</p>
<blockquote>
<div>If specified, the callable will be applied to each column, and the resulting list of strings will be written to the file.   If specified as a list or dictionary of callables, the functions will be applied to correponding columns.    The default used if <strong>stringifier</strong> is not specified, is  <cite>tb.utils.DEFAULT_STRINGIFIER</cite>, which merely passes through string-type columns, and converts numerical-type columns directly to correponding strings with NaNs replaced with blank values.    The main purpose of specifying a non-default value is to encode numerical values in various string encodings that might be used required for other applications like databases.</div></blockquote>
<p>NOTE:   In certain special circumstances (e.g. when the lineterminator or delimiter character appears in a field of the data), the python CSV writer is used to write out data.  To allow for control of the operation of the writer in these circumstances, the following other parameters replicating the interface of the CSV module are also valid, and values will be passed through:  <strong>doublequote</strong>, <strong>escapechar</strong>, <strong>quoting</strong>, <strong>quotechar</strong>, and <strong>skipinitialspace</strong>.   (See python CSV module documentation for more information.)</p>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.io.html#tabular.io.loadSV" title="tabular.io.loadSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadSV()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.savebinary">
<tt class="descname">savebinary</tt><big>(</big><em>fname</em>, <em>savecoloring=True</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.savebinary" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Save the tabarray to a numpy binary archive (<tt class="docutils literal"><span class="pre">.npz</span></tt>).</p>
<p>Save the tabarray to a <tt class="docutils literal"><span class="pre">.npz</span></tt> zipped file containing <tt class="docutils literal"><span class="pre">.npy</span></tt> binary 
files for data, plus optionally coloring and/or rowdata or simply to a 
<tt class="docutils literal"><span class="pre">.npy</span></tt> binary file containing the data but no coloring or rowdata.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.savebinary(fname, self, savecoloring, saverowdata)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.io.html#tabular.io.savebinary" title="tabular.io.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savebinary()</span></tt></a>:</p>
</div></blockquote>
<p>Save a tabarray to a numpy binary file or archive.</p>
<p>Save a tabarray to a numpy binary file (<tt class="docutils literal"><span class="pre">.npy</span></tt>) or archive
(<tt class="docutils literal"><span class="pre">.npz</span></tt>) that can be loaded by <a class="reference internal" href="tabular.io.html#tabular.io.savebinary" title="tabular.io.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savebinary()</span></tt></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">.npz</span></tt> file is a zipped archive created using
<tt class="xref py py-func docutils literal"><span class="pre">numpy.savez()</span></tt> and containing one or more <tt class="docutils literal"><span class="pre">.npy</span></tt> files,
which are NumPy binary files created by <tt class="xref py py-func docutils literal"><span class="pre">numpy.save()</span></tt>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string or file-like object</p>
<blockquote>
<div>File name or open numpy binary file (<tt class="docutils literal"><span class="pre">.npy</span></tt>) or archive 
(<tt class="docutils literal"><span class="pre">.npz</span></tt>) created by <a class="reference internal" href="tabular.io.html#tabular.io.savebinary" title="tabular.io.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savebinary()</span></tt></a>.</div></blockquote>
<p><strong>X</strong> :  tabarray</p>
<blockquote>
<div><p>The actual data in a <a class="reference internal" href="#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a>:</p>
<ul>
<li><p class="first">if <cite>fname</cite> is a <tt class="docutils literal"><span class="pre">.npy</span></tt> file, then this is the same 
as:</p>
<div class="highlight-rest"><div class="highlight"><pre>numpy.savez(fname, data=X)
</pre></div>
</div>
</li>
<li><p class="first">otherwise, if <cite>fname</cite> is a <tt class="docutils literal"><span class="pre">.npz</span></tt> file, then <cite>X</cite> is   
zipped inside of <cite>fname</cite> as <tt class="docutils literal"><span class="pre">data.npy</span></tt></p>
</li>
</ul>
</div></blockquote>
<p><strong>savecoloring</strong> : boolean</p>
<blockquote>
<div><p>Whether or not to save the <cite>coloring</cite> attribute of <cite>X</cite>.
If <cite>savecoloring</cite> is <cite>True</cite>, then <cite>fname</cite> must be a
<tt class="docutils literal"><span class="pre">.npz</span></tt> archive and <cite>X.coloring</cite> is zipped inside of
<cite>fname</cite> as <tt class="docutils literal"><span class="pre">coloring.npy</span></tt></p>
<p>See <a class="reference internal" href="#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more
information about coloring.</p>
</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.io.html#tabular.io.loadbinary" title="tabular.io.loadbinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadbinary()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.load()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.save()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.savez()</span></tt></div></blockquote>
</dd></dl>

<dl class="method">
<dt id="tabular.tab.tabarray.savecolumns">
<tt class="descname">savecolumns</tt><big>(</big><em>fname</em><big>)</big><a class="headerlink" href="#tabular.tab.tabarray.savecolumns" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Save the tabarray to a set of flat <tt class="docutils literal"><span class="pre">.csv</span></tt> files, one per column.</p>
<p>Save the tabarray to a set of flat <tt class="docutils literal"><span class="pre">.csv</span></tt> files in <tt class="docutils literal"><span class="pre">.hsv</span></tt> format 
(e.g. <tt class="docutils literal"><span class="pre">.int.csv</span></tt>, <tt class="docutils literal"><span class="pre">.float.csv</span></tt>, <tt class="docutils literal"><span class="pre">.str.csv</span></tt>).  Note that data in 
the <em>coloring</em> attribute is lost.</p>
<p>Method wraps:</p>
<div class="highlight-rest"><div class="highlight"><pre>tabular.io.savecolumns(fname, self)
</pre></div>
</div>
<p>Documentation from <a class="reference internal" href="tabular.io.html#tabular.io.savecolumns" title="tabular.io.savecolumns"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savecolumns()</span></tt></a>:</p>
</div></blockquote>
<p>Save columns of a tabarray to an existing HSV directory.</p>
<p>Save columns of tabarray <cite>X</cite> to an existing HSV directory <cite>fname</cite> (e.g. a 
<tt class="docutils literal"><span class="pre">.hsv</span></tt> directory created by <a class="reference internal" href="tabular.io.html#tabular.io.saveHSV" title="tabular.io.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveHSV()</span></tt></a>).</p>
<p>Each column of data in the tabarray is stored inside of the <tt class="docutils literal"><span class="pre">.hsv</span></tt> 
directory to a separate comma-separated variable text file (<tt class="docutils literal"><span class="pre">.csv</span></tt>), 
whose name includes the column name and data type of the column (e.g. 
<tt class="docutils literal"><span class="pre">name.int.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.float.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.str.csv</span></tt>).</p>
<p>Coloring is lost.</p>
<p>This function is used by the tabarray method
<a class="reference internal" href="#tabular.tab.tabarray.savecolumns" title="tabular.tab.tabarray.savecolumns"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.savecolumns()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path to a hierarchical separated variable (HSV) directory
(<tt class="docutils literal"><span class="pre">.hsv</span></tt>).</div></blockquote>
<p><strong>X</strong> :  tabarray</p>
<blockquote>
<div>The actual data in a <a class="reference internal" href="#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a>.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.io.html#tabular.io.saveHSV" title="tabular.io.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveHSV()</span></tt></a>, <a class="reference internal" href="tabular.io.html#tabular.io.loadHSVlist" title="tabular.io.loadHSVlist"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSVlist()</span></tt></a></div></blockquote>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<p class="logo"><a href="http://web.mit.edu/yamins/www/tabular">
  <img class="logo" src="../_static/tabularclear.png" alt="Logo"/>
</a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="../reference/web.html"
                        title="previous chapter">Web &amp; HTML</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tabular.io.html"
                        title="next chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">tabular.io</span></tt></a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/tabular.tab.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tabular.io.html" title="tabular.io"
             >next</a> |</li>
        <li class="right" >
          <a href="../reference/web.html" title="Web &amp; HTML"
             >previous</a> |</li>
    
        <li><a href="../index.html">tabular</a> &raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Elaine Angelino and Daniel Yamins.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>