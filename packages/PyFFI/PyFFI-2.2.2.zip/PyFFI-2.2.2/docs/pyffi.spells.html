

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyffi.spells — High level file operations &mdash; PyFFI 2.2.2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyFFI 2.2.2 documentation" href="index.html" />
    <link rel="up" title="pyffi — Interfacing block structured files" href="pyffi.html" />
    <link rel="next" title="pyffi.spells.cgf — Crytek Geometry/Animation (.cgf/.cga) spells" href="pyffi.spells.cgf.html" />
    <link rel="prev" title="pyffi.formats.tri — TRI (.tri)" href="pyffi.formats.tri.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyffi.spells.cgf.html" title="pyffi.spells.cgf — Crytek Geometry/Animation (.cgf/.cga) spells"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pyffi.formats.tri.html" title="pyffi.formats.tri — TRI (.tri)"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyFFI 2.2.2 documentation</a> &raquo;</li>
          <li><a href="pyffi.html" accesskey="U"><tt class="docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal"><span class="pre">pyffi</span></tt> &#8212; Interfacing block structured files</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-pyffi.spells"></span><div class="section" id="pyffi-spells-high-level-file-operations">
<h1><a class="reference internal" href="#module-pyffi.spells" title="pyffi.spells"><tt class="xref py py-mod docutils literal"><span class="pre">pyffi.spells</span></tt></a> &#8212; High level file operations<a class="headerlink" href="#pyffi-spells-high-level-file-operations" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This module is based on wz&#8217;s NifTester module, although
nothing of wz&#8217;s original code is left in this module.</p>
</div>
<p>A <a class="reference internal" href="glossary.html#term-toaster"><em class="xref std std-term">toaster</em></a>, implemented by subclasses of the abstract
<a class="reference internal" href="#pyffi.spells.Toaster" title="pyffi.spells.Toaster"><tt class="xref py py-class docutils literal"><span class="pre">Toaster</span></tt></a> class, walks over all files in a folder, and applies
one or more transformations on each file. Such transformations are
called <a class="reference internal" href="glossary.html#term-spell"><em class="xref std std-term">spell</em></a>s, and are implemented by subclasses of the
abstract <a class="reference internal" href="#pyffi.spells.Spell" title="pyffi.spells.Spell"><tt class="xref py py-class docutils literal"><span class="pre">Spell</span></tt></a> class.</p>
<p>A <a class="reference internal" href="glossary.html#term-spell"><em class="xref std std-term">spell</em></a> can also run independently of a <a class="reference internal" href="glossary.html#term-toaster"><em class="xref std std-term">toaster</em></a> and be
applied on a branch directly. The recommended way of doing this is via
the <a class="reference internal" href="#pyffi.spells.Spell.recurse" title="pyffi.spells.Spell.recurse"><tt class="xref py py-meth docutils literal"><span class="pre">Spell.recurse()</span></tt></a> method.</p>
<div class="section" id="supported-spells">
<h2>Supported spells<a class="headerlink" href="#supported-spells" title="Permalink to this headline">¶</a></h2>
<p>For format specific spells, refer to the corresponding module.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyffi.spells.cgf.html"><tt class="docutils literal"><span class="pre">pyffi.spells.cgf</span></tt> &#8212;  Crytek Geometry/Animation (.cgf/.cga) spells</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyffi.spells.kfm.html"><tt class="docutils literal"><span class="pre">pyffi.spells.kfm</span></tt> &#8212;  NetImmerse/Gamebryo Keyframe Motion (.kfm) spells</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyffi.spells.nif.html"><tt class="docutils literal"><span class="pre">pyffi.spells.nif</span></tt> &#8212;  NetImmerse/Gamebryo File/Keyframe (.nif/.kf/.kfa) spells</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pyffi.spells.nif.html#pyffi-spells-nif-fix-spells-to-fix-errors"><tt class="docutils literal"><span class="pre">pyffi.spells.nif.fix</span></tt> &#8212;  spells to fix errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyffi.spells.nif.html#pyffi-spells-nif-modify-spells-to-make-modifications"><tt class="docutils literal"><span class="pre">pyffi.spells.nif.modify</span></tt> &#8212;  spells to make modifications</a></li>
</ul>
</li>
</ul>
</div>
<p>Some spells are applicable on every file format, and those are documented
here.</p>
<dl class="class">
<dt id="pyffi.spells.SpellApplyPatch">
<em class="property">class </em><tt class="descclassname">pyffi.spells.</tt><tt class="descname">SpellApplyPatch</tt><big>(</big><em>toaster=None</em>, <em>data=None</em>, <em>stream=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellApplyPatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyffi.spells.Spell" title="pyffi.spells.Spell"><tt class="xref py py-class docutils literal"><span class="pre">pyffi.spells.Spell</span></tt></a></p>
<p>A spell for applying a patch on files.</p>
<dl class="method">
<dt id="pyffi.spells.SpellApplyPatch.datainspect">
<tt class="descname">datainspect</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.SpellApplyPatch.datainspect" title="Permalink to this definition">¶</a></dt>
<dd><p>There is no need to read the whole file, so we apply the patch
already at inspection stage, and stop the spell process by returning
<tt class="docutils literal"><span class="pre">False</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">False</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="docutils literal"><span class="pre">bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="adding-new-spells">
<h2>Adding new spells<a class="headerlink" href="#adding-new-spells" title="Permalink to this headline">¶</a></h2>
<p>To create new spells, derive your custom spells from the <a class="reference internal" href="#pyffi.spells.Spell" title="pyffi.spells.Spell"><tt class="xref py py-class docutils literal"><span class="pre">Spell</span></tt></a>
class, and include them in the <a class="reference internal" href="#pyffi.spells.Toaster.SPELLS" title="pyffi.spells.Toaster.SPELLS"><tt class="xref py py-attr docutils literal"><span class="pre">Toaster.SPELLS</span></tt></a> attribute of your
toaster.</p>
<dl class="class">
<dt id="pyffi.spells.Spell">
<em class="property">class </em><tt class="descclassname">pyffi.spells.</tt><tt class="descname">Spell</tt><big>(</big><em>toaster=None</em>, <em>data=None</em>, <em>stream=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.Spell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Spell base class. A spell takes a data file and then does something
useful with it. The main entry point for spells is <a class="reference internal" href="#pyffi.spells.Spell.recurse" title="pyffi.spells.Spell.recurse"><tt class="xref py py-meth docutils literal"><span class="pre">recurse()</span></tt></a>, so if you
are writing new spells, start with reading the documentation with
<a class="reference internal" href="#pyffi.spells.Spell.recurse" title="pyffi.spells.Spell.recurse"><tt class="xref py py-meth docutils literal"><span class="pre">recurse()</span></tt></a>.</p>
<dl class="attribute">
<dt id="pyffi.spells.Spell.READONLY">
<tt class="descname">READONLY</tt><em class="property"> = True</em><a class="headerlink" href="#pyffi.spells.Spell.READONLY" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="docutils literal"><span class="pre">bool</span></tt> which determines whether the spell is read only or
not. Default value is <tt class="docutils literal"><span class="pre">True</span></tt>. Override this class attribute, and
set to <tt class="docutils literal"><span class="pre">False</span></tt>, when subclassing a spell that must write files
back to the disk.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Spell.SPELLNAME">
<tt class="descname">SPELLNAME</tt><em class="property"> = None</em><a class="headerlink" href="#pyffi.spells.Spell.SPELLNAME" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="docutils literal"><span class="pre">str</span></tt> describing how to refer to the spell from the command line.
Override this class attribute when subclassing.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Spell.data">
<tt class="descname">data</tt><em class="property"> = None</em><a class="headerlink" href="#pyffi.spells.Spell.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="pyffi.object_models.html#pyffi.object_models.FileFormat.Data" title="pyffi.object_models.FileFormat.Data"><tt class="xref py py-class docutils literal"><span class="pre">Data</span></tt></a> instance
this spell acts on.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Spell.stream">
<tt class="descname">stream</tt><em class="property"> = None</em><a class="headerlink" href="#pyffi.spells.Spell.stream" title="Permalink to this definition">¶</a></dt>
<dd><p>The current <tt class="docutils literal"><span class="pre">file</span></tt> being processed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Spell.toaster">
<tt class="descname">toaster</tt><em class="property"> = None</em><a class="headerlink" href="#pyffi.spells.Spell.toaster" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pyffi.spells.Toaster" title="pyffi.spells.Toaster"><tt class="xref py py-class docutils literal"><span class="pre">Toaster</span></tt></a> instance this spell is called from.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell.__init__">
<tt class="descname">__init__</tt><big>(</big><em>toaster=None</em>, <em>data=None</em>, <em>stream=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the spell data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<a class="reference internal" href="pyffi.object_models.html#pyffi.object_models.FileFormat.Data" title="pyffi.object_models.FileFormat.Data"><tt class="xref py py-class docutils literal"><span class="pre">Data</span></tt></a>) &#8211; The file <a class="reference internal" href="#pyffi.spells.Spell.data" title="pyffi.spells.Spell.data"><tt class="xref py py-attr docutils literal"><span class="pre">data</span></tt></a>.</li>
<li><strong>stream</strong> (<tt class="docutils literal"><span class="pre">file</span></tt>) &#8211; The file <a class="reference internal" href="#pyffi.spells.Spell.stream" title="pyffi.spells.Spell.stream"><tt class="xref py py-attr docutils literal"><span class="pre">stream</span></tt></a>.</li>
<li><strong>toaster</strong> (<a class="reference internal" href="#pyffi.spells.Toaster" title="pyffi.spells.Toaster"><tt class="xref py py-class docutils literal"><span class="pre">Toaster</span></tt></a>) &#8211; The <a class="reference internal" href="#pyffi.spells.Spell.toaster" title="pyffi.spells.Spell.toaster"><tt class="xref py py-attr docutils literal"><span class="pre">toaster</span></tt></a> this spell is called from (optional).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell.recurse">
<tt class="descname">recurse</tt><big>(</big><em>branch=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.recurse" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function which calls <a class="reference internal" href="#pyffi.spells.Spell._branchinspect" title="pyffi.spells.Spell._branchinspect"><tt class="xref py py-meth docutils literal"><span class="pre">_branchinspect()</span></tt></a> and <a class="reference internal" href="#pyffi.spells.Spell.branchinspect" title="pyffi.spells.Spell.branchinspect"><tt class="xref py py-meth docutils literal"><span class="pre">branchinspect()</span></tt></a>
on the branch,
if both successful then <a class="reference internal" href="#pyffi.spells.Spell.branchentry" title="pyffi.spells.Spell.branchentry"><tt class="xref py py-meth docutils literal"><span class="pre">branchentry()</span></tt></a> on the branch, and if this is
succesful it calls <a class="reference internal" href="#pyffi.spells.Spell.recurse" title="pyffi.spells.Spell.recurse"><tt class="xref py py-meth docutils literal"><span class="pre">recurse()</span></tt></a> on the branch&#8217;s children, and
once all children are done, it calls <a class="reference internal" href="#pyffi.spells.Spell.branchexit" title="pyffi.spells.Spell.branchexit"><tt class="xref py py-meth docutils literal"><span class="pre">branchexit()</span></tt></a>.</p>
<p>Note that <a class="reference internal" href="#pyffi.spells.Spell._branchinspect" title="pyffi.spells.Spell._branchinspect"><tt class="xref py py-meth docutils literal"><span class="pre">_branchinspect()</span></tt></a> and <a class="reference internal" href="#pyffi.spells.Spell.branchinspect" title="pyffi.spells.Spell.branchinspect"><tt class="xref py py-meth docutils literal"><span class="pre">branchinspect()</span></tt></a> are not called upon
first entry of this function, that is, when called with <a class="reference internal" href="#pyffi.spells.Spell.data" title="pyffi.spells.Spell.data"><tt class="xref py py-attr docutils literal"><span class="pre">data</span></tt></a> as
branch argument. Use <a class="reference internal" href="#pyffi.spells.Spell.datainspect" title="pyffi.spells.Spell.datainspect"><tt class="xref py py-meth docutils literal"><span class="pre">datainspect()</span></tt></a> to stop recursion into this branch.</p>
<p>Do not override this function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>branch</strong> (<tt class="xref py py-class docutils literal"><span class="pre">GlobalNode</span></tt>) &#8211; The branch to start the recursion from, or <tt class="docutils literal"><span class="pre">None</span></tt>
to recurse the whole tree.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell._datainspect">
<tt class="descname">_datainspect</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.Spell._datainspect" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called after <a class="reference internal" href="pyffi.object_models.html#pyffi.object_models.FileFormat.Data.inspect" title="pyffi.object_models.FileFormat.Data.inspect"><tt class="xref py py-meth docutils literal"><span class="pre">pyffi.object_models.FileFormat.Data.inspect()</span></tt></a> has
been called, and before <a class="reference internal" href="pyffi.object_models.html#pyffi.object_models.FileFormat.Data.read" title="pyffi.object_models.FileFormat.Data.read"><tt class="xref py py-meth docutils literal"><span class="pre">pyffi.object_models.FileFormat.Data.read()</span></tt></a> is
called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">True</span></tt> if the file must be processed, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="docutils literal"><span class="pre">bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell.datainspect">
<tt class="descname">datainspect</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.datainspect" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called after <a class="reference internal" href="pyffi.object_models.html#pyffi.object_models.FileFormat.Data.inspect" title="pyffi.object_models.FileFormat.Data.inspect"><tt class="xref py py-meth docutils literal"><span class="pre">pyffi.object_models.FileFormat.Data.inspect()</span></tt></a> has
been called, and before <a class="reference internal" href="pyffi.object_models.html#pyffi.object_models.FileFormat.Data.read" title="pyffi.object_models.FileFormat.Data.read"><tt class="xref py py-meth docutils literal"><span class="pre">pyffi.object_models.FileFormat.Data.read()</span></tt></a> is
called. Override this function for customization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">True</span></tt> if the file must be processed, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="docutils literal"><span class="pre">bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell._branchinspect">
<tt class="descname">_branchinspect</tt><big>(</big><em>branch</em><big>)</big><a class="headerlink" href="#pyffi.spells.Spell._branchinspect" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if spell should be cast on this branch or not, based on
exclude and include options passed on the command line. You should
not need to override this function: if you need additional checks on
whether a branch must be parsed or not, override the <a class="reference internal" href="#pyffi.spells.Spell.branchinspect" title="pyffi.spells.Spell.branchinspect"><tt class="xref py py-meth docutils literal"><span class="pre">branchinspect()</span></tt></a>
method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>branch</strong> (<tt class="xref py py-class docutils literal"><span class="pre">GlobalNode</span></tt>) &#8211; The branch to check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">True</span></tt> if the branch must be processed, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="docutils literal"><span class="pre">bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell.branchinspect">
<tt class="descname">branchinspect</tt><big>(</big><em>branch</em><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.branchinspect" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#pyffi.spells.Spell._branchinspect" title="pyffi.spells.Spell._branchinspect"><tt class="xref py py-meth docutils literal"><span class="pre">_branchinspect()</span></tt></a>, but for customization: can be overridden to
perform an extra inspection (the default implementation always
returns <tt class="docutils literal"><span class="pre">True</span></tt>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>branch</strong> (<tt class="xref py py-class docutils literal"><span class="pre">GlobalNode</span></tt>) &#8211; The branch to check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">True</span></tt> if the branch must be processed, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="docutils literal"><span class="pre">bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell.dataentry">
<tt class="descname">dataentry</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.dataentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Called before all blocks are recursed.
The default implementation simply returns <tt class="docutils literal"><span class="pre">True</span></tt>.
You can access the data via <a class="reference internal" href="#pyffi.spells.Spell.data" title="pyffi.spells.Spell.data"><tt class="xref py py-attr docutils literal"><span class="pre">data</span></tt></a>, and unlike in the
<a class="reference internal" href="#pyffi.spells.Spell.datainspect" title="pyffi.spells.Spell.datainspect"><tt class="xref py py-meth docutils literal"><span class="pre">datainspect()</span></tt></a> method, the full file has been processed at this stage.</p>
<p>Typically, you will override this function to perform a global
operation on the file data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">True</span></tt> if the children must be processed, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="docutils literal"><span class="pre">bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell.dataexit">
<tt class="descname">dataexit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.dataexit" title="Permalink to this definition">¶</a></dt>
<dd><p>Called after all blocks have been processed, if <a class="reference internal" href="#pyffi.spells.Spell.dataentry" title="pyffi.spells.Spell.dataentry"><tt class="xref py py-meth docutils literal"><span class="pre">dataentry()</span></tt></a>
returned <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>Typically, you will override this function to perform a final spell
operation, such as writing back the file in a special way, or making a
summary log.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell.branchentry">
<tt class="descname">branchentry</tt><big>(</big><em>branch</em><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.branchentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast the spell on the given branch. First called with branch equal to
<a class="reference internal" href="#pyffi.spells.Spell.data" title="pyffi.spells.Spell.data"><tt class="xref py py-attr docutils literal"><span class="pre">data</span></tt></a>&#8216;s children, then the grandchildren, and so on.
The default implementation simply returns <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>Typically, you will override this function to perform an operation
on a particular block type and/or to stop recursion at particular
block types.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>branch</strong> (<tt class="xref py py-class docutils literal"><span class="pre">GlobalNode</span></tt>) &#8211; The branch to cast the spell on.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">True</span></tt> if the children must be processed, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="docutils literal"><span class="pre">bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Spell.branchexit">
<tt class="descname">branchexit</tt><big>(</big><em>branch</em><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.branchexit" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast a spell on the given branch, after all its children,
grandchildren, have been processed, if <a class="reference internal" href="#pyffi.spells.Spell.branchentry" title="pyffi.spells.Spell.branchentry"><tt class="xref py py-meth docutils literal"><span class="pre">branchentry()</span></tt></a> returned
<tt class="docutils literal"><span class="pre">True</span></tt> on the given branch.</p>
<p>Typically, you will override this function to perform a particular
operation on a block type, but you rely on the fact that the children
must have been processed first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>branch</strong> (<tt class="xref py py-class docutils literal"><span class="pre">GlobalNode</span></tt>) &#8211; The branch to cast the spell on.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyffi.spells.Spell.toastentry">
<em class="property">classmethod </em><tt class="descname">toastentry</tt><big>(</big><em>toaster</em><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.toastentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Called just before the toaster starts processing
all files. If it returns <tt class="docutils literal"><span class="pre">False</span></tt>, then the spell is not used.
The default implementation simply returns <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>For example, if the spell only acts on a particular block type, but
that block type is excluded, then you can use this function to flag
that this spell can be skipped. You can also use this function to
initialize statistics data to be aggregated from files, to
initialize a log file, and so.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>toaster</strong> (<a class="reference internal" href="#pyffi.spells.Toaster" title="pyffi.spells.Toaster"><tt class="xref py py-class docutils literal"><span class="pre">Toaster</span></tt></a>) &#8211; The toaster this spell is called from.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><tt class="docutils literal"><span class="pre">True</span></tt> if the spell applies, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="docutils literal"><span class="pre">bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pyffi.spells.Spell.toastexit">
<em class="property">classmethod </em><tt class="descname">toastexit</tt><big>(</big><em>toaster</em><big>)</big><a class="headerlink" href="#pyffi.spells.Spell.toastexit" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when the toaster has finished processing
all files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>toaster</strong> (<a class="reference internal" href="#pyffi.spells.Toaster" title="pyffi.spells.Toaster"><tt class="xref py py-class docutils literal"><span class="pre">Toaster</span></tt></a>) &#8211; The toaster this spell is called from.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="grouping-spells-together">
<h2>Grouping spells together<a class="headerlink" href="#grouping-spells-together" title="Permalink to this headline">¶</a></h2>
<p>It is also possible to create composite spells, that is, spells that
simply execute other spells. The following functions and classes can
be used for this purpose.</p>
<dl class="function">
<dt id="pyffi.spells.SpellGroupParallel">
<tt class="descclassname">pyffi.spells.</tt><tt class="descname">SpellGroupParallel</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupParallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Class factory for grouping spells in parallel.</p>
</dd></dl>

<dl class="function">
<dt id="pyffi.spells.SpellGroupSeries">
<tt class="descclassname">pyffi.spells.</tt><tt class="descname">SpellGroupSeries</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Class factory for grouping spells in series.</p>
</dd></dl>

<dl class="class">
<dt id="pyffi.spells.SpellGroupBase">
<em class="property">class </em><tt class="descclassname">pyffi.spells.</tt><tt class="descname">SpellGroupBase</tt><big>(</big><em>toaster=None</em>, <em>data=None</em>, <em>stream=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyffi.spells.Spell" title="pyffi.spells.Spell"><tt class="xref py py-class docutils literal"><span class="pre">pyffi.spells.Spell</span></tt></a></p>
<p>Base class for grouping spells. This implements all the spell grouping
functions that fall outside of the actual recursing (<tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt>,
<a class="reference internal" href="#pyffi.spells.SpellGroupBase.toastentry" title="pyffi.spells.SpellGroupBase.toastentry"><tt class="xref py py-meth docutils literal"><span class="pre">toastentry()</span></tt></a>, <tt class="xref py py-meth docutils literal"><span class="pre">_datainspect()</span></tt>, <a class="reference internal" href="#pyffi.spells.SpellGroupBase.datainspect" title="pyffi.spells.SpellGroupBase.datainspect"><tt class="xref py py-meth docutils literal"><span class="pre">datainspect()</span></tt></a>, and <a class="reference internal" href="#pyffi.spells.SpellGroupBase.toastexit" title="pyffi.spells.SpellGroupBase.toastexit"><tt class="xref py py-meth docutils literal"><span class="pre">toastexit()</span></tt></a>).</p>
<dl class="attribute">
<dt id="pyffi.spells.SpellGroupBase.ACTIVESPELLCLASSES">
<tt class="descname">ACTIVESPELLCLASSES</tt><em class="property"> = []</em><a class="headerlink" href="#pyffi.spells.SpellGroupBase.ACTIVESPELLCLASSES" title="Permalink to this definition">¶</a></dt>
<dd><p>List of active spells of this group (not instantiated).
This list is automatically built when <a class="reference internal" href="#pyffi.spells.SpellGroupBase.toastentry" title="pyffi.spells.SpellGroupBase.toastentry"><tt class="xref py py-meth docutils literal"><span class="pre">toastentry()</span></tt></a> is called.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.SpellGroupBase.SPELLCLASSES">
<tt class="descname">SPELLCLASSES</tt><em class="property"> = []</em><a class="headerlink" href="#pyffi.spells.SpellGroupBase.SPELLCLASSES" title="Permalink to this definition">¶</a></dt>
<dd><p>List of <a class="reference internal" href="#pyffi.spells.Spell" title="pyffi.spells.Spell"><tt class="xref py py-class docutils literal"><span class="pre">Spell</span></tt></a>s of this group (not instantiated).</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.SpellGroupBase.datainspect">
<tt class="descname">datainspect</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupBase.datainspect" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspect every spell with L{Spell.datainspect} and keep
those spells that must be cast.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.SpellGroupBase.spells">
<tt class="descname">spells</tt><em class="property"> = []</em><a class="headerlink" href="#pyffi.spells.SpellGroupBase.spells" title="Permalink to this definition">¶</a></dt>
<dd><p>List of active spell instances.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyffi.spells.SpellGroupBase.toastentry">
<em class="property">classmethod </em><tt class="descname">toastentry</tt><big>(</big><em>toaster</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupBase.toastentry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pyffi.spells.SpellGroupBase.toastexit">
<em class="property">classmethod </em><tt class="descname">toastexit</tt><big>(</big><em>toaster</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupBase.toastexit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyffi.spells.SpellGroupParallelBase">
<em class="property">class </em><tt class="descclassname">pyffi.spells.</tt><tt class="descname">SpellGroupParallelBase</tt><big>(</big><em>toaster=None</em>, <em>data=None</em>, <em>stream=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupParallelBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyffi.spells.SpellGroupBase" title="pyffi.spells.SpellGroupBase"><tt class="xref py py-class docutils literal"><span class="pre">pyffi.spells.SpellGroupBase</span></tt></a></p>
<p>Base class for running spells in parallel (that is, with only
a single recursion in the tree).</p>
<dl class="method">
<dt id="pyffi.spells.SpellGroupParallelBase.branchentry">
<tt class="descname">branchentry</tt><big>(</big><em>branch</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupParallelBase.branchentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Run all spells.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.SpellGroupParallelBase.branchexit">
<tt class="descname">branchexit</tt><big>(</big><em>branch</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupParallelBase.branchexit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyffi.spells.SpellGroupParallelBase.branchinspect">
<tt class="descname">branchinspect</tt><big>(</big><em>branch</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupParallelBase.branchinspect" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspect spells with <a class="reference internal" href="#pyffi.spells.Spell.branchinspect" title="pyffi.spells.Spell.branchinspect"><tt class="xref py py-meth docutils literal"><span class="pre">Spell.branchinspect()</span></tt></a> (not all checks are
executed, only keeps going until a spell inspection returns <tt class="docutils literal"><span class="pre">True</span></tt>).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.SpellGroupParallelBase.changed">
<tt class="descname">changed</tt><a class="headerlink" href="#pyffi.spells.SpellGroupParallelBase.changed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyffi.spells.SpellGroupParallelBase.dataentry">
<tt class="descname">dataentry</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupParallelBase.dataentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Look into every spell with <a class="reference internal" href="#pyffi.spells.Spell.dataentry" title="pyffi.spells.Spell.dataentry"><tt class="xref py py-meth docutils literal"><span class="pre">Spell.dataentry()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.SpellGroupParallelBase.dataexit">
<tt class="descname">dataexit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupParallelBase.dataexit" title="Permalink to this definition">¶</a></dt>
<dd><p>Look into every spell with <a class="reference internal" href="#pyffi.spells.Spell.dataexit" title="pyffi.spells.Spell.dataexit"><tt class="xref py py-meth docutils literal"><span class="pre">Spell.dataexit()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyffi.spells.SpellGroupSeriesBase">
<em class="property">class </em><tt class="descclassname">pyffi.spells.</tt><tt class="descname">SpellGroupSeriesBase</tt><big>(</big><em>toaster=None</em>, <em>data=None</em>, <em>stream=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupSeriesBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyffi.spells.SpellGroupBase" title="pyffi.spells.SpellGroupBase"><tt class="xref py py-class docutils literal"><span class="pre">pyffi.spells.SpellGroupBase</span></tt></a></p>
<p>Base class for running spells in series.</p>
<dl class="method">
<dt id="pyffi.spells.SpellGroupSeriesBase.branchentry">
<tt class="descname">branchentry</tt><big>(</big><em>branch</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupSeriesBase.branchentry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyffi.spells.SpellGroupSeriesBase.branchinspect">
<tt class="descname">branchinspect</tt><big>(</big><em>branch</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupSeriesBase.branchinspect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.SpellGroupSeriesBase.changed">
<tt class="descname">changed</tt><a class="headerlink" href="#pyffi.spells.SpellGroupSeriesBase.changed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyffi.spells.SpellGroupSeriesBase.dataentry">
<tt class="descname">dataentry</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupSeriesBase.dataentry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyffi.spells.SpellGroupSeriesBase.dataexit">
<tt class="descname">dataexit</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupSeriesBase.dataexit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyffi.spells.SpellGroupSeriesBase.recurse">
<tt class="descname">recurse</tt><big>(</big><em>branch=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.SpellGroupSeriesBase.recurse" title="Permalink to this definition">¶</a></dt>
<dd><p>Recurse spells in series.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="creating-toaster-scripts">
<h2>Creating toaster scripts<a class="headerlink" href="#creating-toaster-scripts" title="Permalink to this headline">¶</a></h2>
<p>To create a new toaster script, derive your toaster from the <a class="reference internal" href="#pyffi.spells.Toaster" title="pyffi.spells.Toaster"><tt class="xref py py-class docutils literal"><span class="pre">Toaster</span></tt></a>
class, and set the <a class="reference internal" href="#pyffi.spells.Toaster.FILEFORMAT" title="pyffi.spells.Toaster.FILEFORMAT"><tt class="xref py py-attr docutils literal"><span class="pre">Toaster.FILEFORMAT</span></tt></a> attribute of your toaster to
the file format class of the files it can toast.</p>
<dl class="class">
<dt id="pyffi.spells.Toaster">
<em class="property">class </em><tt class="descclassname">pyffi.spells.</tt><tt class="descname">Toaster</tt><big>(</big><em>spellclass=None</em>, <em>options=None</em>, <em>spellnames=None</em>, <em>logger=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Toaster base class. Toasters run spells on large quantities of files.
They load each file and pass the data structure to any number of spells.</p>
<dl class="attribute">
<dt id="pyffi.spells.Toaster.ALIASDICT">
<tt class="descname">ALIASDICT</tt><em class="property"> = {}</em><a class="headerlink" href="#pyffi.spells.Toaster.ALIASDICT" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary with aliases for spells.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.DEFAULT_OPTIONS">
<tt class="descname">DEFAULT_OPTIONS</tt><em class="property"> = {'patchcmd': '', 'dryrun': False, 'sourcedir': '', 'resume': False, 'skip': [], 'inifile': '', 'helpspell': False, 'destdir': '', 'prefix': '', 'examples': False, 'arg': '', 'jobs': 8, 'exclude': [], 'createpatch': False, 'suffix': '', 'pause': False, 'verbose': 1, 'gccollect': False, 'raisetesterror': False, 'applypatch': False, 'refresh': 32, 'diffcmd': '', 'include': [], 'only': [], 'archives': False, 'series': False, 'spells': False, 'interactive': True}</em><a class="headerlink" href="#pyffi.spells.Toaster.DEFAULT_OPTIONS" title="Permalink to this definition">¶</a></dt>
<dd><p>List of spell classes of the particular <a class="reference internal" href="#pyffi.spells.Toaster" title="pyffi.spells.Toaster"><tt class="xref py py-class docutils literal"><span class="pre">Toaster</span></tt></a> instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.EXAMPLES">
<tt class="descname">EXAMPLES</tt><em class="property"> = ''</em><a class="headerlink" href="#pyffi.spells.Toaster.EXAMPLES" title="Permalink to this definition">¶</a></dt>
<dd><p>Some examples which describe typical use of the toaster.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.FILEFORMAT">
<tt class="descname">FILEFORMAT</tt><a class="headerlink" href="#pyffi.spells.Toaster.FILEFORMAT" title="Permalink to this definition">¶</a></dt>
<dd><p>The file format class (a subclass of
<a class="reference internal" href="pyffi.object_models.html#pyffi.object_models.FileFormat" title="pyffi.object_models.FileFormat"><tt class="xref py py-class docutils literal"><span class="pre">FileFormat</span></tt></a>).</p>
<p>alias of <tt class="xref py py-class docutils literal"><span class="pre">FileFormat</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.SPELLS">
<tt class="descname">SPELLS</tt><em class="property"> = []</em><a class="headerlink" href="#pyffi.spells.Toaster.SPELLS" title="Permalink to this definition">¶</a></dt>
<dd><p>List of all available <a class="reference internal" href="#pyffi.spells.Spell" title="pyffi.spells.Spell"><tt class="xref py py-class docutils literal"><span class="pre">Spell</span></tt></a> classes.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.cli">
<tt class="descname">cli</tt><big>(</big><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.cli" title="Permalink to this definition">¶</a></dt>
<dd><p>Command line interface: initializes spell classes and options from
the command line, and run the <a class="reference internal" href="#pyffi.spells.Toaster.toast" title="pyffi.spells.Toaster.toast"><tt class="xref py py-meth docutils literal"><span class="pre">toast()</span></tt></a> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.exclude_types">
<tt class="descname">exclude_types</tt><em class="property"> = []</em><a class="headerlink" href="#pyffi.spells.Toaster.exclude_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of types corresponding to the exclude key of <a class="reference internal" href="#pyffi.spells.Toaster.options" title="pyffi.spells.Toaster.options"><tt class="xref py py-attr docutils literal"><span class="pre">options</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.get_toast_head_root_ext">
<tt class="descname">get_toast_head_root_ext</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.get_toast_head_root_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of where the input file <em>filename</em> would
be written to by the toaster: head, root, and extension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<tt class="xref py py-class docutils literal"><span class="pre">str</span></tt>) &#8211; The name of the hypothetical file to be
toasted.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The head, root, and extension of the destination, or
<tt class="docutils literal"><span class="pre">(None,</span> <span class="pre">None,</span> <span class="pre">None)</span></tt> if <tt class="docutils literal"><span class="pre">--dry-run</span></tt> is specified.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt> of three <tt class="xref py py-class docutils literal"><span class="pre">str</span></tt>s</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.get_toast_stream">
<tt class="descname">get_toast_stream</tt><big>(</big><em>filename</em>, <em>test_exists=False</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.get_toast_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <tt class="xref py py-meth docutils literal"><span class="pre">get_toast_head_root_ext(filename)()</span></tt>
to determine the name of the toast file, and return
a stream for writing accordingly.</p>
<p>Then return a stream where result can be written to, or
in case test_exists is True, test if result would overwrite a
file. More specifically, if test_exists is True, then no
streams are created, and True is returned if the file
already exists, and False is returned otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.include_types">
<tt class="descname">include_types</tt><em class="property"> = []</em><a class="headerlink" href="#pyffi.spells.Toaster.include_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of types corresponding to the include key of <a class="reference internal" href="#pyffi.spells.Toaster.options" title="pyffi.spells.Toaster.options"><tt class="xref py py-attr docutils literal"><span class="pre">options</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.indent">
<tt class="descname">indent</tt><em class="property"> = 0</em><a class="headerlink" href="#pyffi.spells.Toaster.indent" title="Permalink to this definition">¶</a></dt>
<dd><p>An <tt class="docutils literal"><span class="pre">int</span></tt> which describes the current indentation level for messages.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.inspect_filename">
<tt class="descname">inspect_filename</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.inspect_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether to toast a filename or not, based on
skip_regexs and only_regexs.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.is_admissible_branch_class">
<tt class="descname">is_admissible_branch_class</tt><big>(</big><em>branchtype</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.is_admissible_branch_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function which checks whether a given branch type should
have spells cast on it or not, based in exclude and include options.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyffi.formats.nif</span> <span class="kn">import</span> <span class="n">NifFormat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyToaster</span><span class="p">(</span><span class="n">Toaster</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">FILEFORMAT</span> <span class="o">=</span> <span class="n">NifFormat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span> <span class="o">=</span> <span class="n">MyToaster</span><span class="p">()</span> <span class="c"># no include or exclude: all admissible</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiProperty</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiNode</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiAVObject</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiLODNode</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiMaterialProperty</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span> <span class="o">=</span> <span class="n">MyToaster</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;exclude&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;NiProperty&quot;</span><span class="p">,</span> <span class="s">&quot;NiNode&quot;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiProperty</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiNode</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiAVObject</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiLODNode</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiMaterialProperty</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span> <span class="o">=</span> <span class="n">MyToaster</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;include&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;NiProperty&quot;</span><span class="p">,</span> <span class="s">&quot;NiNode&quot;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiProperty</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiNode</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiAVObject</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiLODNode</span><span class="p">)</span> <span class="c"># NiNodes are!</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiMaterialProperty</span><span class="p">)</span> <span class="c"># NiProperties are!</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span> <span class="o">=</span> <span class="n">MyToaster</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;include&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;NiProperty&quot;</span><span class="p">,</span> <span class="s">&quot;NiNode&quot;</span><span class="p">],</span> <span class="s">&quot;exclude&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;NiMaterialProperty&quot;</span><span class="p">,</span> <span class="s">&quot;NiLODNode&quot;</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiProperty</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiNode</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiAVObject</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiLODNode</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiSwitchNode</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiMaterialProperty</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">is_admissible_branch_class</span><span class="p">(</span><span class="n">NifFormat</span><span class="o">.</span><span class="n">NiAlphaProperty</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.logger">
<tt class="descname">logger</tt><em class="property"> = &lt;logging.Logger object at 0xb13b090&gt;</em><a class="headerlink" href="#pyffi.spells.Toaster.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="xref py py-class docutils literal"><span class="pre">logging.Logger</span></tt> for toaster log messages.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.msg">
<tt class="descname">msg</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Write log message with <tt class="xref py py-meth docutils literal"><span class="pre">logger.info()</span></tt>, taking into account
<a class="reference internal" href="#pyffi.spells.Toaster.indent" title="pyffi.spells.Toaster.indent"><tt class="xref py py-attr docutils literal"><span class="pre">indent</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>message</strong> (<tt class="docutils literal"><span class="pre">str</span></tt>) &#8211; The message to write.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.msgblockbegin">
<tt class="descname">msgblockbegin</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.msgblockbegin" title="Permalink to this definition">¶</a></dt>
<dd><p>Acts like <a class="reference internal" href="#pyffi.spells.Toaster.msg" title="pyffi.spells.Toaster.msg"><tt class="xref py py-meth docutils literal"><span class="pre">msg()</span></tt></a>, but also increases <a class="reference internal" href="#pyffi.spells.Toaster.indent" title="pyffi.spells.Toaster.indent"><tt class="xref py py-attr docutils literal"><span class="pre">indent</span></tt></a> after writing the
message.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.msgblockend">
<tt class="descname">msgblockend</tt><big>(</big><em>message=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.msgblockend" title="Permalink to this definition">¶</a></dt>
<dd><p>Acts like <a class="reference internal" href="#pyffi.spells.Toaster.msg" title="pyffi.spells.Toaster.msg"><tt class="xref py py-meth docutils literal"><span class="pre">msg()</span></tt></a>, but also decreases <a class="reference internal" href="#pyffi.spells.Toaster.indent" title="pyffi.spells.Toaster.indent"><tt class="xref py py-attr docutils literal"><span class="pre">indent</span></tt></a> before writing the
message, but if the message argument is <tt class="docutils literal"><span class="pre">None</span></tt>, then no message is
printed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.only_regexs">
<tt class="descname">only_regexs</tt><em class="property"> = []</em><a class="headerlink" href="#pyffi.spells.Toaster.only_regexs" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of regular expressions corresponding to the only key of
<a class="reference internal" href="#pyffi.spells.Toaster.options" title="pyffi.spells.Toaster.options"><tt class="xref py py-attr docutils literal"><span class="pre">options</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.options">
<tt class="descname">options</tt><em class="property"> = {}</em><a class="headerlink" href="#pyffi.spells.Toaster.options" title="Permalink to this definition">¶</a></dt>
<dd><p>The options of the toaster, as <tt class="docutils literal"><span class="pre">dict</span></tt>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pyffi.spells.Toaster.parse_inifile">
<em class="property">static </em><tt class="descname">parse_inifile</tt><big>(</big><em>option</em>, <em>opt</em>, <em>value</em>, <em>parser</em>, <em>toaster=None</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.parse_inifile" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes spell classes and options from an ini file.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyffi.spells.nif</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyffi.spells.nif.modify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">NifToaster</span><span class="p">(</span><span class="n">pyffi</span><span class="o">.</span><span class="n">spells</span><span class="o">.</span><span class="n">nif</span><span class="o">.</span><span class="n">NifToaster</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">SPELLS</span> <span class="o">=</span> <span class="p">[</span><span class="n">pyffi</span><span class="o">.</span><span class="n">spells</span><span class="o">.</span><span class="n">nif</span><span class="o">.</span><span class="n">modify</span><span class="o">.</span><span class="n">SpellDelBranches</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;[main]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;spell = modify_delbranches</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;folder = tests/nif/test_vertexcolor.nif</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;[options]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;source-dir = tests/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;dest-dir = _tests/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;exclude = NiVertexColorProperty NiStencilProperty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;skip = &#39;testing quoted string&#39;    normal_string</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cfg</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span> <span class="o">=</span> <span class="n">NifToaster</span><span class="p">(</span><span class="n">logger</span><span class="o">=</span><span class="n">fake_logger</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="s">&quot;niftoaster.py&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s">&quot;--ini-file=utilities/toaster/default.ini&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s">&quot;--ini-file=</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">cfg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s">&quot;--noninteractive&quot;</span><span class="p">,</span> <span class="s">&quot;--jobs=1&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toaster</span><span class="o">.</span><span class="n">cli</span><span class="p">()</span>
<span class="go">pyffi.toaster:INFO:=== tests/nif/test_vertexcolor.nif ===</span>
<span class="go">pyffi.toaster:INFO:  --- modify_delbranches ---</span>
<span class="go">pyffi.toaster:INFO:    ~~~ NiNode [Scene Root] ~~~</span>
<span class="go">pyffi.toaster:INFO:      ~~~ NiTriStrips [Cube] ~~~</span>
<span class="go">pyffi.toaster:INFO:        ~~~ NiStencilProperty [] ~~~</span>
<span class="go">pyffi.toaster:INFO:          stripping this branch</span>
<span class="go">pyffi.toaster:INFO:        ~~~ NiSpecularProperty [] ~~~</span>
<span class="go">pyffi.toaster:INFO:        ~~~ NiMaterialProperty [Material] ~~~</span>
<span class="go">pyffi.toaster:INFO:        ~~~ NiVertexColorProperty [] ~~~</span>
<span class="go">pyffi.toaster:INFO:          stripping this branch</span>
<span class="go">pyffi.toaster:INFO:        ~~~ NiTriStripsData [] ~~~</span>
<span class="go">pyffi.toaster:INFO:creating destination path _tests/nif</span>
<span class="go">pyffi.toaster:INFO:  writing _tests/nif/test_vertexcolor.nif</span>
<span class="go">pyffi.toaster:INFO:Finished.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&quot;_tests/nif/test_vertexcolor.nif&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="s">&quot;_tests/nif/&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="s">&quot;_tests/&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">toaster</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
<span class="go">applypatch: False</span>
<span class="go">archives: False</span>
<span class="go">arg: </span>
<span class="go">createpatch: False</span>
<span class="go">destdir: _tests/</span>
<span class="go">diffcmd: </span>
<span class="go">dryrun: False</span>
<span class="go">examples: False</span>
<span class="go">exclude: [&#39;NiVertexColorProperty&#39;, &#39;NiStencilProperty&#39;]</span>
<span class="go">gccollect: False</span>
<span class="go">helpspell: False</span>
<span class="go">include: []</span>
<span class="go">inifile: </span>
<span class="go">interactive: False</span>
<span class="go">jobs: 1</span>
<span class="go">only: []</span>
<span class="go">patchcmd: </span>
<span class="go">pause: True</span>
<span class="go">prefix: </span>
<span class="go">raisetesterror: False</span>
<span class="go">refresh: 32</span>
<span class="go">resume: True</span>
<span class="go">series: False</span>
<span class="go">skip: [&#39;testing quoted string&#39;, &#39;normal_string&#39;]</span>
<span class="go">sourcedir: tests/</span>
<span class="go">spells: False</span>
<span class="go">suffix: </span>
<span class="go">verbose: 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.skip_regexs">
<tt class="descname">skip_regexs</tt><em class="property"> = []</em><a class="headerlink" href="#pyffi.spells.Toaster.skip_regexs" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of regular expressions corresponding to the skip key of
<a class="reference internal" href="#pyffi.spells.Toaster.options" title="pyffi.spells.Toaster.options"><tt class="xref py py-attr docutils literal"><span class="pre">options</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.spellnames">
<tt class="descname">spellnames</tt><em class="property"> = []</em><a class="headerlink" href="#pyffi.spells.Toaster.spellnames" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the names of the spells.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.toast">
<tt class="descname">toast</tt><big>(</big><em>top</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.toast" title="Permalink to this definition">¶</a></dt>
<dd><p>Walk over all files in a directory tree and cast spells
on every file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>top</strong> (<em>str</em>) &#8211; The directory or file to toast.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.toast_archives">
<tt class="descname">toast_archives</tt><big>(</big><em>top</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.toast_archives" title="Permalink to this definition">¶</a></dt>
<dd><p>Toast all files in all archives.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyffi.spells.Toaster.top">
<tt class="descname">top</tt><em class="property"> = ''</em><a class="headerlink" href="#pyffi.spells.Toaster.top" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the top folder to toast.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.write">
<tt class="descname">write</tt><big>(</big><em>stream</em>, <em>data</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the data to data and raises an exception if the
write fails, but restores file if fails on overwrite.</p>
</dd></dl>

<dl class="method">
<dt id="pyffi.spells.Toaster.writepatch">
<tt class="descname">writepatch</tt><big>(</big><em>stream</em>, <em>data</em><big>)</big><a class="headerlink" href="#pyffi.spells.Toaster.writepatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a binary patch for the updated file.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">pyffi.spells</span></tt> &#8212; High level file operations</a><ul>
<li><a class="reference internal" href="#supported-spells">Supported spells</a><ul>
</ul>
</li>
<li><a class="reference internal" href="#adding-new-spells">Adding new spells</a></li>
<li><a class="reference internal" href="#grouping-spells-together">Grouping spells together</a></li>
<li><a class="reference internal" href="#creating-toaster-scripts">Creating toaster scripts</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pyffi.formats.tri.html"
                        title="previous chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">pyffi.formats.tri</span></tt> &#8212; TRI (.tri)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyffi.spells.cgf.html"
                        title="next chapter"><tt class="docutils literal"><span class="pre">pyffi.spells.cgf</span></tt> &#8212;  Crytek Geometry/Animation (.cgf/.cga) spells</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pyffi.spells.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyffi.spells.cgf.html" title="pyffi.spells.cgf — Crytek Geometry/Animation (.cgf/.cga) spells"
             >next</a> |</li>
        <li class="right" >
          <a href="pyffi.formats.tri.html" title="pyffi.formats.tri — TRI (.tri)"
             >previous</a> |</li>
        <li><a href="index.html">PyFFI 2.2.2 documentation</a> &raquo;</li>
          <li><a href="pyffi.html" ><tt class="docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal docutils literal"><span class="pre">pyffi</span></tt> &#8212; Interfacing block structured files</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2007-2012, Amorilia.
      Last updated on Nov 17, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    <br/><a href="http://sourceforge.net/projects/pyffi"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=199269&amp;type=10" width="80" height="15" alt="Get Python File Format Interface at SourceForge.net." /></a>
    </div>
  </body>
</html>