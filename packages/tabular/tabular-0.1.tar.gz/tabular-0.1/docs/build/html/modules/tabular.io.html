

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tabular.io &mdash; tabular v0.0.8 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="tabular v0.0.8 documentation" href="../index.html" />
    <link rel="next" title="tabular.spreadsheet" href="tabular.spreadsheet.html" />
    <link rel="prev" title="tabular.tab" href="tabular.tab.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tabular.spreadsheet.html" title="tabular.spreadsheet"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tabular.tab.html" title="tabular.tab"
             accesskey="P">previous</a> |</li>
    
        <li><a href="../index.html">tabular</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-tabular.io">
<span id="tabular-io"></span><h1><a class="reference internal" href="#module-tabular.io" title="tabular.io"><tt class="xref py py-mod docutils literal"><span class="pre">tabular.io</span></tt></a><a class="headerlink" href="#module-tabular.io" title="Permalink to this headline">¶</a></h1>
<p>Functions for <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a> i/o methods, including to/from 
separated-value (CSV, e.g. <tt class="docutils literal"><span class="pre">.tsv</span></tt>, <tt class="docutils literal"><span class="pre">.csv</span></tt>) and other text files, binary 
files, hierarchical separated-value (HSV) format.</p>
<dl class="function">
<dt id="tabular.io.loadSV">
<tt class="descclassname">tabular.io.</tt><tt class="descname">loadSV</tt><big>(</big><em>fname</em>, <em>shape=None</em>, <em>titles=None</em>, <em>aligned=False</em>, <em>byteorder=None</em>, <em>renamer=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tabular.io.loadSV" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a delimited text file to a numpy record array.</p>
<p>Basically, this function calls loadSVcols and combines columns returned by that function into a numpy ndarray with stuctured dtype.  Also uses and returns metadata including column names, formats, coloring, &amp;c. if these items are determined during the loading process.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string or file object</p>
<blockquote>
<div><blockquote>
<div>Path (or file object) corresponding to a separated variable
(CSV) text file.</div></blockquote>
<p><strong>names</strong> : list of strings</p>
<blockquote>
<div>Sets the names of the columns of the resulting tabarray.   If not specified, <cite>names</cite> value is determined first by looking for metadata in the header of the file, and if that is not found, are assigned by NumPy&#8217;s <cite>f0, f1, ... fn</cite> convention.     See <strong>namesinheader</strong> parameter below.</div></blockquote>
</div></blockquote>
<p><strong>formats</strong> :  string or list of strings</p>
<blockquote>
<div><p>Sets the datatypes of the columns.  The value of <cite>formats</cite> can be a list or comma-delimited string of values describing values for each column (e.g. &#8220;str,str,int,float&#8221; or [&#8220;str&#8221;, &#8220;str&#8221;, &#8220;int&#8221;, &#8220;float&#8221;]), a single value to apply to all columns, or anything that can be used in numpy.rec.array constructor.</p>
<p>If the <strong>formats</strong> (or <strong>dtype</strong>) parameter are not  specified, typing is done by inference.   (See also <strong>typer</strong> parameter below).</p>
</div></blockquote>
<p><strong>dtype</strong> : numpy dtype object</p>
<blockquote>
<div><blockquote>
<div>Sets the numpy dtype of the resulting tabarray, combining column format and column name information.  If dtype is set, any <strong>names</strong> and <strong>formats</strong> specifications will be overriden.   If the <strong>dtype</strong> (or <strong>formats</strong>) parameter are not  specified, typing is done by inference.   (See also <strong>typer</strong> parameter below).</div></blockquote>
<p>The <strong>names</strong>, <strong>formats</strong> and <strong>dtype</strong> parameters duplicate parameters of the NumPy record array creation inferface.   Additional paramters of the NumPy inferface that are passed through are <strong>shape</strong>, <strong>titles</strong>, <strong>byteorder</strong> and <strong>aligned</strong> (see NumPy documentation for more information.)</p>
</div></blockquote>
</div></blockquote>
<p><strong>kwargs</strong>: keyword argument dictionary of variable length</p>
<blockquote>
<div>Contains various parameters to be passed down to loadSVcols.  These may include  <strong>skiprows</strong>, <strong>comments</strong>, <strong>delimiter</strong>, <strong>lineterminator</strong>, <strong>uselines</strong>, <strong>usecols</strong>, <strong>excludecols</strong>, <strong>metametadata</strong>, <strong>namesinheader</strong>,**headerlines**, <strong>valuefixer</strong>, <strong>linefixer</strong>, <strong>colfixer</strong>, <strong>delimiter_regex</strong>, <strong>inflines</strong>, <strong>typer</strong>, <strong>missingvalues</strong>, <strong>fillingvalues</strong>, <strong>verbosity</strong>, and various CSV module parameters like <strong>escapechar</strong>, <strong>quoting</strong>, <strong>quotechar=</strong>, <strong>doublequote</strong>, <strong>skipinitialspace</strong>.</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>R</strong> :  numpy record array</p>
<blockquote>
<div>record array constructed from data in the SV file</div></blockquote>
<p><strong>metadata</strong> :  dictionary</p>
<blockquote>
<div>Metadata read and constructed during process of reading 
file.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.loadSVcols" title="tabular.io.loadSVcols"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadSVcols()</span></tt></a>, <a class="reference internal" href="#tabular.io.saveSV" title="tabular.io.saveSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveSV()</span></tt></a>, 
<tt class="xref py py-func docutils literal"><span class="pre">tabular.io.DEFAULT_TYPEINFERER()</span></tt></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.loadSVcols">
<tt class="descclassname">tabular.io.</tt><tt class="descname">loadSVcols</tt><big>(</big><em>fname</em>, <em>usecols=None</em>, <em>excludecols=None</em>, <em>valuefixer=None</em>, <em>colfixer=None</em>, <em>missingvalues=None</em>, <em>fillingvalues=None</em>, <em>typeinferer=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#tabular.io.loadSVcols" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a separated value text file to a list of column arrays.</p>
<p>Basically, this function calls loadSVrecs, and transposes the string-valued row data returned by that function into a Python list of numpy arrays corresponding to columns, each a uniform Python type (int, float, str).  Also uses and returns metadata including column names, formats, coloring, &amp;c. if these items  are determined during the loading process.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string or file object</p>
<blockquote>
<div>Path (or file object) corresponding to a separated variable
(CSV) text file.</div></blockquote>
<p><strong>usecols</strong> :  sequence of non-negative integers or strings, optional</p>
<blockquote>
<div>Only the columns in <em>usecols</em> are loaded and processed.   Columns can be described by number, with 0 being the first column; or if name metadata is present, then by name ; or, if color group information is present in the file, then by color group name.   (Default is None, e.g. all columns are loaded.</div></blockquote>
<p><strong>excludecols</strong> :  sequence of non-negative integers or strings, optional</p>
<blockquote>
<div>Converse of <strong>usecols</strong>, e.g. all columns EXCEPT those listed will be loaded.</div></blockquote>
<p><strong>valuefixer</strong>  :  callable, or list or dictionary of callables, optional</p>
<blockquote>
<div>These callable(s) are applied to every value in each field.   The application is done after line strings are loaded and split into fields, but before any typing or missing-value imputation is done.  The purpose of the <strong>valuefixer</strong> is to prepare column values for typing and imputation.   The valuefixer callable can return a string or a python object.   If <cite>valuefixer</cite> is a single callable, then that same callable is applied to values in all column; if it is a dictionary, then the keys can be either numbers or names and the value for the key will be applied to values in the corresponding column with that name or number; if it is a list, then the list elements must be in 1-1 correponsdence with the loaded columns, and are applied to each respectively.</div></blockquote>
<p><strong>colfixer</strong> : callable, or list or dictionary of callables, optional</p>
<blockquote>
<div>Same as <strong>valuefixer</strong>,  but instead of being applied to individual values, are applied to whole columns (and must return columns or numpy arrays of identical length).    Like valuefixer, colfixer callable(s) are applied before typing and missing-value imputation.</div></blockquote>
<p><strong>missingvalues</strong> : string, callable returning string, or list or dictionary of strings or string-valued callable</p>
<blockquote>
<div>String value(s) to consider as &#8220;missing data&#8221; and to be replaced before typing is done.   If specified as a callable, the callable will be applied to the column(s) to determine missing value.   If specified as a dictionary, keys are expected to be numbers of names of columns, and values are individual missing values for those columns (like <strong>valuefixer</strong> inferface).</div></blockquote>
<p><strong>fillingvalues</strong> : string, pair of strings, callable returning string, or list or dictionary of strings or string-valued callable</p>
<blockquote>
<div>Values to be used to replace missing data before typing is done.   If specified as a  single non-callable, non-tuple value, this value is used to replace all missing data.  If specified as a callable, the callable is applied to the column and returns the fill value (e.g. to allow the value to depend on the column type).    If specified as a pair of values, the first value acts as the missing value and the second as the value to replace with.   If a dictionary or list of values, then values are applied to corresponding columns.</div></blockquote>
<p>NOTE:  all the <strong>missingvalues</strong> and <strong>fillingvalues</strong> functionalities can be replicated (and generalized) using the <strong>valuefixer</strong> or <strong>colfixer</strong> parameters, by specifying function(s) which identify and replace missing values.   While more limited, using <strong>missingvalues</strong> and <strong>fillingvalues</strong>  interface is easier and gives better performance.</p>
<p><strong>typer</strong>  :   callable taking python list of strings (or other values) and returning 1-dnumpy array ; or list dictionary of such callables</p>
<blockquote>
<div>Function used to infer type and convert string lists into typed numpy arrays, if no format information has been provided.   When applied at all, this function is applied after string have been loaded and split into fields.   This function is expected to impute missing values as well, and will override any setting of <strong>missingvalues</strong> or <strong>fillingvalues</strong>.    If a callable is passed,  it is used as typer for all columns, while if a dictionary (or list) of callables is passed, they&#8217;re used on corresponding columns.    If needed (e.g. because formatting information hasn&#8217;t been supplied) but <strong>typer</strong> isn&#8217;t specified (at least, for a given column), the constructor defaults to using the <cite>utils.DEFAULT_TYPEINFERER</cite> function.</div></blockquote>
<p><strong>kwargs</strong>: keyword argument dictionary of variable length</p>
<blockquote>
<div>Contains various parameters to be passed on to loadSVrecs, including <strong>skiprows</strong>, <strong>comments</strong>, <strong>delimiter</strong>, <strong>lineterminator</strong>, <strong>uselines</strong>,  <strong>metametadata</strong>, <strong>namesinheader</strong>,**headerlines**, <strong>linefixer</strong>,  <strong>delimiter_regex</strong>, <strong>inflines</strong>, <strong>verbosity</strong>, and various CSV module parameters like <strong>escapechar</strong>, <strong>quoting</strong>, <strong>quotechar=</strong>, <strong>doublequote</strong>, <strong>skipinitialspace</strong>.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>columns</strong> :  list of numpy arrays</p>
<blockquote>
<div>List of arrays corresponding to columns of data.</div></blockquote>
<p><strong>metadata</strong> :  dictionary</p>
<blockquote>
<div>Metadata read and constructed during process of reading 
file.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.loadSV" title="tabular.io.loadSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadSV()</span></tt></a>, <a class="reference internal" href="#tabular.io.saveSV" title="tabular.io.saveSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveSV()</span></tt></a>, 
<tt class="xref py py-func docutils literal"><span class="pre">tabular.io.DEFAULT_TYPEINFERER()</span></tt></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.loadSVrecs">
<tt class="descclassname">tabular.io.</tt><tt class="descname">loadSVrecs</tt><big>(</big><em>fname</em>, <em>uselines=None</em>, <em>skiprows=0</em>, <em>linefixer=None</em>, <em>delimiter_regex=None</em>, <em>verbosity=5</em>, <em>**metadata</em><big>)</big><a class="headerlink" href="#tabular.io.loadSVrecs" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a separated value text file to a list of lists of strings of records.</p>
<p>Takes a tabular text file with a specified delimeter and end-of-line 
character, and return data as a list of lists of strings corresponding to records (rows).  Also uses and returns metadata (including column names, formats, coloring, &amp;c.) if these items are determined during the loading process.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><blockquote>
<div><p><strong>fname</strong> :  string or file object</p>
<blockquote>
<div><dl class="docutils">
<dt>Path (or file object) corresponding to a separated variable</dt>
<dd>(CSV) text file.</dd>
</dl>
</div></blockquote>
<p><strong>delimiter</strong> : single-character string</p>
<blockquote>
<div>When reading text file, character to use as delimiter to split fields.  If not specified, the delimiter is determined first by looking for special-format metadata specifying the delimiter, and then if no specification is found, attempts are made to infer delimiter from file contents.   (See <strong>inflines</strong> parameter below.)</div></blockquote>
<p><strong>delimiter_regex</strong> :  regular expression (compiled or in string format)</p>
<blockquote>
<div>Regular expression to use to recognize delimiters, in place of a single character.   (For instance, to have whitespace delimiting, using delimiter_regex = &#8216;[s*]+&#8217; )</div></blockquote>
<p><strong>lineterminator</strong> : single-character string</p>
<blockquote>
<div>Line terminator to use when reading in using SVfile</div></blockquote>
<dl class="docutils">
<dt><strong>skipinitialspace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>If true, strips whitespace following the delimiter from field.</dd>
</dl>
</div></blockquote>
<p>The <strong>delimiter</strong>, <strong>linterminator</strong> and <strong>skipinitialspace</strong> 
parameters are passed on as parameters to the python CSV module, 
which is used for reading in delimited text files.   Additional 
parameters from that interface that are replicated in this constructor include <strong>quotechar</strong>, <strong>escapechar</strong>, <strong>quoting</strong>, <strong>doublequote</strong> and <strong>dialect</strong> (see CSV module documentation for more information.)</p>
<blockquote>
<div><p><strong>skiprows</strong> :  non-negative integer, optional</p>
<blockquote>
<div>When reading from a text file, the first <cite>skiprows</cite> lines are ignored.  Default is 0, e.g no rows are skipped.</div></blockquote>
<p><strong>uselines</strong> : pair of non-negative integer, optional</p>
<blockquote>
<div>When reading from a text file, range of lines of data to load.  (In constrast to <strong>skiprows</strong>, which specifies file rows to ignore before looking for header information, <strong>uselines</strong> specifies which data (non-header) lines to use, after header has been striped and processed.)   See <strong>headerlines</strong> below.</div></blockquote>
<p><strong>comments</strong> : single-character string, optional</p>
<blockquote>
<div>When reading from a text file, character used to distinguish header lines.  If specified, any lines beginning with this character at the top of the file are assumed to contain header information and not row data.</div></blockquote>
<p><strong>headerlines</strong> : integer, optional</p>
<blockquote>
<div>When reading from a text file, the number of lines at the top of the file (after the first  <cite>skiprows</cite> lines) corresponding to the header of the file, where metadata can be found.   Lines after headerlines are assumed to contain row contents.   If not specified, value is determined first by looking for special metametadata  in first line of file (see Tabular reference documentation for more information about this), and if no such metadata is found, is inferred by looking at file contents.</div></blockquote>
<p><strong>namesinheader</strong> : Boolean, optional</p>
<blockquote>
<div>When reading from a text file, if <cite>namesinheader == True</cite>, then assume the column names are in the last header line (unless overridden by existing metadata or metametadata directive).    Default is True.</div></blockquote>
<p><strong>linefixer</strong> : callable, optional</p>
<blockquote>
<div>This callable is applied to every line in the file.  If specified, the called is applied directly to the strings in the file, after they&#8217;re split in lines but before they&#8217;re split into fields.   The purpose is to make lines with errors or mistakes amenable to delimiter inference and field-splitting.</div></blockquote>
<p><strong>inflines</strong> :  integer, optional</p>
<blockquote>
<div>Number of lines of file to use as sample data when inferring delimiter and header.</div></blockquote>
<p><strong>metametadata</strong> :  dictionary of integers or pairs of integers</p>
<blockquote>
<div>Specifies supplementary metametadata information for use 
with SVfile loading.  See Tabular reference documentation for more information</div></blockquote>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>records</strong> :  list of lists of strings</p>
<blockquote>
<div>List of lists corresponding to records (rows) of data.</div></blockquote>
<p><strong>metadata</strong> :  dictionary</p>
<blockquote>
<div>Metadata read and constructed during process of reading 
file.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.loadSV" title="tabular.io.loadSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadSV()</span></tt></a>, <a class="reference internal" href="#tabular.io.saveSV" title="tabular.io.saveSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveSV()</span></tt></a>, 
<tt class="xref py py-func docutils literal"><span class="pre">tabular.io.DEFAULT_TYPEINFERER()</span></tt></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.saveSV">
<tt class="descclassname">tabular.io.</tt><tt class="descname">saveSV</tt><big>(</big><em>fname</em>, <em>X</em>, <em>comments=None</em>, <em>metadata=None</em>, <em>printmetadict=None</em>, <em>dialect=None</em>, <em>delimiter=None</em>, <em>doublequote=True</em>, <em>lineterminator='\n'</em>, <em>escapechar=None</em>, <em>quoting=0</em>, <em>quotechar='&quot;'</em>, <em>skipinitialspace=False</em>, <em>stringifier=None</em>, <em>verbosity=5</em><big>)</big><a class="headerlink" href="#tabular.io.saveSV" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a tabarray to a separated-variable (CSV) file.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path to a separated variable (CSV) text file.</div></blockquote>
<p><strong>X</strong> :  tabarray</p>
<blockquote>
<div>The actual data in a <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a>.</div></blockquote>
<p><strong>comments</strong> :  string, optional</p>
<blockquote>
<div>The character to be used to denote the start of a header (non-data) line, e.g. &#8216;#&#8217;.  If not specified, it is determined according to the following rule:  &#8216;#&#8217; if <cite>metadata</cite> argument is set, otherwise &#8216;&#8217;.</div></blockquote>
<p><strong>delimiter</strong> :  string, optional</p>
<blockquote>
<div>The character to beused to separate values in each line of text, e.g. &#8216;,&#8217;.  If not specified, by default, this is inferred from the file extension: if the file ends in <cite>.csv</cite>, the delimiter is &#8216;,&#8217;, otherwise it is &#8216;t.&#8217;</div></blockquote>
<p><strong>linebreak</strong> :  string, optional</p>
<blockquote>
<div>The string separating lines of text.  By default, this is assumed to be &#8216;n&#8217;, and can also be set to be &#8216;r&#8217; or &#8216;rn&#8217;.</div></blockquote>
<p><strong>metadata</strong> :  list of strings or Boolean, optional</p>
<blockquote>
<div><p>Allowed values are True, False, or any sublists of the list 
<cite>[&#8216;names&#8217;, &#8216;formats&#8217;, &#8216;types&#8217;, &#8216;coloring&#8217;, &#8216;dialect&#8217;]</cite>.  These keys indicate what special metadata is printed in the header.</p>
<ul class="simple">
<li>If a sublist of [&#8216;names&#8217;, &#8216;formats&#8217;, &#8216;types&#8217;, &#8216;coloring&#8217;, &#8216;dialect&#8217;], then the indicated types of metadata are written out.</li>
<li>If <cite>True</cite>, this is the same as 
<cite>metadata = [&#8216;coloring&#8217;, &#8216;types&#8217;, &#8216;names&#8217;,&#8217;dialect&#8217;]</cite>, e.g. as many types of metadata as this algorithm currently knows how to write out.</li>
<li>If &#8216;False&#8217;, no metadata is printed at all, e.g. just the data.</li>
<li>If <cite>metadata</cite> is not specified, the default is   <cite>[&#8216;names&#8217;]</cite>, &#8211; that is, just column names are written out.</li>
</ul>
</div></blockquote>
<p><strong>printmetadict</strong> :  Boolean, optional</p>
<blockquote>
<div><p>Whether or not to print a string representation of the
<cite>metadatadict</cite> in the first line of the header.</p>
<p>If <cite>printmetadict</cite> is not specified, then:</p>
<ul class="simple">
<li>If <cite>metadata</cite> is specified and is not <cite>False</cite>, then
<cite>printmetadata</cite> defaults to <cite>True</cite>.</li>
<li>Else if <cite>metadata</cite> is <cite>False</cite>, then <cite>printmetadata</cite>
defaults to <cite>False</cite>.</li>
<li>Else <cite>metadata</cite> is not specified, and <cite>printmetadata</cite>
defaults to <cite>False</cite>.</li>
</ul>
<p>See the <a class="reference internal" href="#tabular.io.loadSV" title="tabular.io.loadSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadSV()</span></tt></a> for more information
about <cite>metadatadict</cite>.</p>
</div></blockquote>
<p><strong>stringifier</strong> : callable taking 1-d numpy array and returning python list of strings of same length, or dictionary or tuple of such callables.</p>
<blockquote>
<div>If specified, the callable will be applied to each column, and the resulting list of strings will be written to the file.   If specified as a list or dictionary of callables, the functions will be applied to correponding columns.    The default used if <strong>stringifier</strong> is not specified, is  <cite>tb.utils.DEFAULT_STRINGIFIER</cite>, which merely passes through string-type columns, and converts numerical-type columns directly to correponding strings with NaNs replaced with blank values.    The main purpose of specifying a non-default value is to encode numerical values in various string encodings that might be used required for other applications like databases.</div></blockquote>
<p>NOTE:   In certain special circumstances (e.g. when the lineterminator or delimiter character appears in a field of the data), the python CSV writer is used to write out data.  To allow for control of the operation of the writer in these circumstances, the following other parameters replicating the interface of the CSV module are also valid, and values will be passed through:  <strong>doublequote</strong>, <strong>escapechar</strong>, <strong>quoting</strong>, <strong>quotechar</strong>, and <strong>skipinitialspace</strong>.   (See python CSV module documentation for more information.)</p>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.loadSV" title="tabular.io.loadSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadSV()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.loadbinary">
<tt class="descclassname">tabular.io.</tt><tt class="descname">loadbinary</tt><big>(</big><em>fname</em><big>)</big><a class="headerlink" href="#tabular.io.loadbinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a numpy binary file or archive created by tabular.io.savebinary.</p>
<p>Load a numpy binary file (<tt class="docutils literal"><span class="pre">.npy</span></tt>) or archive (<tt class="docutils literal"><span class="pre">.npz</span></tt>) created by 
<a class="reference internal" href="#tabular.io.savebinary" title="tabular.io.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savebinary()</span></tt></a>.</p>
<p>The data and associated data type (e.g. <cite>dtype</cite>, including if given, column 
names) are loaded and reconstituted.</p>
<p>If <cite>fname</cite> is a numpy archive, it may contain additional data giving 
hierarchical column-oriented structure (e.g. <cite>coloring</cite>).  See 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more information about  
coloring.</p>
<p>The <tt class="docutils literal"><span class="pre">.npz</span></tt> file is a zipped archive created using <tt class="xref py py-func docutils literal"><span class="pre">numpy.savez()</span></tt> and 
containing one or more <tt class="docutils literal"><span class="pre">.npy</span></tt> files, which are NumPy binary files created 
by <tt class="xref py py-func docutils literal"><span class="pre">numpy.save()</span></tt>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string or file-like object</p>
<blockquote>
<div><p>File name or open numpy binary file (<tt class="docutils literal"><span class="pre">.npy</span></tt>) or archive 
(<tt class="docutils literal"><span class="pre">.npz</span></tt>) created by <a class="reference internal" href="#tabular.io.savebinary" title="tabular.io.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savebinary()</span></tt></a>.</p>
<ul>
<li><p class="first">When <cite>fname</cite> is a <tt class="docutils literal"><span class="pre">.npy</span></tt> binary file, it is 
reconstituted as a flat ndarray of data, with 
structured dtype.</p>
</li>
<li><p class="first">When <cite>fname</cite> is a <tt class="docutils literal"><span class="pre">.npz</span></tt> archive, it contains at 
least one <tt class="docutils literal"><span class="pre">.npy</span></tt> binary file and optionally another:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">data.npy</span></tt> must be in the archive, and is
reconstituted as <cite>X</cite>, a flat ndarray of data, 
with structured dtype, <cite>dtype</cite>.</li>
<li><tt class="docutils literal"><span class="pre">coloring.npy</span></tt>, if present is reconstitued as
<cite>coloring</cite>, a dictionary.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>The data, where each column is named and is of a uniform 
NumPy data type.</div></blockquote>
<p><strong>dtype</strong> :  numpy dtype object</p>
<blockquote>
<div>The data type of <cite>X</cite>, e.g. <cite>X.dtype</cite>.</div></blockquote>
<p><strong>coloring</strong> :  dictionary, or None</p>
<blockquote>
<div><p>Hierarchical structure on the columns given in the header 
of the file; an attribute of tabarrays.</p>
<p>See <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more
information about coloring.</p>
</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.savebinary" title="tabular.io.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savebinary()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.load()</span></tt>, 
<tt class="xref py py-func docutils literal"><span class="pre">numpy.save()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.savez()</span></tt></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.savebinary">
<tt class="descclassname">tabular.io.</tt><tt class="descname">savebinary</tt><big>(</big><em>fname</em>, <em>X</em>, <em>savecoloring=True</em><big>)</big><a class="headerlink" href="#tabular.io.savebinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a tabarray to a numpy binary file or archive.</p>
<p>Save a tabarray to a numpy binary file (<tt class="docutils literal"><span class="pre">.npy</span></tt>) or archive
(<tt class="docutils literal"><span class="pre">.npz</span></tt>) that can be loaded by <a class="reference internal" href="#tabular.io.savebinary" title="tabular.io.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savebinary()</span></tt></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">.npz</span></tt> file is a zipped archive created using
<tt class="xref py py-func docutils literal"><span class="pre">numpy.savez()</span></tt> and containing one or more <tt class="docutils literal"><span class="pre">.npy</span></tt> files,
which are NumPy binary files created by <tt class="xref py py-func docutils literal"><span class="pre">numpy.save()</span></tt>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string or file-like object</p>
<blockquote>
<div>File name or open numpy binary file (<tt class="docutils literal"><span class="pre">.npy</span></tt>) or archive 
(<tt class="docutils literal"><span class="pre">.npz</span></tt>) created by <a class="reference internal" href="#tabular.io.savebinary" title="tabular.io.savebinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savebinary()</span></tt></a>.</div></blockquote>
<p><strong>X</strong> :  tabarray</p>
<blockquote>
<div><p>The actual data in a <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a>:</p>
<ul>
<li><p class="first">if <cite>fname</cite> is a <tt class="docutils literal"><span class="pre">.npy</span></tt> file, then this is the same 
as:</p>
<div class="highlight-rest"><div class="highlight"><pre>numpy.savez(fname, data=X)
</pre></div>
</div>
</li>
<li><p class="first">otherwise, if <cite>fname</cite> is a <tt class="docutils literal"><span class="pre">.npz</span></tt> file, then <cite>X</cite> is   
zipped inside of <cite>fname</cite> as <tt class="docutils literal"><span class="pre">data.npy</span></tt></p>
</li>
</ul>
</div></blockquote>
<p><strong>savecoloring</strong> : boolean</p>
<blockquote>
<div><p>Whether or not to save the <cite>coloring</cite> attribute of <cite>X</cite>.
If <cite>savecoloring</cite> is <cite>True</cite>, then <cite>fname</cite> must be a
<tt class="docutils literal"><span class="pre">.npz</span></tt> archive and <cite>X.coloring</cite> is zipped inside of
<cite>fname</cite> as <tt class="docutils literal"><span class="pre">coloring.npy</span></tt></p>
<p>See <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more
information about coloring.</p>
</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.loadbinary" title="tabular.io.loadbinary"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadbinary()</span></tt></a>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.load()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.save()</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">numpy.savez()</span></tt></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.loadHSV">
<tt class="descclassname">tabular.io.</tt><tt class="descname">loadHSV</tt><big>(</big><em>path</em>, <em>X=None</em>, <em>names=None</em>, <em>rootpath=None</em>, <em>rootheader=None</em>, <em>coloring=None</em>, <em>toload=None</em>, <em>Nrecs=None</em><big>)</big><a class="headerlink" href="#tabular.io.loadHSV" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a list of columns (numpy arrays) from a HSV directory.</p>
<p>Load a list of numpy arrays, corresponding to columns of data, from a 
hierarchical separated variable (HSV) directory (<tt class="docutils literal"><span class="pre">.hsv</span></tt>) created by 
<a class="reference internal" href="#tabular.io.saveHSV" title="tabular.io.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveHSV()</span></tt></a>.</p>
<p>This function is used by the tabarray constructor
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> when passed the <cite>HSV</cite> argument.</p>
<p>Each column of data inside of the <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory is a separate 
comma-separated variable text file (<tt class="docutils literal"><span class="pre">.csv</span></tt>), whose name includes the 
column name and data type of the column (e.g. <tt class="docutils literal"><span class="pre">name.int.csv</span></tt>, 
<tt class="docutils literal"><span class="pre">name.float.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.str.csv</span></tt>).  An ordered list of columns, if 
provided, is stored in a separate file, <tt class="docutils literal"><span class="pre">header.txt</span></tt>.</p>
<p>A <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory can contain <tt class="docutils literal"><span class="pre">.hsv</span></tt> subdirectories.  This allows for 
hierarchical structure on the columns, which is mapped to a coloring 
dictionary. For example, a subdirectory named <tt class="docutils literal"><span class="pre">color.hsv</span></tt> contains 
<tt class="docutils literal"><span class="pre">.csv</span></tt> files corrseponding to columns of data grouped by that color.  
Note that when the file structure is not flat, <a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> 
calls itself recursively.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>path</strong> :  string</p>
<blockquote>
<div>Path to a <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory or individual <tt class="docutils literal"><span class="pre">.csv</span></tt> text 
files, corresponding to individual columns of data inside 
of a <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory.</div></blockquote>
<p><strong>X</strong> :  list of numpy arrays, optional</p>
<blockquote>
<div>List of numpy arrays, corresponding to columns of data.  
Typically, the <cite>X</cite> argument is only passed when
<a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> calls itself recursively, in 
which case each element is a column of data that has 
already been loaded.</div></blockquote>
<p><strong>names</strong> :  list of strings, optional</p>
<blockquote>
<div>List of strings giving column names. Typically, the <cite>names</cite> 
is only passed when <a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> calls itself 
recursively, in which case each element gives the name of 
the corresponding array in <cite>X</cite>.</div></blockquote>
<p><strong>rootpath</strong> :  string, optional</p>
<blockquote>
<div>Path to the top-level file (directory), i.e. the value of
<cite>path</cite> the first time <a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> is called.
Typically, the <cite>rootpath</cite> argument is only passed when
<a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> calls itself recursively.</div></blockquote>
<p><strong>rootheader</strong> :  list of strings, optional</p>
<blockquote>
<div>Ordered list of column names. Typically, the <cite>rootheader</cite>
argument is only passed when <a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a>
calls itself recursively, in which case <cite>rootheader</cite> is
filled by parsing the (optional) <tt class="docutils literal"><span class="pre">header.txt</span></tt> file in
<cite>rootpath</cite>, if it exists.</div></blockquote>
<p><strong>coloring</strong> :  dictionary, optional</p>
<blockquote>
<div><p>Hierarchical structure on the columns given in the header
of the file; an attribute of tabarrays.</p>
<p>Typically, the <cite>coloring</cite> argument is only passed when
<a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> calls itself recursively, in 
which case it contains coloring, i.e. hierarchical 
structure information, on the arrays in <cite>X</cite>.</p>
<p>See <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more
information about coloring.</p>
<p><strong>See Also:</strong> <tt class="xref py py-func docutils literal"><span class="pre">tabular.io.infercoloring()</span></tt></p>
</div></blockquote>
<p><strong>toload</strong> :  list of strings, optional</p>
<blockquote>
<div><p>List of strings corresponding to a subset of column names
and/or color names; only these columns are loaded.</p>
<p><strong>See Also:</strong>  <tt class="xref py py-func docutils literal"><span class="pre">tabular.io.thresholdcoloring()</span></tt></p>
</div></blockquote>
<p><strong>Nrecs</strong> :  non-negative integer</p>
<blockquote>
<div>The number of records in <cite>X</cite>. Typically, the <cite>Nrecs</cite> 
argument is only passed when <a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a>
calls itself recursively, in which case it is set by the 
first <tt class="docutils literal"><span class="pre">.csv</span></tt> file loaded.  Subsequent columns must have 
the same number of records; when any subsequent column
disagrees, it is not loaded and a warning is issued.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>X</strong> :  list of numpy arrays</p>
<blockquote>
<div>List of numpy arrays, corresponding to columns of data, 
each loaded from one <tt class="docutils literal"><span class="pre">.csv</span></tt> file.</div></blockquote>
<p><strong>names</strong> :  list of strings</p>
<blockquote>
<div>List of strings giving column names.</div></blockquote>
<p><strong>coloring</strong> :  dictionary</p>
<blockquote>
<div><p>Hierarchical structure on the columns given in the header 
of the file; an attribute of tabarrays.</p>
<p>See <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more
information about coloring.</p>
</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a>, 
<a class="reference internal" href="#tabular.io.saveHSV" title="tabular.io.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveHSV()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.saveHSV">
<tt class="descclassname">tabular.io.</tt><tt class="descname">saveHSV</tt><big>(</big><em>fname</em>, <em>X</em>, <em>printheaderfile=True</em><big>)</big><a class="headerlink" href="#tabular.io.saveHSV" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a tabarray to a hierarchical separated variable (HSV) directory.</p>
<p>The tabarray can later be loaded back from the <tt class="docutils literal"><span class="pre">.hsv</span></tt> by passing <cite>fname</cite> 
to the <cite>HSV</cite> argument of the tabarray constructor 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a>.</p>
<p>This function is used by the tabarray method
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.saveHSV" title="tabular.tab.tabarray.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.saveHSV()</span></tt></a>.</p>
<p>Each column of data in the tabarray is stored inside of the <tt class="docutils literal"><span class="pre">.hsv</span></tt> 
directory to a separate comma-separated variable text file (<tt class="docutils literal"><span class="pre">.csv</span></tt>), 
whose name includes the column name and data type of the column (e.g. 
<tt class="docutils literal"><span class="pre">name.int.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.float.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.str.csv</span></tt>).</p>
<p>Coloring information, i.e.  hierarchical structure on the columns, is 
stored in the file directory structure of the <tt class="docutils literal"><span class="pre">.hsv</span></tt>, where <tt class="docutils literal"><span class="pre">.hsv</span></tt> 
subdirectories correspond to colors in the coloring dictionary:</p>
<div class="highlight-rest"><div class="highlight"><pre>X.coloring.keys()
</pre></div>
</div>
<p>e.g. a subdirectory named <tt class="docutils literal"><span class="pre">color.hsv</span></tt> contains <tt class="docutils literal"><span class="pre">.csv</span></tt> files
corrseponding to columns of data grouped by that color:</p>
<div class="highlight-rest"><div class="highlight"><pre>X[&#39;color&#39;]
</pre></div>
</div>
<p>See <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more information about 
coloring.</p>
<p>Note that when the file structure is not flat,
<a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> calls itself recursively.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path to a <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory or individual <tt class="docutils literal"><span class="pre">.csv</span></tt> text 
files, corresponding to individual columns of data inside 
of a <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory.</div></blockquote>
<p><strong>X</strong> :  tabarray</p>
<blockquote>
<div>The actual data in a <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a>.</div></blockquote>
<p><strong>printheaderfile</strong> : boolean, optional</p>
<blockquote>
<div><p>Whether or not to print an ordered list of columns names in 
an additional file <tt class="docutils literal"><span class="pre">header.txt</span></tt> in all <tt class="docutils literal"><span class="pre">.hsv</span></tt> 
directories. The order is given by:</p>
<div class="highlight-rest"><div class="highlight"><pre>X.dtype.names
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">header.txt</span></tt> file is used by 
<a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a> to load the columns of data in 
the proper order, but is not required.</p>
</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a>, <a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a>, <a class="reference internal" href="#tabular.io.savecolumns" title="tabular.io.savecolumns"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savecolumns()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.savecolumns">
<tt class="descclassname">tabular.io.</tt><tt class="descname">savecolumns</tt><big>(</big><em>fname</em>, <em>X</em><big>)</big><a class="headerlink" href="#tabular.io.savecolumns" title="Permalink to this definition">¶</a></dt>
<dd><p>Save columns of a tabarray to an existing HSV directory.</p>
<p>Save columns of tabarray <cite>X</cite> to an existing HSV directory <cite>fname</cite> (e.g. a 
<tt class="docutils literal"><span class="pre">.hsv</span></tt> directory created by <a class="reference internal" href="#tabular.io.saveHSV" title="tabular.io.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveHSV()</span></tt></a>).</p>
<p>Each column of data in the tabarray is stored inside of the <tt class="docutils literal"><span class="pre">.hsv</span></tt> 
directory to a separate comma-separated variable text file (<tt class="docutils literal"><span class="pre">.csv</span></tt>), 
whose name includes the column name and data type of the column (e.g. 
<tt class="docutils literal"><span class="pre">name.int.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.float.csv</span></tt>, <tt class="docutils literal"><span class="pre">name.str.csv</span></tt>).</p>
<p>Coloring is lost.</p>
<p>This function is used by the tabarray method
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.savecolumns" title="tabular.tab.tabarray.savecolumns"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.savecolumns()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path to a hierarchical separated variable (HSV) directory
(<tt class="docutils literal"><span class="pre">.hsv</span></tt>).</div></blockquote>
<p><strong>X</strong> :  tabarray</p>
<blockquote>
<div>The actual data in a <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a>.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.saveHSV" title="tabular.io.saveHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.saveHSV()</span></tt></a>, <a class="reference internal" href="#tabular.io.loadHSVlist" title="tabular.io.loadHSVlist"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSVlist()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.loadHSVlist">
<tt class="descclassname">tabular.io.</tt><tt class="descname">loadHSVlist</tt><big>(</big><em>flist</em><big>)</big><a class="headerlink" href="#tabular.io.loadHSVlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Load tabarrays from a list of hierarchical separated variable directories.</p>
<p>Loads tabarrays from a list of  hierarchical separated variable (HSV) 
paths, assuming they have disjoint columns and identical numbers of rows;  
then stacks them horizontally, e.g. adding columns side-by-side, aligning 
the rows.</p>
<p>Colorings can be lost.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>flist</strong> :  list of strings</p>
<blockquote>
<div>List of paths to hierarchical separated variable (HSV)
directories (<tt class="docutils literal"><span class="pre">.hsv</span></tt>) and/or individual <tt class="docutils literal"><span class="pre">.csv</span></tt> text 
files, corresponding to individual columns of data inside 
of a <tt class="docutils literal"><span class="pre">.hsv</span></tt> directory.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.loadHSV" title="tabular.io.loadHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.loadHSV()</span></tt></a>, <a class="reference internal" href="#tabular.io.savecolumns" title="tabular.io.savecolumns"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.savecolumns()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.appendHSV">
<tt class="descclassname">tabular.io.</tt><tt class="descname">appendHSV</tt><big>(</big><em>fname</em>, <em>RecObj</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#tabular.io.appendHSV" title="Permalink to this definition">¶</a></dt>
<dd><p>Append records to an on-disk tabarray, e.g. HSV directory.</p>
<p>Function for appending records to an on-disk tabarray, used when one wants 
to write a large tabarray that is not going to be kept in memory at once.</p>
<p>If the tabarray is not there already, the function intializes the tabarray 
using the tabarray <cite>__new__</cite> method, and saves it out.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path of hierarchical separated variable (<tt class="docutils literal"><span class="pre">.hsv</span></tt>) file to
which to append records in <cite>RecObj</cite>.</div></blockquote>
<p><strong>RecObj</strong> :  array or dictionary</p>
<ul>
<li><p class="first">Either an array with complex dtype (e.g. tabarray, recarray or 
ndarray), or</p>
</li>
<li><p class="first">a dictionary (ndarray with structured dtype, e.g. a tabarray) 
where</p>
<blockquote>
<div><ul class="simple">
<li>keys are names of columns to append to, and</li>
<li>the value on a column is a list of values to be 
appended to that column.</li>
</ul>
</div></blockquote>
</li>
</ul>
<p><strong>order</strong> :  list of strings</p>
<blockquote>
<div>List of column names specifying order in which the columns 
should be written; only used when the HSV does not exist 
and the header specifying order needs to be written.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.appendcolumns" title="tabular.io.appendcolumns"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.appendcolumns()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.appendcolumns">
<tt class="descclassname">tabular.io.</tt><tt class="descname">appendcolumns</tt><big>(</big><em>fname</em>, <em>RecObj</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#tabular.io.appendcolumns" title="Permalink to this definition">¶</a></dt>
<dd><p>Append records to a flat on-disk tabarray, e.g. HSV without subdirectories.</p>
<p>Function for appending columnns a flat on-disk tabarray, (e.g. no colors), 
used when one wants to write a large tabarray that is not going to be kept 
in memory at once.</p>
<p>If the tabarray is not there already, the function intializes the tabarray 
using the tabarray __new__ method, and saves it out.</p>
<p>See <a class="reference internal" href="#tabular.io.appendHSV" title="tabular.io.appendHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.appendHSV()</span></tt></a> for a more general method.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>Path of hierarchical separated variable (.hsv) file of 
which to append.</div></blockquote>
<p><strong>RecObj</strong> :  array or dictionary</p>
<ul>
<li><p class="first">Either an array with complex dtype (e.g. tabarray, recarray or 
ndarray), or</p>
</li>
<li><p class="first">a dictionary (ndarray with structured dtype, e.g. a tabarray) 
where</p>
<blockquote>
<div><ul class="simple">
<li>keys are names of columns to append to, and</li>
<li>the value on a column is a list of values to be 
appended to that column.</li>
</ul>
</div></blockquote>
</li>
</ul>
<p><strong>order</strong> :  list of strings</p>
<blockquote>
<div>List of column names specifying order in which the columns 
should be written; only used when the HSV does not exist 
and the header specifying order needs to be written.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.io.appendHSV" title="tabular.io.appendHSV"><tt class="xref py py-func docutils literal"><span class="pre">tabular.io.appendHSV()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.inferdelimiterfromname">
<tt class="descclassname">tabular.io.</tt><tt class="descname">inferdelimiterfromname</tt><big>(</big><em>fname</em><big>)</big><a class="headerlink" href="#tabular.io.inferdelimiterfromname" title="Permalink to this definition">¶</a></dt>
<dd><p>Infer delimiter from file extension.</p>
<ul class="simple">
<li>If <em>fname</em> ends with &#8216;.tsv&#8217;, return &#8216;t&#8217;.</li>
<li>If <em>fname</em> ends with &#8216;.csv&#8217;, return &#8216;,&#8217;.</li>
<li>Otherwise, return &#8216;t&#8217;.</li>
</ul>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> :  string</p>
<blockquote>
<div>File path assumed to be for a separated-variable file.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>delimiter</strong> :  string</p>
<blockquote>
<div>String in [&#8216;t&#8217;, &#8216;,&#8217;], the inferred delimiter.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.inferdialect">
<tt class="descclassname">tabular.io.</tt><tt class="descname">inferdialect</tt><big>(</big><em>fname=None</em>, <em>datalines=None</em>, <em>delimiter_regex=None</em>, <em>verbosity=5</em><big>)</big><a class="headerlink" href="#tabular.io.inferdialect" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to convert infer dialect from csv file lines.</p>
<p>Essentially a small extension of the &#8220;sniff&#8221; function from 
Python CSV module.   csv.Sniffer().sniff attempts to infer 
the delimiter from a putative delimited text file by analyzing 
character frequencies.   This function adds additional analysis 
in which guesses are checked again the number of entries in
each line that would result from spliiting relative to that guess. 
If no plausable guess if found, delimiter is inferred from file 
name  (&#8216;csv&#8217; yields &#8216;,&#8217;, everything else yields &#8216;   &#8216;.)</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>fname</strong> : pathstring</p>
<blockquote>
<div>name of file</div></blockquote>
<p><strong>datalines</strong> : list of strings</p>
<blockquote>
<div>list of lines in the data file</div></blockquote>
<p><strong>lineterminator</strong> : single-character string</p>
<blockquote>
<div>lineterminator to join split/join line strings</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div>csv.Dialect obejct</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.processmetadata">
<tt class="descclassname">tabular.io.</tt><tt class="descname">processmetadata</tt><big>(</big><em>metadata</em>, <em>items=None</em>, <em>comments=None</em>, <em>delimiter_regex=None</em>, <em>ncols=None</em>, <em>verbosity=5</em><big>)</big><a class="headerlink" href="#tabular.io.processmetadata" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Process Metadata from stored (or &#8220;packed&#8221;) state to functional state.</p>
<p>Metadata can come be read from a file &#8220;packed&#8221; in various ways, 
e.g. with a string representation of a dialect or coloring dictionary.  
This function &#8220;unpacks&#8221; the stored metadata into useable Python
objects.  It consists of a list of quasi-modular parts, one for each 
type of recognized metadata.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>metadata</strong> : dictionary</p>
<blockquote>
<div>This argument is a dictionary whose keys are strings denoting
different kinds of metadata (e.g. &#8220;names&#8221; or &#8220;formats&#8221;) and 
whose values are the metadata of that type.
The metadata dictionary is modified IN-PLACE by this function.</div></blockquote>
<p><strong>items</strong> : string or list of strings, optional</p>
<blockquote>
<div>The items arguments specifies which metadata keys are to be 
processed.  E.g. of items = &#8216;names,formats&#8217;, then the &#8220;names&#8221; 
metadata and &#8220;formats&#8221; metadata will be processed, but no 
others  Note however, that sometimes, the processing of one 
type of metadata requires that another be processed first, e.g. 
&#8220;dialect&#8221; must processed into an actual CSV.dialect object 
before &#8220;names&#8221;  is processed.   (The processed of &#8220;names&#8221; 
metadata involves splitting the names metadat string into a 
list, using the delmiter.  This delimiter is part of the dialect 
object.)   In these cases, if you call processmetadata on one 
item before its requirements are processed, nothing will happen.</div></blockquote>
<p><strong>comments</strong> : single-character string, optional</p>
<blockquote>
<div>The comments character is used to process many pieces of 
metadata, e.g. it is striped of the left side of names and formats strings
before splitting on delimiter.</div></blockquote>
<p><strong>verbosity</strong> : integer, optional</p>
<blockquote>
<div>Determines the level of verbosity in the printout of messages
during the running of the procedure.</div></blockquote>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div>Nothing</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.inferheader">
<tt class="descclassname">tabular.io.</tt><tt class="descname">inferheader</tt><big>(</big><em>lines</em>, <em>comments=None</em>, <em>metadata=None</em>, <em>verbosity=5</em><big>)</big><a class="headerlink" href="#tabular.io.inferheader" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers header from a CSV or other tab-delimited file.</p>
<p>This is essentially small extension of the csv.Sniffer.has_header algorithm.
provided in the Python csv module.   First, it checks to see whether a 
metametadata dictionary is present, specifiying the lines numbers of 
metadata lines in the header, and if so, sets the header lines to include
at least those lines.  Then iookms to see if a comments character is 
present, and if so, includes those lines as well.  If either of the above 
returns a nono-zero number of headerlines, the function returns that 
number; otherwise, it uses the csv.Sniffer module, checking each line 
in succession, and stopping at the first line where the sniffer module 
finds no evidence of a header, and returning that line numner.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>lines</strong> : line of strings</p>
<blockquote>
<div>The list of lines representing lines in the file</div></blockquote>
<p><strong>comments</strong> : single-character string, optional</p>
<blockquote>
<div>Comments character  specification.</div></blockquote>
<p><strong>metadata</strong> : metadata dictionary, optional</p>
<blockquote>
<div>used to deterine a comments character and metametadata dicationary, if present,</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div>Integer, representing the number of (inferred) header lines at the top of the file</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.io.readstoredmetadata">
<tt class="descclassname">tabular.io.</tt><tt class="descname">readstoredmetadata</tt><big>(</big><em>fname</em>, <em>skiprows=0</em>, <em>linenumber=None</em>, <em>comments='#'</em>, <em>metametadata=None</em>, <em>verbosity=5</em><big>)</big><a class="headerlink" href="#tabular.io.readstoredmetadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Read metadata from a delimited text file.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<p class="logo"><a href="http://web.mit.edu/yamins/www/tabular">
  <img class="logo" src="../_static/tabularclear.png" alt="Logo"/>
</a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="tabular.tab.html"
                        title="previous chapter"><tt class="docutils literal"><span class="pre">tabular.tab</span></tt></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tabular.spreadsheet.html"
                        title="next chapter"><tt class="docutils literal docutils literal"><span class="pre">tabular.spreadsheet</span></tt></a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/tabular.io.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tabular.spreadsheet.html" title="tabular.spreadsheet"
             >next</a> |</li>
        <li class="right" >
          <a href="tabular.tab.html" title="tabular.tab"
             >previous</a> |</li>
    
        <li><a href="../index.html">tabular</a> &raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Elaine Angelino and Daniel Yamins.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>