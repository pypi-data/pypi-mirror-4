

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Module: pysyncml.change.tracker &mdash; pysyncml 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/theme_extras.js"></script>
    <link rel="top" title="pysyncml 0.1 documentation" href="../../index.html" />
    <link rel="next" title="Module: pysyncml.cli" href="../cli/base.html" />
    <link rel="prev" title="Module: pysyncml.change.merger" href="merger.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../index.html">
          <span>pysyncml 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>Module: pysyncml.change.tracker</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="merger.html">Module: pysyncml.change.merger</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../cli/base.html">Module: pysyncml.cli</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="module-pysyncml.change.tracker">
<span id="module-pysyncml-change-tracker"></span><h1>Module: pysyncml.change.tracker<a class="headerlink" href="#module-pysyncml.change.tracker" title="Permalink to this headline">¶</a></h1>
<p>The <tt class="docutils literal"><span class="pre">pysyncml.change.tracker</span></tt> is a helper package that provides
routines to generate and parse change-specs that are compliant with
pysyncml&#8217;s change tracking system.</p>
<dl class="class">
<dt id="pysyncml.change.tracker.AttributeChangeTracker">
<em class="property">class </em><tt class="descclassname">pysyncml.change.tracker.</tt><tt class="descname">AttributeChangeTracker</tt><big>(</big><em>changeSpec=None</em>, <em>*args</em>, <em>**kw</em><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#AttributeChangeTracker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.AttributeChangeTracker" title="Permalink to this definition">¶</a></dt>
<dd><p>A ChangeTracker implementation that manages changes made to attributes
that are completely independent of each other.</p>
<p>Initializes this AttributeChangeTracker with the provided
<cite>changeSpec</cite>, which is expected to be in the same format as what
would have been returned by a call to <tt class="docutils literal"><span class="pre">str()</span></tt> on this
object. The change-spec will look similar to:</p>
<div class="highlight-python"><pre>add:tel-home|mod:firstname@m68b329d...,lastname@mh4d9...|del:tel-pager@mba45...</pre>
</div>
<p>If <cite>changeSpec</cite> is not specified, this AttributeChangeTracker will
start assuming no prior changes were made to any fields.</p>
<dl class="method">
<dt id="pysyncml.change.tracker.AttributeChangeTracker.isChange">
<tt class="descname">isChange</tt><big>(</big><em>fieldname</em>, <em>changeType</em>, <em>newValue=None</em>, <em>isMd5=False</em><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#AttributeChangeTracker.isChange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.AttributeChangeTracker.isChange" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements as specified in <a class="reference internal" href="#pysyncml.change.tracker.ChangeTracker.isChange" title="pysyncml.change.tracker.ChangeTracker.isChange"><tt class="xref py py-meth docutils literal"><span class="pre">ChangeTracker.isChange()</span></tt></a> where
the <cite>changeObject</cite> is simply the fieldname that needs to be
updated with the <cite>newValue</cite>. Currently, this is always equal to
<cite>fieldname</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysyncml.change.tracker.ChangeTracker">
<em class="property">class </em><tt class="descclassname">pysyncml.change.tracker.</tt><tt class="descname">ChangeTracker</tt><big>(</big><em>changeSpec=None</em>, <em>*args</em>, <em>**kw</em><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#ChangeTracker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.ChangeTracker" title="Permalink to this definition">¶</a></dt>
<dd><p>A ChangeTracker is an abstract interface to help with generating, parsing,
and managing pysyncml change-specs. See <a class="reference internal" href="../merging.html"><em>Matching, Merging, and Conflict Resolution</em></a> for details on
change-spec handling.</p>
<dl class="method">
<dt id="pysyncml.change.tracker.ChangeTracker.append">
<tt class="descname">append</tt><big>(</big><em>fieldname</em>, <em>changeType</em>, <em>initialValue=None</em>, <em>isMd5=False</em><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#ChangeTracker.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.ChangeTracker.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a change to this ChangeTracker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fieldname</strong> &#8211; The item attribute that was changed in some way. The type of
<cite>fieldname</cite> is dependent on which subclass of ChangeTracker is
being used.</li>
<li><strong>changeType</strong> &#8211; The type of change that was applied to <cite>fieldname</cite>, which can be
one of <tt class="docutils literal"><span class="pre">pysyncml.ITEM_ADDED</span></tt>, <tt class="docutils literal"><span class="pre">pysyncml.ITEM_MODIFIED</span></tt>, or
<tt class="docutils literal"><span class="pre">pysyncml.ITEM_DELETED</span></tt>.</li>
<li><strong>initialValue</strong> &#8211; For non-ADDED change types, specifies the <em>initial</em> value of the
field, before the change was applied. Note that if the
<cite>initialValue</cite> is very large, an MD5 checksum can be provided
instead, in which case <cite>isMd5</cite> should be set to <tt class="docutils literal"><span class="pre">True</span></tt>.</li>
<li><strong>isMd5</strong> &#8211; Specifies whether <cite>initialValue</cite> is an MD5 checksum or not. For
large values of <cite>initialValue</cite> the ChangeTrackers will
automatically convert it to a checksum, but this allows the
caller to potentially do some additional optimizations.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pysyncml.change.tracker.ChangeTracker.getChangeSpec">
<tt class="descname">getChangeSpec</tt><big>(</big><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#ChangeTracker.getChangeSpec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.ChangeTracker.getChangeSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string-representation of the changes recorded by this
ChangeTracker that were reported since construction (or calls to
pushChangeSpec()) by calls to <a class="reference internal" href="#pysyncml.change.tracker.ChangeTracker.append" title="pysyncml.change.tracker.ChangeTracker.append"><tt class="xref py py-meth docutils literal"><span class="pre">append()</span></tt></a> or <a class="reference internal" href="#pysyncml.change.tracker.ChangeTracker.update" title="pysyncml.change.tracker.ChangeTracker.update"><tt class="xref py py-meth docutils literal"><span class="pre">update()</span></tt></a>.</p>
<p>This is similar to, but distinct from, <a class="reference internal" href="#pysyncml.change.tracker.ChangeTracker.getFullChangeSpec" title="pysyncml.change.tracker.ChangeTracker.getFullChangeSpec"><tt class="xref py py-meth docutils literal"><span class="pre">getFullChangeSpec()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pysyncml.change.tracker.ChangeTracker.getFullChangeSpec">
<tt class="descname">getFullChangeSpec</tt><big>(</big><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#ChangeTracker.getFullChangeSpec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.ChangeTracker.getFullChangeSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string-representation of <em>all</em> changes recorded by this
ChangeTracker, including those provided in the constructor and any
calls to <cite>pushChangeSpec()</cite>. Note that this is usually <em>NOT</em> what
you are looking for when reporting changes to the pysyncml
framework &#8211; for that, see <a class="reference internal" href="#pysyncml.change.tracker.ChangeTracker.getChangeSpec" title="pysyncml.change.tracker.ChangeTracker.getChangeSpec"><tt class="xref py py-meth docutils literal"><span class="pre">getChangeSpec()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pysyncml.change.tracker.ChangeTracker.isChange">
<tt class="descname">isChange</tt><big>(</big><em>fieldname</em>, <em>changeType</em>, <em>newValue=None</em>, <em>isMd5=False</em><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#ChangeTracker.isChange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.ChangeTracker.isChange" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks to see if the specified field should be changed to the
<cite>newValue</cite>, first checking to see if the change conflicts with the
change-spec stored by this ChangeTracker. IMPORTANT: the
<cite>changeType</cite> is relative to the <strong>current</strong> local value, as
recorded by the changes stored by this tracker from the
<strong>initial</strong> value.</p>
<p>See <a class="reference internal" href="#pysyncml.change.tracker.ChangeTracker.update" title="pysyncml.change.tracker.ChangeTracker.update"><tt class="xref py py-meth docutils literal"><span class="pre">update()</span></tt></a> for a layer above.</p>
<p>This method will terminate in one of the following three ways:</p>
<ul>
<li><p class="first">returns None:</p>
<p>The <cite>newValue</cite> is actually outdated, but does not conflict.
The field should be left as-is.</p>
</li>
<li><p class="first">returns <cite>changeObject</cite>:</p>
<p>If any form of change should be applied as a result of this
change request, then <cite>changeObject</cite> will be non-None and will
define how. The exact nature of the object is ChangeTracker
subclass dependent.</p>
</li>
<li><p class="first">raises <cite>pysyncml.ConflictError</cite>:</p>
<p>The <cite>newValue</cite> conflicts with a change made by another source
and should be handled by following conflict resolution policy.</p>
</li>
</ul>
<p>For example, if two clients and a server are tracking changes
made to the following fields:</p>
<div class="highlight-python"><pre>initial values (on server, client 1 and client 2):
  field "a" =&gt; "A"    (will not change)
  field "b" =&gt; "B"    (will be modified by client 1)
  field "c" =&gt; "C"    (will be deleted by client 1)
  field "d" =&gt; "D"    (will be modified by client 2)
  field "e" =&gt; "E"    (will be a conflict)
  field "f" =&gt; "F"    (will be modified identically)

client 1 changes:
  does not alter field "a"
  modifies field "b" to "Bmod"
  deletes field "c"
  does not alter field "d"
  deletes field "e"
  modifies field "f" to "Fmod"

client 2 changes (simultaneous to client 1 changes):
  does not alter field "a"
  does not alter field "b"
  does not alter field "c"
  modifies field "d" to "Dmod"
  modifies field "e" to "Emod"
  modifies field "f" to "Fmod"

client 1 synchronizes with server ==&gt; server values:
  field "b" =&gt; "Bmod"
  deletes fields "c" and "e"
  field "f" =&gt; "Fmod"
  change-spec for client 2: "mod:b@vB,f@vF|del:c@vC,e@vE"

when client 2 synchronizes, the framework detects a conflict and
requests a merge attempt by the agent. the agent then compares the
current values and those presented by client 2 and determines:
  - field "a" is unchanged
  - field "b" differs: changed to "B"
  - field "c" differs: added as "C"
  - field "d" differs: change to "Dmod"
  - field "e" differs: added as "Dmod"
  - field "f" is unchanged

for the fields that are mismatches (i.e. fields "b", "c", "d",
and "e"), the agent checks with this change tracker ("ct") to
see if it was actually a change, and if so, if it conflicts:

  - ct.isChange('b', 'B')    ==&gt; None
  - ct.isChange('c', 'C')    ==&gt; None
  - ct.isChange('d', 'Dmod') ==&gt; 'd'
  - ct.isChange('e', 'Emod') ==&gt; raises ConflictError</pre>
</div>
<p>Note that this assumes that the caller will have verified that the
remote <cite>currentValue</cite> is <strong>not</strong> equal to the local active value -
i.e. that there is some difference between the <cite>fieldname</cite> values,
and a resolution needs to be negotiated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newValue</strong> &#8211; A string representing the value that is being tested for
conflicts or outdated-ness.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pysyncml.change.tracker.ChangeTracker.update">
<tt class="descname">update</tt><big>(</big><em>fieldname</em>, <em>localValue</em>, <em>remoteValue</em><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#ChangeTracker.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.ChangeTracker.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the appropriate current value, based on the changes
recorded by this ChangeTracker, the value stored by the server
(<cite>localValue</cite>), and the value stored by the synchronizing client
(<cite>remoteValue</cite>). If <cite>remoteValue</cite> conflicts with changes stored
locally, then a <cite>pysyncml.ConflictError</cite> is raised.</p>
<p>If a change needs to be applied because <cite>remoteValue</cite> has been
updated, then the new value will be returned, and this
ChangeTracker will be updated such that a call to
<a class="reference internal" href="#pysyncml.change.tracker.ChangeTracker.getChangeSpec" title="pysyncml.change.tracker.ChangeTracker.getChangeSpec"><tt class="xref py py-meth docutils literal"><span class="pre">getChangeSpec()</span></tt></a> will incorporate the change.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fieldname</strong> &#8211; The name of the fieldname being evaluated.</li>
<li><strong>localValue</strong> &#8211; The value of the field as stored by the server, usually the one that
also stored the current change-spec. If <cite>localValue</cite> is <tt class="docutils literal"><span class="pre">None</span></tt>,
then it is assumed that the field was potentially added (this will
first be verified against the stored change-spec).</li>
<li><strong>remoteValue</strong> &#8211; The new value being presented that may or may not be a source of
conflict. If <cite>remoteValue</cite> is <tt class="docutils literal"><span class="pre">None</span></tt>, then it is assumed that
the field was potentially deleted (this will first be verified
against the stored change-spec).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysyncml.change.tracker.ListChangeTracker">
<em class="property">class </em><tt class="descclassname">pysyncml.change.tracker.</tt><tt class="descname">ListChangeTracker</tt><big>(</big><em>changeSpec=None</em>, <em>*args</em>, <em>**kw</em><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#ListChangeTracker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.ListChangeTracker" title="Permalink to this definition">¶</a></dt>
<dd><p>A ChangeTracker implementation that manages changes made to an
ordered sequence of elements. This tracker is aware that (and
adjusts for the fact that) the addition or deletion of an element in
the list can impact the indexing of elements that come sequentially
after the change. The most common use of the ListChangeTracker is to
track changes to text that has been broken down into sequences of
lines or words.</p>
<p>Initializes this ListChangeTracker with the provided <cite>changeSpec</cite>,
which is expected to be in the same format as what would have been
returned by a call to <tt class="docutils literal"><span class="pre">str()</span></tt> on this object. The change-spec
will look similar to:</p>
<div class="highlight-python"><pre>2:a,1:M68b329d...,1:mh4d9,2:Dba45...,3:a</pre>
</div>
<p>If <cite>changeSpec</cite> is not specified, this ListChangeTracker will
start assuming no prior changes were made to any content and will
expect changes to be reported via <tt class="xref py py-meth docutils literal"><span class="pre">pushChange()</span></tt>.</p>
<dl class="method">
<dt id="pysyncml.change.tracker.ListChangeTracker.append">
<tt class="descname">append</tt><big>(</big><em>listIndex</em>, <em>changeType</em>, <em>initialValue=None</em>, <em>isMd5=False</em><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#ListChangeTracker.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.ListChangeTracker.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a change spec to the current list of changes. The <cite>listIndex</cite>
represents the line number (in multi-line mode) or word number (in
single-line mode), and must be <strong>INCLUSIVE</strong> of both additions and
deletions.</p>
</dd></dl>

<dl class="method">
<dt id="pysyncml.change.tracker.ListChangeTracker.isChange">
<tt class="descname">isChange</tt><big>(</big><em>listIndex</em>, <em>changeType</em>, <em>newValue=None</em>, <em>isMd5=False</em>, <em>token=None</em><big>)</big><a class="reference internal" href="../../_modules/pysyncml/change/tracker.html#ListChangeTracker.isChange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pysyncml.change.tracker.ListChangeTracker.isChange" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements as specified in <a class="reference internal" href="#pysyncml.change.tracker.ChangeTracker.isChange" title="pysyncml.change.tracker.ChangeTracker.isChange"><tt class="xref py py-meth docutils literal"><span class="pre">ChangeTracker.isChange()</span></tt></a> where
the <cite>changeObject</cite> is a two-element tuple. The first element is
the index at which the change should be applied, and the second
element is an abstract token that should be passed back into this
method at every iteration.</p>
<p>IMPORTANT: unlike the AttributeChangeTracker, the
ListChangeTracker&#8217;s <cite>isChange()</cite> method is sensitive to order
(which is why it uses the <cite>changeObject</cite> and <cite>token</cite>
mechanisms. Therefore, it is important to call <cite>isChange()</cite>
sequentially with all changes in the order that they occur in the
change list.</p>
</dd></dl>

</dd></dl>

</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="merger.html">Module: pysyncml.change.merger</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../cli/base.html">Module: pysyncml.cli</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012-2012, UberDev, No Rights Reserved.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>