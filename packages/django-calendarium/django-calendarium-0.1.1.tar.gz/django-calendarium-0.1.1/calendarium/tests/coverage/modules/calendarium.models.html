<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: calendarium.models</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="calendarium.forms.html">calendarium.forms</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="calendarium.templatetags.calendarium_tags.html">calendarium.templatetags.calendarium_tags</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">calendarium.models</span>:
    160 total statements,
    <span class="normal">78.1% covered</span>
  </h1>
  <p>Generated: Sun 2013-03-24 21:11 CET</p>
  <p>Source file: /home/tobi/Projects/calendarium/src/calendarium/models.py</p>
  <p>
    Stats:
    <span class="executed">107 executed</span>,
    <span class="missed">30 missed</span>,
    <span class="excluded">23 excluded</span>,
    <span class="ignored">269 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="ignored"><code>"""</code></li>
<li class="ignored"><code>Models for the ``calendarium`` app.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>The code of these models is highly influenced by or taken from the models of</code></li>
<li class="ignored"><code>django-schedule:</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>https://github.com/thauber/django-schedule/tree/master/schedule/models</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>"""</code></li>
<li class="excluded"><code>import json</code></li>
<li class="excluded"><code>from dateutil import rrule</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from django.contrib.contenttypes import generic</code></li>
<li class="excluded"><code>from django.contrib.contenttypes.models import ContentType</code></li>
<li class="excluded"><code>from django.core.urlresolvers import reverse</code></li>
<li class="excluded"><code>from django.core.validators import RegexValidator</code></li>
<li class="excluded"><code>from django.db import models</code></li>
<li class="excluded"><code>from django.utils.timezone import timedelta</code></li>
<li class="excluded"><code>from django.utils.translation import ugettext_lazy as _</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from calendarium.constants import FREQUENCY_CHOICES, OCCURRENCE_DECISIONS</code></li>
<li class="excluded"><code>from calendarium.utils import OccurrenceReplacer</code></li>
<li class="excluded"><code>from calendarium.widgets import ColorPickerWidget</code></li>
<li class="excluded"><code>from south.modelsinspector import add_introspection_rules</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class ColorField(models.CharField):</code></li>
<li class="ignored"><code>    """Custom color field to display a color picker."""</code></li>
<li class="executed"><code>    def __init__(self, *args, **kwargs):</code></li>
<li class="executed"><code>        kwargs['max_length'] = 6</code></li>
<li class="executed"><code>        super(ColorField, self).__init__(*args, **kwargs)</code></li>
<li class="executed"><code>        self.validators.append(RegexValidator(</code></li>
<li class="ignored"><code>            regex='^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$',</code></li>
<li class="ignored"><code>            message='Only RGB color model inputs allowed, like 00000',</code></li>
<li class="ignored"><code>            code='nomatch'))</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def formfield(self, **kwargs):</code></li>
<li class="missed"><code>        kwargs['widget'] = ColorPickerWidget</code></li>
<li class="missed"><code>        return super(ColorField, self).formfield(**kwargs)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>add_introspection_rules([], ["^calendarium\.models\.ColorField"])</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class EventModelManager(models.Manager):</code></li>
<li class="ignored"><code>    """Custom manager for the ``Event`` model class."""</code></li>
<li class="executed"><code>    def get_occurrences(self, start, end):</code></li>
<li class="ignored"><code>        """Returns a list of events and occurrences for the given period."""</code></li>
<li class="ignored"><code>        # we always want the time of start and end to be at 00:00</code></li>
<li class="executed"><code>        start = start.replace(minute=0, hour=0)</code></li>
<li class="executed"><code>        end = end.replace(minute=0, hour=0)</code></li>
<li class="ignored"><code>        # if we recieve the date of one day as start and end, we need to set</code></li>
<li class="ignored"><code>        # end one day forward</code></li>
<li class="executed"><code>        if start == end:</code></li>
<li class="executed"><code>            end = start + timedelta(days=1)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # retrieving relevant events</code></li>
<li class="ignored"><code>        # TODO currently for events with a rule, I can't properly find out when</code></li>
<li class="ignored"><code>        # the last occurrence of the event ends, or find a way to filter that,</code></li>
<li class="ignored"><code>        # so I'm still fetching **all** events before this period, that have a</code></li>
<li class="ignored"><code>        # end_recurring_period.</code></li>
<li class="ignored"><code>        # For events without a rule, I fetch only the relevant ones.</code></li>
<li class="executed"><code>        qs = self.get_query_set()</code></li>
<li class="executed"><code>        qs = qs.filter(start__lt=end)</code></li>
<li class="executed"><code>        relevant_events = qs.filter(</code></li>
<li class="ignored"><code>            models.Q(end_recurring_period__isnull=True, end__gt=start) |</code></li>
<li class="ignored"><code>            models.Q(end_recurring_period__isnull=False))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # get all occurrences for those events that don't already have a</code></li>
<li class="ignored"><code>        # persistent match and that lie in this period.</code></li>
<li class="executed"><code>        all_occurrences = []</code></li>
<li class="executed"><code>        for event in relevant_events:</code></li>
<li class="executed"><code>            all_occurrences.extend(event.get_occurrences(start, end))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # sort and return</code></li>
<li class="executed"><code>        return sorted(all_occurrences, key=lambda x: x.start)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class EventModelMixin(models.Model):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Abstract base class to prevent code duplication.</code></li>
<li class="ignored"><code>    :start: The start date of the event.</code></li>
<li class="ignored"><code>    :end: The end date of the event.</code></li>
<li class="ignored"><code>    :creation_date: When this event was created.</code></li>
<li class="ignored"><code>    :description: The description of the event.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    """</code></li>
<li class="executed"><code>    start = models.DateTimeField(</code></li>
<li class="ignored"><code>        verbose_name=_('Start date'),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    end = models.DateTimeField(</code></li>
<li class="ignored"><code>        verbose_name=_('End date'),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    creation_date = models.DateTimeField(</code></li>
<li class="ignored"><code>        verbose_name=_('Creation date'),</code></li>
<li class="ignored"><code>        auto_now_add=True,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    description = models.TextField(</code></li>
<li class="ignored"><code>        max_length=2048,</code></li>
<li class="ignored"><code>        verbose_name=_('Description'),</code></li>
<li class="ignored"><code>        blank=True,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return self.title</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    class Meta:</code></li>
<li class="executed"><code>        abstract = True</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Event(EventModelMixin):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Hold the information about an event in the calendar.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    :created_by: FK to the ``User``, who created this event.</code></li>
<li class="ignored"><code>    :category: FK to the ``EventCategory`` this event belongs to.</code></li>
<li class="ignored"><code>    :rule: FK to the definition of the recurrence of an event.</code></li>
<li class="ignored"><code>    :end_recurring_period: The possible end of the recurring definition.</code></li>
<li class="ignored"><code>    :title: The title of the event.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    created_by = models.ForeignKey(</code></li>
<li class="ignored"><code>        'auth.User',</code></li>
<li class="ignored"><code>        verbose_name=_('Created by'),</code></li>
<li class="ignored"><code>        related_name='events',</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    category = models.ForeignKey(</code></li>
<li class="ignored"><code>        'EventCategory',</code></li>
<li class="ignored"><code>        verbose_name=_('Category'),</code></li>
<li class="ignored"><code>        related_name='events',</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    rule = models.ForeignKey(</code></li>
<li class="ignored"><code>        'Rule',</code></li>
<li class="ignored"><code>        verbose_name=_('Rule'),</code></li>
<li class="ignored"><code>        blank=True, null=True,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    end_recurring_period = models.DateTimeField(</code></li>
<li class="ignored"><code>        verbose_name=_('End of recurring'),</code></li>
<li class="ignored"><code>        blank=True, null=True,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    title = models.CharField(</code></li>
<li class="ignored"><code>        max_length=256,</code></li>
<li class="ignored"><code>        verbose_name=_('Title'),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    objects = EventModelManager()</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def get_absolute_url(self):</code></li>
<li class="excluded"><code>        return reverse('calendar_event_detail', kwargs={'pk': self.pk})</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def _create_occurrence(self, occ_start, occ_end=None):</code></li>
<li class="ignored"><code>        """Creates an Occurrence instance."""</code></li>
<li class="ignored"><code>        # if the length is not altered, it is okay to only pass occ_start</code></li>
<li class="executed"><code>        if not occ_end:</code></li>
<li class="executed"><code>            occ_end = occ_start + (self.end - self.start)</code></li>
<li class="executed"><code>        return Occurrence(</code></li>
<li class="ignored"><code>            event=self, start=occ_start, end=occ_end,</code></li>
<li class="ignored"><code>            # TODO not sure why original start and end also are occ_start/_end</code></li>
<li class="ignored"><code>            original_start=occ_start, original_end=occ_end,</code></li>
<li class="ignored"><code>            title=self.title, description=self.description,</code></li>
<li class="ignored"><code>            creation_date=self.creation_date, created_by=self.created_by)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def _get_date_gen(self, rr, start, end):</code></li>
<li class="ignored"><code>        """Returns a generator to create the start dates for occurrences."""</code></li>
<li class="executed"><code>        date = rr.after(start)</code></li>
<li class="executed"><code>        while end and date &lt;= end or not(end):</code></li>
<li class="executed"><code>            yield date</code></li>
<li class="executed"><code>            date = rr.after(date)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def _get_occurrence_gen(self, start, end):</code></li>
<li class="ignored"><code>        """Computes all occurrences for this event from start to end."""</code></li>
<li class="ignored"><code>        # get length of the event</code></li>
<li class="executed"><code>        length = self.end - self.start</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if self.rule:</code></li>
<li class="ignored"><code>            # if the end of the recurring period is before the end arg passed</code></li>
<li class="ignored"><code>            # the end of the recurring period should be the new end</code></li>
<li class="executed"><code>            if self.end_recurring_period and end and (</code></li>
<li class="ignored"><code>                    self.end_recurring_period &lt; end):</code></li>
<li class="executed"><code>                end = self.end_recurring_period</code></li>
<li class="ignored"><code>            # making start date generator</code></li>
<li class="executed"><code>            occ_start_gen = self._get_date_gen(</code></li>
<li class="ignored"><code>                self.get_rrule_object(),</code></li>
<li class="ignored"><code>                start - length, end)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # chosing the first item from the generator to initiate</code></li>
<li class="executed"><code>            occ_start = occ_start_gen.next()</code></li>
<li class="executed"><code>            while not end or (end and occ_start &lt;= end):</code></li>
<li class="executed"><code>                occ_end = occ_start + length</code></li>
<li class="executed"><code>                yield self._create_occurrence(occ_start, occ_end)</code></li>
<li class="executed"><code>                occ_start = occ_start_gen.next()</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="ignored"><code>            # check if event is in the period</code></li>
<li class="executed"><code>            if (not end or self.start &lt; end) and self.end &gt;= start:</code></li>
<li class="executed"><code>                yield self._create_occurrence(self.start, self.end)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def get_occurrences(self, start, end=None):</code></li>
<li class="ignored"><code>        """Returns all occurrences from start to end."""</code></li>
<li class="ignored"><code>        # get persistent occurrences</code></li>
<li class="executed"><code>        persistent_occurrences = self.occurrences.all()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # setup occ_replacer with p_occs</code></li>
<li class="executed"><code>        occ_replacer = OccurrenceReplacer(persistent_occurrences)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # compute own occurrences according to rule that overlap with the</code></li>
<li class="ignored"><code>        # period</code></li>
<li class="executed"><code>        occurrence_gen = self._get_occurrence_gen(start, end)</code></li>
<li class="ignored"><code>        # get additional occs, that we need to take into concern</code></li>
<li class="executed"><code>        additional_occs = occ_replacer.get_additional_occurrences(</code></li>
<li class="ignored"><code>            start, end)</code></li>
<li class="executed"><code>        occ = occurrence_gen.next()</code></li>
<li class="executed"><code>        while not end or (occ.start &lt; end or any(additional_occs)):</code></li>
<li class="executed"><code>            if occ_replacer.has_occurrence(occ):</code></li>
<li class="executed"><code>                p_occ = occ_replacer.get_occurrence(occ)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # if the persistent occ falls into the period, replace it</code></li>
<li class="executed"><code>                if (end and p_occ.start &lt; end) and p_occ.end &gt;= start:</code></li>
<li class="executed"><code>                    estimated_occ = p_occ</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="missed"><code>                    occ = occurrence_gen.next()</code></li>
<li class="missed"><code>                    continue</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="ignored"><code>                # if there is no persistent match, use the original occ</code></li>
<li class="executed"><code>                estimated_occ = occ</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>            if any(additional_occs) and (</code></li>
<li class="ignored"><code>                    estimated_occ.start == additional_occs[0].start):</code></li>
<li class="executed"><code>                final_occ = additional_occs.pop(0)</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="executed"><code>                final_occ = estimated_occ</code></li>
<li class="executed"><code>            if not final_occ.cancelled:</code></li>
<li class="executed"><code>                yield final_occ</code></li>
<li class="executed"><code>            occ = occurrence_gen.next()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def get_rrule_object(self):</code></li>
<li class="ignored"><code>        """Returns the rrule object for this ``Event``."""</code></li>
<li class="executed"><code>        if self.rule:</code></li>
<li class="executed"><code>            params = self.rule.get_params()</code></li>
<li class="executed"><code>            frequency = 'rrule.{0}'.format(self.rule.frequency)</code></li>
<li class="executed"><code>            return rrule.rrule(eval(frequency), dtstart=self.start, **params)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class EventCategory(models.Model):</code></li>
<li class="ignored"><code>    """The category of an event."""</code></li>
<li class="executed"><code>    name = models.CharField(</code></li>
<li class="ignored"><code>        max_length=256,</code></li>
<li class="ignored"><code>        verbose_name=_('Name'),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    color = ColorField(</code></li>
<li class="ignored"><code>        verbose_name=_('Color'),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return self.name</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class EventRelation(models.Model):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    This class allows to relate additional or external data to an event.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    :event: A FK to the ``Event`` this additional data is related to.</code></li>
<li class="ignored"><code>    :content_type: A FK to ContentType of the generic object.</code></li>
<li class="ignored"><code>    :object_id: The id of the generic object.</code></li>
<li class="ignored"><code>    :content_object: The generic foreign key to the generic object.</code></li>
<li class="ignored"><code>    :relation_type: A string representing the type of the relation. This allows</code></li>
<li class="ignored"><code>        to relate to the same content_type several times but mean different</code></li>
<li class="ignored"><code>        things, such as (normal_guests, speakers, keynote_speakers, all being</code></li>
<li class="ignored"><code>        Guest instances)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    event = models.ForeignKey(</code></li>
<li class="ignored"><code>        'Event',</code></li>
<li class="ignored"><code>        verbose_name=_("Event"),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    content_type = models.ForeignKey(</code></li>
<li class="ignored"><code>        ContentType,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    object_id = models.IntegerField()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    content_object = generic.GenericForeignKey(</code></li>
<li class="ignored"><code>        'content_type',</code></li>
<li class="ignored"><code>        'object_id',</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    relation_type = models.CharField(</code></li>
<li class="ignored"><code>        verbose_name=_('Relation type'),</code></li>
<li class="ignored"><code>        max_length=32,</code></li>
<li class="ignored"><code>        blank=True, null=True,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return 'type "{0}" for "{1}"'.format(</code></li>
<li class="ignored"><code>            self.relation_type, self.event.title)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Occurrence(EventModelMixin):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Needed if one occurrence of an event has slightly different settings than</code></li>
<li class="ignored"><code>    all other.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    :created_by: FK to the ``User``, who created this event.</code></li>
<li class="ignored"><code>    :event: FK to the ``Event`` this ``Occurrence`` belongs to.</code></li>
<li class="ignored"><code>    :original_start: The original start of the related ``Event``.</code></li>
<li class="ignored"><code>    :original_end: The original end of the related ``Event``.</code></li>
<li class="ignored"><code>    :title: The title of the event.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    """</code></li>
<li class="executed"><code>    created_by = models.ForeignKey(</code></li>
<li class="ignored"><code>        'auth.User',</code></li>
<li class="ignored"><code>        verbose_name=_('Created by'),</code></li>
<li class="ignored"><code>        related_name='occurrences',</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    event = models.ForeignKey(</code></li>
<li class="ignored"><code>        'Event',</code></li>
<li class="ignored"><code>        verbose_name=_('Event'),</code></li>
<li class="ignored"><code>        related_name='occurrences',</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    original_start = models.DateTimeField(</code></li>
<li class="ignored"><code>        verbose_name=_('Original start'),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    original_end = models.DateTimeField(</code></li>
<li class="ignored"><code>        verbose_name=_('Original end'),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    cancelled = models.BooleanField(</code></li>
<li class="ignored"><code>        verbose_name=_('Cancelled'),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    title = models.CharField(</code></li>
<li class="ignored"><code>        max_length=256,</code></li>
<li class="ignored"><code>        verbose_name=_('Title'),</code></li>
<li class="ignored"><code>        blank=True,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def category(self):</code></li>
<li class="executed"><code>        return self.event.category</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def delete_period(self, period):</code></li>
<li class="ignored"><code>        """Deletes a set of occurrences based on the given decision."""</code></li>
<li class="ignored"><code>        # check if this is the last or only one</code></li>
<li class="missed"><code>        is_last = False</code></li>
<li class="missed"><code>        is_only = False</code></li>
<li class="missed"><code>        gen = self.event.get_occurrences(</code></li>
<li class="ignored"><code>            self.start, self.event.end_recurring_period)</code></li>
<li class="missed"><code>        occs = [occ for occ in gen]</code></li>
<li class="missed"><code>        if len(occs) == 1:</code></li>
<li class="missed"><code>            is_only = True</code></li>
<li class="missed"><code>        elif len(occs) &gt; 1 and self == occs[-1]:</code></li>
<li class="missed"><code>            is_last = True</code></li>
<li class="missed"><code>        if period == OCCURRENCE_DECISIONS['all']:</code></li>
<li class="ignored"><code>            # delete all persistent occurrences along with the parent event</code></li>
<li class="missed"><code>            self.event.occurrences.all().delete()</code></li>
<li class="missed"><code>            self.event.delete()</code></li>
<li class="missed"><code>        elif period == OCCURRENCE_DECISIONS['this one']:</code></li>
<li class="ignored"><code>            # check if it is the last one. If so, shorten the recurring period,</code></li>
<li class="ignored"><code>            # otherwise cancel the event</code></li>
<li class="missed"><code>            if is_last:</code></li>
<li class="missed"><code>                self.event.end_recurring_period = self.start - timedelta(</code></li>
<li class="ignored"><code>                    days=1)</code></li>
<li class="missed"><code>                self.event.save()</code></li>
<li class="missed"><code>            elif is_only:</code></li>
<li class="missed"><code>                self.event.occurrences.all().delete()</code></li>
<li class="missed"><code>                self.event.delete()</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                self.cancelled = True</code></li>
<li class="missed"><code>                self.save()</code></li>
<li class="missed"><code>        elif period == OCCURRENCE_DECISIONS['following']:</code></li>
<li class="ignored"><code>            # just shorten the recurring period</code></li>
<li class="missed"><code>            self.event.end_recurring_period = self.start - timedelta(days=1)</code></li>
<li class="missed"><code>            self.event.occurrences.filter(start__gte=self.start).delete()</code></li>
<li class="missed"><code>            if is_only:</code></li>
<li class="missed"><code>                self.event.delete()</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                self.event.save()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Rule(models.Model):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    This defines the rule by which an event will recur.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    :name: Name of this rule.</code></li>
<li class="ignored"><code>    :description: Description of this rule.</code></li>
<li class="ignored"><code>    :frequency: A string representing the frequency of the recurrence.</code></li>
<li class="ignored"><code>    :params: JSON string to hold the exact rule parameters as used by</code></li>
<li class="ignored"><code>        dateutil.rrule to define the pattern of the recurrence.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    """</code></li>
<li class="executed"><code>    name = models.CharField(</code></li>
<li class="ignored"><code>        verbose_name=_("name"),</code></li>
<li class="ignored"><code>        max_length=32,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    description = models.TextField(</code></li>
<li class="ignored"><code>        _("description"),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    frequency = models.CharField(</code></li>
<li class="ignored"><code>        verbose_name=_("frequency"),</code></li>
<li class="ignored"><code>        choices=FREQUENCY_CHOICES,</code></li>
<li class="ignored"><code>        max_length=10,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    params = models.TextField(</code></li>
<li class="ignored"><code>        verbose_name=_("params"),</code></li>
<li class="ignored"><code>        blank=True, null=True,</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return self.name</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def get_params(self):</code></li>
<li class="executed"><code>        if self.params:</code></li>
<li class="executed"><code>            return json.loads(self.params)</code></li>
<li class="executed"><code>        return {}</code></li>
  </ol>
</div>

<div class="nav">
  <a href="calendarium.forms.html">calendarium.forms</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="calendarium.templatetags.calendarium_tags.html">calendarium.templatetags.calendarium_tags</a>
</div>

  </body>
</html>

