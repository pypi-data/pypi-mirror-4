/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef plow_TYPES_H
#define plow_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "common_types.h"


namespace Plow {

struct JobState {
  enum type {
    INITIALIZE = 0,
    RUNNING = 1,
    FINISHED = 2
  };
};

extern const std::map<int, const char*> _JobState_VALUES_TO_NAMES;

struct TaskState {
  enum type {
    INITIALIZE = 0,
    WAITING = 1,
    RUNNING = 2,
    DEAD = 3,
    EATEN = 4,
    DEPEND = 5,
    SUCCEEDED = 6
  };
};

extern const std::map<int, const char*> _TaskState_VALUES_TO_NAMES;

struct NodeState {
  enum type {
    UP = 0,
    DOWN = 1,
    REPAIR = 2
  };
};

extern const std::map<int, const char*> _NodeState_VALUES_TO_NAMES;

struct DependType {
  enum type {
    JOB_ON_JOB = 0,
    LAYER_ON_LAYER = 1,
    LAYER_ON_TASK = 2,
    TASK_ON_LAYER = 3,
    TASK_ON_TASK = 4,
    TASK_BY_TASK = 5
  };
};

extern const std::map<int, const char*> _DependType_VALUES_TO_NAMES;

struct MatcherType {
  enum type {
    CONTAINS = 0,
    NOT_CONTAINS = 1,
    IS = 2,
    IS_NOT = 3,
    BEGINS_WITH = 4,
    ENDS_WITH = 5
  };
};

extern const std::map<int, const char*> _MatcherType_VALUES_TO_NAMES;

struct MatcherField {
  enum type {
    JOB_NAME = 0,
    USER = 1,
    ATTR = 2
  };
};

extern const std::map<int, const char*> _MatcherField_VALUES_TO_NAMES;

struct ActionType {
  enum type {
    SET_FOLDER = 0,
    SET_MIN_CORES = 1,
    SET_MAX_CORES = 2,
    PAUSE = 3,
    STOP_PROCESSING = 4
  };
};

extern const std::map<int, const char*> _ActionType_VALUES_TO_NAMES;

typedef std::map<std::string, std::string>  Attrs;

typedef struct _PlowException__isset {
  _PlowException__isset() : what(false), why(false) {}
  bool what;
  bool why;
} _PlowException__isset;

class PlowException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  PlowException() : what(0), why() {
  }

  virtual ~PlowException() throw() {}

  int32_t what;
  std::string why;

  _PlowException__isset __isset;

  void __set_what(const int32_t val) {
    what = val;
  }

  void __set_why(const std::string& val) {
    why = val;
  }

  bool operator == (const PlowException & rhs) const
  {
    if (!(what == rhs.what))
      return false;
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const PlowException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlowException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PlowException &a, PlowException &b);

typedef struct _DependT__isset {
  _DependT__isset() : dependentLayerId(false), dependOnLayerId(false), dependentTaskId(false), dependOnTaskId(false), dependentLayerName(false), dependOnLayerName(false), dependentTaskName(false), dependOnTaskName(false) {}
  bool dependentLayerId;
  bool dependOnLayerId;
  bool dependentTaskId;
  bool dependOnTaskId;
  bool dependentLayerName;
  bool dependOnLayerName;
  bool dependentTaskName;
  bool dependOnTaskName;
} _DependT__isset;

class DependT {
 public:

  static const char* ascii_fingerprint; // = "42D5F222D6ED9D4192E5224B386908E6";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0xD5,0xF2,0x22,0xD6,0xED,0x9D,0x41,0x92,0xE5,0x22,0x4B,0x38,0x69,0x08,0xE6};

  DependT() : id(), type((DependType::type)0), active(0), createdTime(0), modifiedTime(0), dependentJobId(), dependOnJobId(), dependentLayerId(), dependOnLayerId(), dependentTaskId(), dependOnTaskId(), dependentJobName(), dependOnJobName(), dependentLayerName(), dependOnLayerName(), dependentTaskName(), dependOnTaskName() {
  }

  virtual ~DependT() throw() {}

   ::Plow::Guid id;
  DependType::type type;
  bool active;
   ::Plow::Timestamp createdTime;
   ::Plow::Timestamp modifiedTime;
  std::string dependentJobId;
  std::string dependOnJobId;
  std::string dependentLayerId;
  std::string dependOnLayerId;
  std::string dependentTaskId;
  std::string dependOnTaskId;
  std::string dependentJobName;
  std::string dependOnJobName;
  std::string dependentLayerName;
  std::string dependOnLayerName;
  std::string dependentTaskName;
  std::string dependOnTaskName;

  _DependT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_type(const DependType::type val) {
    type = val;
  }

  void __set_active(const bool val) {
    active = val;
  }

  void __set_createdTime(const  ::Plow::Timestamp val) {
    createdTime = val;
  }

  void __set_modifiedTime(const  ::Plow::Timestamp val) {
    modifiedTime = val;
  }

  void __set_dependentJobId(const std::string& val) {
    dependentJobId = val;
  }

  void __set_dependOnJobId(const std::string& val) {
    dependOnJobId = val;
  }

  void __set_dependentLayerId(const std::string& val) {
    dependentLayerId = val;
    __isset.dependentLayerId = true;
  }

  void __set_dependOnLayerId(const std::string& val) {
    dependOnLayerId = val;
    __isset.dependOnLayerId = true;
  }

  void __set_dependentTaskId(const std::string& val) {
    dependentTaskId = val;
    __isset.dependentTaskId = true;
  }

  void __set_dependOnTaskId(const std::string& val) {
    dependOnTaskId = val;
    __isset.dependOnTaskId = true;
  }

  void __set_dependentJobName(const std::string& val) {
    dependentJobName = val;
  }

  void __set_dependOnJobName(const std::string& val) {
    dependOnJobName = val;
  }

  void __set_dependentLayerName(const std::string& val) {
    dependentLayerName = val;
    __isset.dependentLayerName = true;
  }

  void __set_dependOnLayerName(const std::string& val) {
    dependOnLayerName = val;
    __isset.dependOnLayerName = true;
  }

  void __set_dependentTaskName(const std::string& val) {
    dependentTaskName = val;
    __isset.dependentTaskName = true;
  }

  void __set_dependOnTaskName(const std::string& val) {
    dependOnTaskName = val;
    __isset.dependOnTaskName = true;
  }

  bool operator == (const DependT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(active == rhs.active))
      return false;
    if (!(createdTime == rhs.createdTime))
      return false;
    if (!(modifiedTime == rhs.modifiedTime))
      return false;
    if (!(dependentJobId == rhs.dependentJobId))
      return false;
    if (!(dependOnJobId == rhs.dependOnJobId))
      return false;
    if (__isset.dependentLayerId != rhs.__isset.dependentLayerId)
      return false;
    else if (__isset.dependentLayerId && !(dependentLayerId == rhs.dependentLayerId))
      return false;
    if (__isset.dependOnLayerId != rhs.__isset.dependOnLayerId)
      return false;
    else if (__isset.dependOnLayerId && !(dependOnLayerId == rhs.dependOnLayerId))
      return false;
    if (__isset.dependentTaskId != rhs.__isset.dependentTaskId)
      return false;
    else if (__isset.dependentTaskId && !(dependentTaskId == rhs.dependentTaskId))
      return false;
    if (__isset.dependOnTaskId != rhs.__isset.dependOnTaskId)
      return false;
    else if (__isset.dependOnTaskId && !(dependOnTaskId == rhs.dependOnTaskId))
      return false;
    if (!(dependentJobName == rhs.dependentJobName))
      return false;
    if (!(dependOnJobName == rhs.dependOnJobName))
      return false;
    if (__isset.dependentLayerName != rhs.__isset.dependentLayerName)
      return false;
    else if (__isset.dependentLayerName && !(dependentLayerName == rhs.dependentLayerName))
      return false;
    if (__isset.dependOnLayerName != rhs.__isset.dependOnLayerName)
      return false;
    else if (__isset.dependOnLayerName && !(dependOnLayerName == rhs.dependOnLayerName))
      return false;
    if (__isset.dependentTaskName != rhs.__isset.dependentTaskName)
      return false;
    else if (__isset.dependentTaskName && !(dependentTaskName == rhs.dependentTaskName))
      return false;
    if (__isset.dependOnTaskName != rhs.__isset.dependOnTaskName)
      return false;
    else if (__isset.dependOnTaskName && !(dependOnTaskName == rhs.dependOnTaskName))
      return false;
    return true;
  }
  bool operator != (const DependT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DependT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DependT &a, DependT &b);

typedef struct _TaskTotalsT__isset {
  _TaskTotalsT__isset() : totalTaskCount(true), succeededTaskCount(true), runningTaskCount(true), deadTaskCount(true), eatenTaskCount(true), waitingTaskCount(true), dependTaskCount(true) {}
  bool totalTaskCount;
  bool succeededTaskCount;
  bool runningTaskCount;
  bool deadTaskCount;
  bool eatenTaskCount;
  bool waitingTaskCount;
  bool dependTaskCount;
} _TaskTotalsT__isset;

class TaskTotalsT {
 public:

  static const char* ascii_fingerprint; // = "458493A9F4060F6499357D68C4F331E2";
  static const uint8_t binary_fingerprint[16]; // = {0x45,0x84,0x93,0xA9,0xF4,0x06,0x0F,0x64,0x99,0x35,0x7D,0x68,0xC4,0xF3,0x31,0xE2};

  TaskTotalsT() : totalTaskCount(0), succeededTaskCount(0), runningTaskCount(0), deadTaskCount(0), eatenTaskCount(0), waitingTaskCount(0), dependTaskCount(0) {
  }

  virtual ~TaskTotalsT() throw() {}

  int32_t totalTaskCount;
  int32_t succeededTaskCount;
  int32_t runningTaskCount;
  int32_t deadTaskCount;
  int32_t eatenTaskCount;
  int32_t waitingTaskCount;
  int32_t dependTaskCount;

  _TaskTotalsT__isset __isset;

  void __set_totalTaskCount(const int32_t val) {
    totalTaskCount = val;
  }

  void __set_succeededTaskCount(const int32_t val) {
    succeededTaskCount = val;
  }

  void __set_runningTaskCount(const int32_t val) {
    runningTaskCount = val;
  }

  void __set_deadTaskCount(const int32_t val) {
    deadTaskCount = val;
  }

  void __set_eatenTaskCount(const int32_t val) {
    eatenTaskCount = val;
  }

  void __set_waitingTaskCount(const int32_t val) {
    waitingTaskCount = val;
  }

  void __set_dependTaskCount(const int32_t val) {
    dependTaskCount = val;
  }

  bool operator == (const TaskTotalsT & rhs) const
  {
    if (!(totalTaskCount == rhs.totalTaskCount))
      return false;
    if (!(succeededTaskCount == rhs.succeededTaskCount))
      return false;
    if (!(runningTaskCount == rhs.runningTaskCount))
      return false;
    if (!(deadTaskCount == rhs.deadTaskCount))
      return false;
    if (!(eatenTaskCount == rhs.eatenTaskCount))
      return false;
    if (!(waitingTaskCount == rhs.waitingTaskCount))
      return false;
    if (!(dependTaskCount == rhs.dependTaskCount))
      return false;
    return true;
  }
  bool operator != (const TaskTotalsT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskTotalsT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskTotalsT &a, TaskTotalsT &b);

typedef struct _ProjectT__isset {
  _ProjectT__isset() : id(false), code(false), title(false), isActive(false) {}
  bool id;
  bool code;
  bool title;
  bool isActive;
} _ProjectT__isset;

class ProjectT {
 public:

  static const char* ascii_fingerprint; // = "557CE3E1F35DD5D74A3999FB1200CAB8";
  static const uint8_t binary_fingerprint[16]; // = {0x55,0x7C,0xE3,0xE1,0xF3,0x5D,0xD5,0xD7,0x4A,0x39,0x99,0xFB,0x12,0x00,0xCA,0xB8};

  ProjectT() : id(), code(), title(), isActive(0) {
  }

  virtual ~ProjectT() throw() {}

   ::Plow::Guid id;
  std::string code;
  std::string title;
  bool isActive;

  _ProjectT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_code(const std::string& val) {
    code = val;
  }

  void __set_title(const std::string& val) {
    title = val;
  }

  void __set_isActive(const bool val) {
    isActive = val;
  }

  bool operator == (const ProjectT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(title == rhs.title))
      return false;
    if (!(isActive == rhs.isActive))
      return false;
    return true;
  }
  bool operator != (const ProjectT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProjectT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ProjectT &a, ProjectT &b);


class ClusterCountsT {
 public:

  static const char* ascii_fingerprint; // = "FB78EBC5FCC9B4E153E910DEF7648158";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x78,0xEB,0xC5,0xFC,0xC9,0xB4,0xE1,0x53,0xE9,0x10,0xDE,0xF7,0x64,0x81,0x58};

  ClusterCountsT() : nodes(0), upNodes(0), downNodes(0), repairNodes(0), lockedNodes(0), unlockedNodes(0), cores(0), upCores(0), downCores(0), repairCores(0), lockedCores(0), unlockedCores(0), runCores(0), idleCores(0) {
  }

  virtual ~ClusterCountsT() throw() {}

  int32_t nodes;
  int32_t upNodes;
  int32_t downNodes;
  int32_t repairNodes;
  int32_t lockedNodes;
  int32_t unlockedNodes;
  int32_t cores;
  int32_t upCores;
  int32_t downCores;
  int32_t repairCores;
  int32_t lockedCores;
  int32_t unlockedCores;
  int32_t runCores;
  int32_t idleCores;

  void __set_nodes(const int32_t val) {
    nodes = val;
  }

  void __set_upNodes(const int32_t val) {
    upNodes = val;
  }

  void __set_downNodes(const int32_t val) {
    downNodes = val;
  }

  void __set_repairNodes(const int32_t val) {
    repairNodes = val;
  }

  void __set_lockedNodes(const int32_t val) {
    lockedNodes = val;
  }

  void __set_unlockedNodes(const int32_t val) {
    unlockedNodes = val;
  }

  void __set_cores(const int32_t val) {
    cores = val;
  }

  void __set_upCores(const int32_t val) {
    upCores = val;
  }

  void __set_downCores(const int32_t val) {
    downCores = val;
  }

  void __set_repairCores(const int32_t val) {
    repairCores = val;
  }

  void __set_lockedCores(const int32_t val) {
    lockedCores = val;
  }

  void __set_unlockedCores(const int32_t val) {
    unlockedCores = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  void __set_idleCores(const int32_t val) {
    idleCores = val;
  }

  bool operator == (const ClusterCountsT & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    if (!(upNodes == rhs.upNodes))
      return false;
    if (!(downNodes == rhs.downNodes))
      return false;
    if (!(repairNodes == rhs.repairNodes))
      return false;
    if (!(lockedNodes == rhs.lockedNodes))
      return false;
    if (!(unlockedNodes == rhs.unlockedNodes))
      return false;
    if (!(cores == rhs.cores))
      return false;
    if (!(upCores == rhs.upCores))
      return false;
    if (!(downCores == rhs.downCores))
      return false;
    if (!(repairCores == rhs.repairCores))
      return false;
    if (!(lockedCores == rhs.lockedCores))
      return false;
    if (!(unlockedCores == rhs.unlockedCores))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    if (!(idleCores == rhs.idleCores))
      return false;
    return true;
  }
  bool operator != (const ClusterCountsT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterCountsT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ClusterCountsT &a, ClusterCountsT &b);

typedef struct _ClusterT__isset {
  _ClusterT__isset() : name(false), tags(false), isLocked(false), isDefault(false), total(false) {}
  bool name;
  bool tags;
  bool isLocked;
  bool isDefault;
  bool total;
} _ClusterT__isset;

class ClusterT {
 public:

  static const char* ascii_fingerprint; // = "44007FF02F852C1596154F7EE0B2C7C9";
  static const uint8_t binary_fingerprint[16]; // = {0x44,0x00,0x7F,0xF0,0x2F,0x85,0x2C,0x15,0x96,0x15,0x4F,0x7E,0xE0,0xB2,0xC7,0xC9};

  ClusterT() : id(), name(), isLocked(0), isDefault(0) {
  }

  virtual ~ClusterT() throw() {}

   ::Plow::Guid id;
  std::string name;
  std::set<std::string>  tags;
  bool isLocked;
  bool isDefault;
  ClusterCountsT total;

  _ClusterT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_tags(const std::set<std::string> & val) {
    tags = val;
  }

  void __set_isLocked(const bool val) {
    isLocked = val;
  }

  void __set_isDefault(const bool val) {
    isDefault = val;
  }

  void __set_total(const ClusterCountsT& val) {
    total = val;
  }

  bool operator == (const ClusterT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(isLocked == rhs.isLocked))
      return false;
    if (!(isDefault == rhs.isDefault))
      return false;
    if (!(total == rhs.total))
      return false;
    return true;
  }
  bool operator != (const ClusterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ClusterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ClusterT &a, ClusterT &b);

typedef struct _QuotaT__isset {
  _QuotaT__isset() : id(false), clusterId(false), projectId(false), name(false), isLocked(false), size(false), burst(false), runCores(false) {}
  bool id;
  bool clusterId;
  bool projectId;
  bool name;
  bool isLocked;
  bool size;
  bool burst;
  bool runCores;
} _QuotaT__isset;

class QuotaT {
 public:

  static const char* ascii_fingerprint; // = "0168B2E7F15AD09D4D4CF27D6E2795E6";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0x68,0xB2,0xE7,0xF1,0x5A,0xD0,0x9D,0x4D,0x4C,0xF2,0x7D,0x6E,0x27,0x95,0xE6};

  QuotaT() : id(), clusterId(), projectId(), name(), isLocked(0), size(0), burst(0), runCores(0) {
  }

  virtual ~QuotaT() throw() {}

   ::Plow::Guid id;
   ::Plow::Guid clusterId;
   ::Plow::Guid projectId;
  std::string name;
  bool isLocked;
  int32_t size;
  int32_t burst;
  int32_t runCores;

  _QuotaT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_clusterId(const  ::Plow::Guid& val) {
    clusterId = val;
  }

  void __set_projectId(const  ::Plow::Guid& val) {
    projectId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_isLocked(const bool val) {
    isLocked = val;
  }

  void __set_size(const int32_t val) {
    size = val;
  }

  void __set_burst(const int32_t val) {
    burst = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  bool operator == (const QuotaT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(clusterId == rhs.clusterId))
      return false;
    if (!(projectId == rhs.projectId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(isLocked == rhs.isLocked))
      return false;
    if (!(size == rhs.size))
      return false;
    if (!(burst == rhs.burst))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    return true;
  }
  bool operator != (const QuotaT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QuotaT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(QuotaT &a, QuotaT &b);

typedef struct _NodeSystemT__isset {
  _NodeSystemT__isset() : physicalCores(false), logicalCores(false), totalRamMb(false), freeRamMb(false), totalSwapMb(false), freeSwapMb(false), cpuModel(false), platform(false), load(false) {}
  bool physicalCores;
  bool logicalCores;
  bool totalRamMb;
  bool freeRamMb;
  bool totalSwapMb;
  bool freeSwapMb;
  bool cpuModel;
  bool platform;
  bool load;
} _NodeSystemT__isset;

class NodeSystemT {
 public:

  static const char* ascii_fingerprint; // = "DA22BC03B87E362458B544686CD45AB6";
  static const uint8_t binary_fingerprint[16]; // = {0xDA,0x22,0xBC,0x03,0xB8,0x7E,0x36,0x24,0x58,0xB5,0x44,0x68,0x6C,0xD4,0x5A,0xB6};

  NodeSystemT() : physicalCores(0), logicalCores(0), totalRamMb(0), freeRamMb(0), totalSwapMb(0), freeSwapMb(0), cpuModel(), platform() {
  }

  virtual ~NodeSystemT() throw() {}

  int32_t physicalCores;
  int32_t logicalCores;
  int32_t totalRamMb;
  int32_t freeRamMb;
  int32_t totalSwapMb;
  int32_t freeSwapMb;
  std::string cpuModel;
  std::string platform;
  std::vector<int32_t>  load;

  _NodeSystemT__isset __isset;

  void __set_physicalCores(const int32_t val) {
    physicalCores = val;
  }

  void __set_logicalCores(const int32_t val) {
    logicalCores = val;
  }

  void __set_totalRamMb(const int32_t val) {
    totalRamMb = val;
  }

  void __set_freeRamMb(const int32_t val) {
    freeRamMb = val;
  }

  void __set_totalSwapMb(const int32_t val) {
    totalSwapMb = val;
  }

  void __set_freeSwapMb(const int32_t val) {
    freeSwapMb = val;
  }

  void __set_cpuModel(const std::string& val) {
    cpuModel = val;
  }

  void __set_platform(const std::string& val) {
    platform = val;
  }

  void __set_load(const std::vector<int32_t> & val) {
    load = val;
  }

  bool operator == (const NodeSystemT & rhs) const
  {
    if (!(physicalCores == rhs.physicalCores))
      return false;
    if (!(logicalCores == rhs.logicalCores))
      return false;
    if (!(totalRamMb == rhs.totalRamMb))
      return false;
    if (!(freeRamMb == rhs.freeRamMb))
      return false;
    if (!(totalSwapMb == rhs.totalSwapMb))
      return false;
    if (!(freeSwapMb == rhs.freeSwapMb))
      return false;
    if (!(cpuModel == rhs.cpuModel))
      return false;
    if (!(platform == rhs.platform))
      return false;
    if (!(load == rhs.load))
      return false;
    return true;
  }
  bool operator != (const NodeSystemT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeSystemT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NodeSystemT &a, NodeSystemT &b);

typedef struct _NodeT__isset {
  _NodeT__isset() : id(false), clusterId(false), name(false), clusterName(false), ipaddr(false), tags(false), state(false), locked(false), createdTime(false), updatedTime(false), bootTime(false), totalCores(false), idleCores(false), totalRamMb(false), freeRamMb(false), system(false) {}
  bool id;
  bool clusterId;
  bool name;
  bool clusterName;
  bool ipaddr;
  bool tags;
  bool state;
  bool locked;
  bool createdTime;
  bool updatedTime;
  bool bootTime;
  bool totalCores;
  bool idleCores;
  bool totalRamMb;
  bool freeRamMb;
  bool system;
} _NodeT__isset;

class NodeT {
 public:

  static const char* ascii_fingerprint; // = "99788DF07D715CB5A00251BB21383B4B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x78,0x8D,0xF0,0x7D,0x71,0x5C,0xB5,0xA0,0x02,0x51,0xBB,0x21,0x38,0x3B,0x4B};

  NodeT() : id(), clusterId(), name(), clusterName(), ipaddr(), state((NodeState::type)0), locked(0), createdTime(0), updatedTime(0), bootTime(0), totalCores(0), idleCores(0), totalRamMb(0), freeRamMb(0) {
  }

  virtual ~NodeT() throw() {}

   ::Plow::Guid id;
   ::Plow::Guid clusterId;
  std::string name;
  std::string clusterName;
  std::string ipaddr;
  std::set<std::string>  tags;
  NodeState::type state;
  bool locked;
   ::Plow::Timestamp createdTime;
   ::Plow::Timestamp updatedTime;
   ::Plow::Timestamp bootTime;
  int32_t totalCores;
  int32_t idleCores;
  int32_t totalRamMb;
  int32_t freeRamMb;
  NodeSystemT system;

  _NodeT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_clusterId(const  ::Plow::Guid& val) {
    clusterId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_clusterName(const std::string& val) {
    clusterName = val;
  }

  void __set_ipaddr(const std::string& val) {
    ipaddr = val;
  }

  void __set_tags(const std::set<std::string> & val) {
    tags = val;
  }

  void __set_state(const NodeState::type val) {
    state = val;
  }

  void __set_locked(const bool val) {
    locked = val;
  }

  void __set_createdTime(const  ::Plow::Timestamp val) {
    createdTime = val;
  }

  void __set_updatedTime(const  ::Plow::Timestamp val) {
    updatedTime = val;
  }

  void __set_bootTime(const  ::Plow::Timestamp val) {
    bootTime = val;
  }

  void __set_totalCores(const int32_t val) {
    totalCores = val;
  }

  void __set_idleCores(const int32_t val) {
    idleCores = val;
  }

  void __set_totalRamMb(const int32_t val) {
    totalRamMb = val;
  }

  void __set_freeRamMb(const int32_t val) {
    freeRamMb = val;
  }

  void __set_system(const NodeSystemT& val) {
    system = val;
  }

  bool operator == (const NodeT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(clusterId == rhs.clusterId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(clusterName == rhs.clusterName))
      return false;
    if (!(ipaddr == rhs.ipaddr))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(locked == rhs.locked))
      return false;
    if (!(createdTime == rhs.createdTime))
      return false;
    if (!(updatedTime == rhs.updatedTime))
      return false;
    if (!(bootTime == rhs.bootTime))
      return false;
    if (!(totalCores == rhs.totalCores))
      return false;
    if (!(idleCores == rhs.idleCores))
      return false;
    if (!(totalRamMb == rhs.totalRamMb))
      return false;
    if (!(freeRamMb == rhs.freeRamMb))
      return false;
    if (!(system == rhs.system))
      return false;
    return true;
  }
  bool operator != (const NodeT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NodeT &a, NodeT &b);

typedef struct _ProcT__isset {
  _ProcT__isset() : id(false), hostId(false), jobName(false), taskName(false), cores(false), ramMb(false), usedRamMb(false), highRamMb(false), unbooked(false) {}
  bool id;
  bool hostId;
  bool jobName;
  bool taskName;
  bool cores;
  bool ramMb;
  bool usedRamMb;
  bool highRamMb;
  bool unbooked;
} _ProcT__isset;

class ProcT {
 public:

  static const char* ascii_fingerprint; // = "DF2D0B05495D75DAEEDAB46A102BFEF1";
  static const uint8_t binary_fingerprint[16]; // = {0xDF,0x2D,0x0B,0x05,0x49,0x5D,0x75,0xDA,0xEE,0xDA,0xB4,0x6A,0x10,0x2B,0xFE,0xF1};

  ProcT() : id(), hostId(), jobName(), taskName(), cores(0), ramMb(0), usedRamMb(0), highRamMb(0), unbooked(0) {
  }

  virtual ~ProcT() throw() {}

   ::Plow::Guid id;
   ::Plow::Guid hostId;
  std::string jobName;
  std::string taskName;
  int32_t cores;
  int32_t ramMb;
  int32_t usedRamMb;
  int32_t highRamMb;
  bool unbooked;

  _ProcT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_hostId(const  ::Plow::Guid& val) {
    hostId = val;
  }

  void __set_jobName(const std::string& val) {
    jobName = val;
  }

  void __set_taskName(const std::string& val) {
    taskName = val;
  }

  void __set_cores(const int32_t val) {
    cores = val;
  }

  void __set_ramMb(const int32_t val) {
    ramMb = val;
  }

  void __set_usedRamMb(const int32_t val) {
    usedRamMb = val;
  }

  void __set_highRamMb(const int32_t val) {
    highRamMb = val;
  }

  void __set_unbooked(const bool val) {
    unbooked = val;
  }

  bool operator == (const ProcT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(hostId == rhs.hostId))
      return false;
    if (!(jobName == rhs.jobName))
      return false;
    if (!(taskName == rhs.taskName))
      return false;
    if (!(cores == rhs.cores))
      return false;
    if (!(ramMb == rhs.ramMb))
      return false;
    if (!(usedRamMb == rhs.usedRamMb))
      return false;
    if (!(highRamMb == rhs.highRamMb))
      return false;
    if (!(unbooked == rhs.unbooked))
      return false;
    return true;
  }
  bool operator != (const ProcT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProcT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ProcT &a, ProcT &b);

typedef struct _JobT__isset {
  _JobT__isset() : id(false), folderId(false), name(false), username(false), uid(false), state(false), paused(false), minCores(false), maxCores(false), runCores(false), startTime(false), stopTime(false), totals(false), maxRssMb(false), attrs(false) {}
  bool id;
  bool folderId;
  bool name;
  bool username;
  bool uid;
  bool state;
  bool paused;
  bool minCores;
  bool maxCores;
  bool runCores;
  bool startTime;
  bool stopTime;
  bool totals;
  bool maxRssMb;
  bool attrs;
} _JobT__isset;

class JobT {
 public:

  static const char* ascii_fingerprint; // = "125E431D13D8B15912642D7AD4B34136";
  static const uint8_t binary_fingerprint[16]; // = {0x12,0x5E,0x43,0x1D,0x13,0xD8,0xB1,0x59,0x12,0x64,0x2D,0x7A,0xD4,0xB3,0x41,0x36};

  JobT() : id(), folderId(), name(), username(), uid(0), state((JobState::type)0), paused(0), minCores(0), maxCores(0), runCores(0), startTime(0), stopTime(0), maxRssMb(0) {
  }

  virtual ~JobT() throw() {}

   ::Plow::Guid id;
   ::Plow::Guid folderId;
  std::string name;
  std::string username;
  int32_t uid;
  JobState::type state;
  bool paused;
  int32_t minCores;
  int32_t maxCores;
  int32_t runCores;
   ::Plow::Timestamp startTime;
   ::Plow::Timestamp stopTime;
  TaskTotalsT totals;
  int32_t maxRssMb;
  Attrs attrs;

  _JobT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_folderId(const  ::Plow::Guid& val) {
    folderId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_username(const std::string& val) {
    username = val;
  }

  void __set_uid(const int32_t val) {
    uid = val;
  }

  void __set_state(const JobState::type val) {
    state = val;
  }

  void __set_paused(const bool val) {
    paused = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  void __set_startTime(const  ::Plow::Timestamp val) {
    startTime = val;
  }

  void __set_stopTime(const  ::Plow::Timestamp val) {
    stopTime = val;
  }

  void __set_totals(const TaskTotalsT& val) {
    totals = val;
  }

  void __set_maxRssMb(const int32_t val) {
    maxRssMb = val;
  }

  void __set_attrs(const Attrs& val) {
    attrs = val;
  }

  bool operator == (const JobT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(folderId == rhs.folderId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(username == rhs.username))
      return false;
    if (!(uid == rhs.uid))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(paused == rhs.paused))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(stopTime == rhs.stopTime))
      return false;
    if (!(totals == rhs.totals))
      return false;
    if (!(maxRssMb == rhs.maxRssMb))
      return false;
    if (!(attrs == rhs.attrs))
      return false;
    return true;
  }
  bool operator != (const JobT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobT &a, JobT &b);

typedef struct _LayerT__isset {
  _LayerT__isset() : id(false), name(false), range(false), chunk(false), tags(false), threadable(false), minCores(false), maxCores(false), minRamMb(false), runCores(false), totals(false), maxRssMb(false), maxCpuPerc(false) {}
  bool id;
  bool name;
  bool range;
  bool chunk;
  bool tags;
  bool threadable;
  bool minCores;
  bool maxCores;
  bool minRamMb;
  bool runCores;
  bool totals;
  bool maxRssMb;
  bool maxCpuPerc;
} _LayerT__isset;

class LayerT {
 public:

  static const char* ascii_fingerprint; // = "A0609CE5F3D1B9C3469DA3791D724ACE";
  static const uint8_t binary_fingerprint[16]; // = {0xA0,0x60,0x9C,0xE5,0xF3,0xD1,0xB9,0xC3,0x46,0x9D,0xA3,0x79,0x1D,0x72,0x4A,0xCE};

  LayerT() : id(), name(), range(), chunk(0), threadable(0), minCores(0), maxCores(0), minRamMb(0), runCores(0), maxRssMb(0), maxCpuPerc(0) {
  }

  virtual ~LayerT() throw() {}

   ::Plow::Guid id;
  std::string name;
  std::string range;
  int32_t chunk;
  std::set<std::string>  tags;
  bool threadable;
  int32_t minCores;
  int32_t maxCores;
  int32_t minRamMb;
  int32_t runCores;
  TaskTotalsT totals;
  int32_t maxRssMb;
  int16_t maxCpuPerc;

  _LayerT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_range(const std::string& val) {
    range = val;
  }

  void __set_chunk(const int32_t val) {
    chunk = val;
  }

  void __set_tags(const std::set<std::string> & val) {
    tags = val;
  }

  void __set_threadable(const bool val) {
    threadable = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_minRamMb(const int32_t val) {
    minRamMb = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  void __set_totals(const TaskTotalsT& val) {
    totals = val;
  }

  void __set_maxRssMb(const int32_t val) {
    maxRssMb = val;
  }

  void __set_maxCpuPerc(const int16_t val) {
    maxCpuPerc = val;
  }

  bool operator == (const LayerT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(range == rhs.range))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (!(threadable == rhs.threadable))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(minRamMb == rhs.minRamMb))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    if (!(totals == rhs.totals))
      return false;
    if (!(maxRssMb == rhs.maxRssMb))
      return false;
    if (!(maxCpuPerc == rhs.maxCpuPerc))
      return false;
    return true;
  }
  bool operator != (const LayerT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LayerT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LayerT &a, LayerT &b);

typedef struct _TaskT__isset {
  _TaskT__isset() : id(false), name(false), number(false), dependCount(false), order(false), state(false), startTime(false), stopTime(false), lastNodeName(false), lastLogLine(false), retries(false), cores(false), ramMb(false), rssMb(false), maxRssMb(false), cpuPerc(false), maxCpuPerc(false), progress(false) {}
  bool id;
  bool name;
  bool number;
  bool dependCount;
  bool order;
  bool state;
  bool startTime;
  bool stopTime;
  bool lastNodeName;
  bool lastLogLine;
  bool retries;
  bool cores;
  bool ramMb;
  bool rssMb;
  bool maxRssMb;
  bool cpuPerc;
  bool maxCpuPerc;
  bool progress;
} _TaskT__isset;

class TaskT {
 public:

  static const char* ascii_fingerprint; // = "4E3CC190AD5B376E4BC53A0D5EA40FAC";
  static const uint8_t binary_fingerprint[16]; // = {0x4E,0x3C,0xC1,0x90,0xAD,0x5B,0x37,0x6E,0x4B,0xC5,0x3A,0x0D,0x5E,0xA4,0x0F,0xAC};

  TaskT() : id(), name(), number(0), dependCount(0), order(0), state((TaskState::type)0), startTime(0), stopTime(0), lastNodeName(), lastLogLine(), retries(0), cores(0), ramMb(0), rssMb(0), maxRssMb(0), cpuPerc(0), maxCpuPerc(0), progress(0) {
  }

  virtual ~TaskT() throw() {}

   ::Plow::Guid id;
  std::string name;
  int32_t number;
  int32_t dependCount;
  int32_t order;
  TaskState::type state;
   ::Plow::Timestamp startTime;
   ::Plow::Timestamp stopTime;
  std::string lastNodeName;
  std::string lastLogLine;
  int32_t retries;
  int32_t cores;
  int32_t ramMb;
  int32_t rssMb;
  int32_t maxRssMb;
  int16_t cpuPerc;
  int16_t maxCpuPerc;
  int32_t progress;

  _TaskT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_number(const int32_t val) {
    number = val;
  }

  void __set_dependCount(const int32_t val) {
    dependCount = val;
  }

  void __set_order(const int32_t val) {
    order = val;
  }

  void __set_state(const TaskState::type val) {
    state = val;
  }

  void __set_startTime(const  ::Plow::Timestamp val) {
    startTime = val;
  }

  void __set_stopTime(const  ::Plow::Timestamp val) {
    stopTime = val;
  }

  void __set_lastNodeName(const std::string& val) {
    lastNodeName = val;
  }

  void __set_lastLogLine(const std::string& val) {
    lastLogLine = val;
  }

  void __set_retries(const int32_t val) {
    retries = val;
  }

  void __set_cores(const int32_t val) {
    cores = val;
  }

  void __set_ramMb(const int32_t val) {
    ramMb = val;
  }

  void __set_rssMb(const int32_t val) {
    rssMb = val;
  }

  void __set_maxRssMb(const int32_t val) {
    maxRssMb = val;
  }

  void __set_cpuPerc(const int16_t val) {
    cpuPerc = val;
  }

  void __set_maxCpuPerc(const int16_t val) {
    maxCpuPerc = val;
  }

  void __set_progress(const int32_t val) {
    progress = val;
  }

  bool operator == (const TaskT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(number == rhs.number))
      return false;
    if (!(dependCount == rhs.dependCount))
      return false;
    if (!(order == rhs.order))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(stopTime == rhs.stopTime))
      return false;
    if (!(lastNodeName == rhs.lastNodeName))
      return false;
    if (!(lastLogLine == rhs.lastLogLine))
      return false;
    if (!(retries == rhs.retries))
      return false;
    if (!(cores == rhs.cores))
      return false;
    if (!(ramMb == rhs.ramMb))
      return false;
    if (!(rssMb == rhs.rssMb))
      return false;
    if (!(maxRssMb == rhs.maxRssMb))
      return false;
    if (!(cpuPerc == rhs.cpuPerc))
      return false;
    if (!(maxCpuPerc == rhs.maxCpuPerc))
      return false;
    if (!(progress == rhs.progress))
      return false;
    return true;
  }
  bool operator != (const TaskT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskT &a, TaskT &b);

typedef struct _FolderT__isset {
  _FolderT__isset() : id(false), name(false), minCores(false), maxCores(false), runCores(false), order(false), totals(false), jobs(false) {}
  bool id;
  bool name;
  bool minCores;
  bool maxCores;
  bool runCores;
  bool order;
  bool totals;
  bool jobs;
} _FolderT__isset;

class FolderT {
 public:

  static const char* ascii_fingerprint; // = "31919B8E0F9AED1BFA7EF287C283029D";
  static const uint8_t binary_fingerprint[16]; // = {0x31,0x91,0x9B,0x8E,0x0F,0x9A,0xED,0x1B,0xFA,0x7E,0xF2,0x87,0xC2,0x83,0x02,0x9D};

  FolderT() : id(), name(), minCores(0), maxCores(0), runCores(0), order(0) {
  }

  virtual ~FolderT() throw() {}

   ::Plow::Guid id;
  std::string name;
  int32_t minCores;
  int32_t maxCores;
  int32_t runCores;
  int32_t order;
  TaskTotalsT totals;
  std::vector<JobT>  jobs;

  _FolderT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_runCores(const int32_t val) {
    runCores = val;
  }

  void __set_order(const int32_t val) {
    order = val;
  }

  void __set_totals(const TaskTotalsT& val) {
    totals = val;
  }

  void __set_jobs(const std::vector<JobT> & val) {
    jobs = val;
    __isset.jobs = true;
  }

  bool operator == (const FolderT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(runCores == rhs.runCores))
      return false;
    if (!(order == rhs.order))
      return false;
    if (!(totals == rhs.totals))
      return false;
    if (__isset.jobs != rhs.__isset.jobs)
      return false;
    else if (__isset.jobs && !(jobs == rhs.jobs))
      return false;
    return true;
  }
  bool operator != (const FolderT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FolderT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FolderT &a, FolderT &b);

typedef struct _MatcherT__isset {
  _MatcherT__isset() : id(false), type(false), field(false), value(false), attr(false) {}
  bool id;
  bool type;
  bool field;
  bool value;
  bool attr;
} _MatcherT__isset;

class MatcherT {
 public:

  static const char* ascii_fingerprint; // = "97DC467FBBF7D1E3CE39BC21DB8631F9";
  static const uint8_t binary_fingerprint[16]; // = {0x97,0xDC,0x46,0x7F,0xBB,0xF7,0xD1,0xE3,0xCE,0x39,0xBC,0x21,0xDB,0x86,0x31,0xF9};

  MatcherT() : id(), type((MatcherType::type)0), field((MatcherField::type)0), value(), attr() {
  }

  virtual ~MatcherT() throw() {}

   ::Plow::Guid id;
  MatcherType::type type;
  MatcherField::type field;
  std::string value;
  std::string attr;

  _MatcherT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_type(const MatcherType::type val) {
    type = val;
  }

  void __set_field(const MatcherField::type val) {
    field = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_attr(const std::string& val) {
    attr = val;
    __isset.attr = true;
  }

  bool operator == (const MatcherT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(field == rhs.field))
      return false;
    if (!(value == rhs.value))
      return false;
    if (__isset.attr != rhs.__isset.attr)
      return false;
    else if (__isset.attr && !(attr == rhs.attr))
      return false;
    return true;
  }
  bool operator != (const MatcherT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatcherT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MatcherT &a, MatcherT &b);

typedef struct _ActionT__isset {
  _ActionT__isset() : id(false), type(false), value(false) {}
  bool id;
  bool type;
  bool value;
} _ActionT__isset;

class ActionT {
 public:

  static const char* ascii_fingerprint; // = "D635E8134E429A3CB23835FC5CC677D6";
  static const uint8_t binary_fingerprint[16]; // = {0xD6,0x35,0xE8,0x13,0x4E,0x42,0x9A,0x3C,0xB2,0x38,0x35,0xFC,0x5C,0xC6,0x77,0xD6};

  ActionT() : id(), type((ActionType::type)0), value() {
  }

  virtual ~ActionT() throw() {}

   ::Plow::Guid id;
  ActionType::type type;
  std::string value;

  _ActionT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_type(const ActionType::type val) {
    type = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const ActionT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const ActionT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActionT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ActionT &a, ActionT &b);

typedef struct _FilterT__isset {
  _FilterT__isset() : id(false), name(false), order(false), enabled(false), matchers(false), actions(false) {}
  bool id;
  bool name;
  bool order;
  bool enabled;
  bool matchers;
  bool actions;
} _FilterT__isset;

class FilterT {
 public:

  static const char* ascii_fingerprint; // = "B72114DFC4A1A2E8CF1CBE22113832EF";
  static const uint8_t binary_fingerprint[16]; // = {0xB7,0x21,0x14,0xDF,0xC4,0xA1,0xA2,0xE8,0xCF,0x1C,0xBE,0x22,0x11,0x38,0x32,0xEF};

  FilterT() : id(), name(), order(0), enabled(0) {
  }

  virtual ~FilterT() throw() {}

   ::Plow::Guid id;
  std::string name;
  int32_t order;
  bool enabled;
  std::vector<MatcherT>  matchers;
  std::vector<ActionT>  actions;

  _FilterT__isset __isset;

  void __set_id(const  ::Plow::Guid& val) {
    id = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_order(const int32_t val) {
    order = val;
  }

  void __set_enabled(const bool val) {
    enabled = val;
  }

  void __set_matchers(const std::vector<MatcherT> & val) {
    matchers = val;
    __isset.matchers = true;
  }

  void __set_actions(const std::vector<ActionT> & val) {
    actions = val;
    __isset.actions = true;
  }

  bool operator == (const FilterT & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(order == rhs.order))
      return false;
    if (!(enabled == rhs.enabled))
      return false;
    if (__isset.matchers != rhs.__isset.matchers)
      return false;
    else if (__isset.matchers && !(matchers == rhs.matchers))
      return false;
    if (__isset.actions != rhs.__isset.actions)
      return false;
    else if (__isset.actions && !(actions == rhs.actions))
      return false;
    return true;
  }
  bool operator != (const FilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FilterT &a, FilterT &b);

typedef struct _DependSpecT__isset {
  _DependSpecT__isset() : type(false), dependentJob(false), dependOnJob(false), dependentLayer(false), dependOnLayer(false), dependentTask(false), dependOnTask(false) {}
  bool type;
  bool dependentJob;
  bool dependOnJob;
  bool dependentLayer;
  bool dependOnLayer;
  bool dependentTask;
  bool dependOnTask;
} _DependSpecT__isset;

class DependSpecT {
 public:

  static const char* ascii_fingerprint; // = "C74CD2BA0D69BC506E09542F0DD5DA6B";
  static const uint8_t binary_fingerprint[16]; // = {0xC7,0x4C,0xD2,0xBA,0x0D,0x69,0xBC,0x50,0x6E,0x09,0x54,0x2F,0x0D,0xD5,0xDA,0x6B};

  DependSpecT() : type((DependType::type)0), dependentJob(), dependOnJob(), dependentLayer(), dependOnLayer(), dependentTask(), dependOnTask() {
  }

  virtual ~DependSpecT() throw() {}

  DependType::type type;
  std::string dependentJob;
  std::string dependOnJob;
  std::string dependentLayer;
  std::string dependOnLayer;
  std::string dependentTask;
  std::string dependOnTask;

  _DependSpecT__isset __isset;

  void __set_type(const DependType::type val) {
    type = val;
  }

  void __set_dependentJob(const std::string& val) {
    dependentJob = val;
  }

  void __set_dependOnJob(const std::string& val) {
    dependOnJob = val;
  }

  void __set_dependentLayer(const std::string& val) {
    dependentLayer = val;
  }

  void __set_dependOnLayer(const std::string& val) {
    dependOnLayer = val;
  }

  void __set_dependentTask(const std::string& val) {
    dependentTask = val;
  }

  void __set_dependOnTask(const std::string& val) {
    dependOnTask = val;
  }

  bool operator == (const DependSpecT & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(dependentJob == rhs.dependentJob))
      return false;
    if (!(dependOnJob == rhs.dependOnJob))
      return false;
    if (!(dependentLayer == rhs.dependentLayer))
      return false;
    if (!(dependOnLayer == rhs.dependOnLayer))
      return false;
    if (!(dependentTask == rhs.dependentTask))
      return false;
    if (!(dependOnTask == rhs.dependOnTask))
      return false;
    return true;
  }
  bool operator != (const DependSpecT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DependSpecT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DependSpecT &a, DependSpecT &b);

typedef struct _TaskSpecT__isset {
  _TaskSpecT__isset() : name(false), depends(false) {}
  bool name;
  bool depends;
} _TaskSpecT__isset;

class TaskSpecT {
 public:

  static const char* ascii_fingerprint; // = "1603170361566071292880A0F6D53016";
  static const uint8_t binary_fingerprint[16]; // = {0x16,0x03,0x17,0x03,0x61,0x56,0x60,0x71,0x29,0x28,0x80,0xA0,0xF6,0xD5,0x30,0x16};

  TaskSpecT() : name() {
  }

  virtual ~TaskSpecT() throw() {}

  std::string name;
  std::vector<DependSpecT>  depends;

  _TaskSpecT__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_depends(const std::vector<DependSpecT> & val) {
    depends = val;
  }

  bool operator == (const TaskSpecT & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(depends == rhs.depends))
      return false;
    return true;
  }
  bool operator != (const TaskSpecT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskSpecT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskSpecT &a, TaskSpecT &b);

typedef struct _LayerSpecT__isset {
  _LayerSpecT__isset() : name(false), command(false), tags(false), range(false), chunk(true), minCores(true), maxCores(true), minRamMb(true), threadable(true), depends(false), tasks(false), env(false) {}
  bool name;
  bool command;
  bool tags;
  bool range;
  bool chunk;
  bool minCores;
  bool maxCores;
  bool minRamMb;
  bool threadable;
  bool depends;
  bool tasks;
  bool env;
} _LayerSpecT__isset;

class LayerSpecT {
 public:

  static const char* ascii_fingerprint; // = "56A94EA08E0C9B8AF8E317A5E651C4CF";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA9,0x4E,0xA0,0x8E,0x0C,0x9B,0x8A,0xF8,0xE3,0x17,0xA5,0xE6,0x51,0xC4,0xCF};

  LayerSpecT() : name(), range(), chunk(1), minCores(1), maxCores(1), minRamMb(1024), threadable(false) {
  }

  virtual ~LayerSpecT() throw() {}

  std::string name;
  std::vector<std::string>  command;
  std::set<std::string>  tags;
  std::string range;
  int32_t chunk;
  int32_t minCores;
  int32_t maxCores;
  int32_t minRamMb;
  bool threadable;
  std::vector<DependSpecT>  depends;
  std::vector<TaskSpecT>  tasks;
  Attrs env;

  _LayerSpecT__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_command(const std::vector<std::string> & val) {
    command = val;
  }

  void __set_tags(const std::set<std::string> & val) {
    tags = val;
  }

  void __set_range(const std::string& val) {
    range = val;
    __isset.range = true;
  }

  void __set_chunk(const int32_t val) {
    chunk = val;
  }

  void __set_minCores(const int32_t val) {
    minCores = val;
  }

  void __set_maxCores(const int32_t val) {
    maxCores = val;
  }

  void __set_minRamMb(const int32_t val) {
    minRamMb = val;
  }

  void __set_threadable(const bool val) {
    threadable = val;
  }

  void __set_depends(const std::vector<DependSpecT> & val) {
    depends = val;
  }

  void __set_tasks(const std::vector<TaskSpecT> & val) {
    tasks = val;
  }

  void __set_env(const Attrs& val) {
    env = val;
  }

  bool operator == (const LayerSpecT & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(command == rhs.command))
      return false;
    if (!(tags == rhs.tags))
      return false;
    if (__isset.range != rhs.__isset.range)
      return false;
    else if (__isset.range && !(range == rhs.range))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(minCores == rhs.minCores))
      return false;
    if (!(maxCores == rhs.maxCores))
      return false;
    if (!(minRamMb == rhs.minRamMb))
      return false;
    if (!(threadable == rhs.threadable))
      return false;
    if (!(depends == rhs.depends))
      return false;
    if (!(tasks == rhs.tasks))
      return false;
    if (!(env == rhs.env))
      return false;
    return true;
  }
  bool operator != (const LayerSpecT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LayerSpecT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LayerSpecT &a, LayerSpecT &b);

typedef struct _JobSpecT__isset {
  _JobSpecT__isset() : name(false), project(false), paused(false), username(false), uid(false), logPath(false), layers(false), depends(false), attrs(false), env(false) {}
  bool name;
  bool project;
  bool paused;
  bool username;
  bool uid;
  bool logPath;
  bool layers;
  bool depends;
  bool attrs;
  bool env;
} _JobSpecT__isset;

class JobSpecT {
 public:

  static const char* ascii_fingerprint; // = "D7CBD43F52D409FEEF0B46D569595D81";
  static const uint8_t binary_fingerprint[16]; // = {0xD7,0xCB,0xD4,0x3F,0x52,0xD4,0x09,0xFE,0xEF,0x0B,0x46,0xD5,0x69,0x59,0x5D,0x81};

  JobSpecT() : name(), project(), paused(0), username(), uid(0), logPath() {
  }

  virtual ~JobSpecT() throw() {}

  std::string name;
  std::string project;
  bool paused;
  std::string username;
  int32_t uid;
  std::string logPath;
  std::vector<LayerSpecT>  layers;
  std::vector<DependSpecT>  depends;
  Attrs attrs;
  Attrs env;

  _JobSpecT__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_project(const std::string& val) {
    project = val;
  }

  void __set_paused(const bool val) {
    paused = val;
  }

  void __set_username(const std::string& val) {
    username = val;
  }

  void __set_uid(const int32_t val) {
    uid = val;
  }

  void __set_logPath(const std::string& val) {
    logPath = val;
  }

  void __set_layers(const std::vector<LayerSpecT> & val) {
    layers = val;
  }

  void __set_depends(const std::vector<DependSpecT> & val) {
    depends = val;
  }

  void __set_attrs(const Attrs& val) {
    attrs = val;
  }

  void __set_env(const Attrs& val) {
    env = val;
  }

  bool operator == (const JobSpecT & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(project == rhs.project))
      return false;
    if (!(paused == rhs.paused))
      return false;
    if (!(username == rhs.username))
      return false;
    if (!(uid == rhs.uid))
      return false;
    if (!(logPath == rhs.logPath))
      return false;
    if (!(layers == rhs.layers))
      return false;
    if (!(depends == rhs.depends))
      return false;
    if (!(attrs == rhs.attrs))
      return false;
    if (!(env == rhs.env))
      return false;
    return true;
  }
  bool operator != (const JobSpecT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobSpecT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobSpecT &a, JobSpecT &b);

typedef struct _JobFilterT__isset {
  _JobFilterT__isset() : matchingOnly(true), project(false), user(false), regex(false), states(false), jobIds(false), name(false) {}
  bool matchingOnly;
  bool project;
  bool user;
  bool regex;
  bool states;
  bool jobIds;
  bool name;
} _JobFilterT__isset;

class JobFilterT {
 public:

  static const char* ascii_fingerprint; // = "F937E676F235563615B336A844347504";
  static const uint8_t binary_fingerprint[16]; // = {0xF9,0x37,0xE6,0x76,0xF2,0x35,0x56,0x36,0x15,0xB3,0x36,0xA8,0x44,0x34,0x75,0x04};

  JobFilterT() : matchingOnly(false), regex() {
  }

  virtual ~JobFilterT() throw() {}

  bool matchingOnly;
  std::vector<std::string>  project;
  std::vector<std::string>  user;
  std::string regex;
  std::vector<JobState::type>  states;
  std::vector< ::Plow::Guid>  jobIds;
  std::vector<std::string>  name;

  _JobFilterT__isset __isset;

  void __set_matchingOnly(const bool val) {
    matchingOnly = val;
  }

  void __set_project(const std::vector<std::string> & val) {
    project = val;
  }

  void __set_user(const std::vector<std::string> & val) {
    user = val;
  }

  void __set_regex(const std::string& val) {
    regex = val;
  }

  void __set_states(const std::vector<JobState::type> & val) {
    states = val;
  }

  void __set_jobIds(const std::vector< ::Plow::Guid> & val) {
    jobIds = val;
  }

  void __set_name(const std::vector<std::string> & val) {
    name = val;
  }

  bool operator == (const JobFilterT & rhs) const
  {
    if (!(matchingOnly == rhs.matchingOnly))
      return false;
    if (!(project == rhs.project))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(regex == rhs.regex))
      return false;
    if (!(states == rhs.states))
      return false;
    if (!(jobIds == rhs.jobIds))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const JobFilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JobFilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JobFilterT &a, JobFilterT &b);

typedef struct _TaskFilterT__isset {
  _TaskFilterT__isset() : jobId(false), layerIds(false), states(false), limit(true), offset(true), lastUpdateTime(true), taskIds(false) {}
  bool jobId;
  bool layerIds;
  bool states;
  bool limit;
  bool offset;
  bool lastUpdateTime;
  bool taskIds;
} _TaskFilterT__isset;

class TaskFilterT {
 public:

  static const char* ascii_fingerprint; // = "7028F2D087F924A052FD8B2C709E418F";
  static const uint8_t binary_fingerprint[16]; // = {0x70,0x28,0xF2,0xD0,0x87,0xF9,0x24,0xA0,0x52,0xFD,0x8B,0x2C,0x70,0x9E,0x41,0x8F};

  TaskFilterT() : jobId(), limit(0), offset(0), lastUpdateTime(0LL) {
  }

  virtual ~TaskFilterT() throw() {}

   ::Plow::Guid jobId;
  std::vector< ::Plow::Guid>  layerIds;
  std::vector<TaskState::type>  states;
  int32_t limit;
  int32_t offset;
  int64_t lastUpdateTime;
  std::vector< ::Plow::Guid>  taskIds;

  _TaskFilterT__isset __isset;

  void __set_jobId(const  ::Plow::Guid& val) {
    jobId = val;
  }

  void __set_layerIds(const std::vector< ::Plow::Guid> & val) {
    layerIds = val;
  }

  void __set_states(const std::vector<TaskState::type> & val) {
    states = val;
  }

  void __set_limit(const int32_t val) {
    limit = val;
  }

  void __set_offset(const int32_t val) {
    offset = val;
  }

  void __set_lastUpdateTime(const int64_t val) {
    lastUpdateTime = val;
  }

  void __set_taskIds(const std::vector< ::Plow::Guid> & val) {
    taskIds = val;
  }

  bool operator == (const TaskFilterT & rhs) const
  {
    if (!(jobId == rhs.jobId))
      return false;
    if (!(layerIds == rhs.layerIds))
      return false;
    if (!(states == rhs.states))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(lastUpdateTime == rhs.lastUpdateTime))
      return false;
    if (!(taskIds == rhs.taskIds))
      return false;
    return true;
  }
  bool operator != (const TaskFilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskFilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskFilterT &a, TaskFilterT &b);

typedef struct _NodeFilterT__isset {
  _NodeFilterT__isset() : hostIds(false), clusterIds(false), regex(false), hostnames(false), states(false), locked(false) {}
  bool hostIds;
  bool clusterIds;
  bool regex;
  bool hostnames;
  bool states;
  bool locked;
} _NodeFilterT__isset;

class NodeFilterT {
 public:

  static const char* ascii_fingerprint; // = "A5FBE94ED5EBC0E091C6D957CD35627C";
  static const uint8_t binary_fingerprint[16]; // = {0xA5,0xFB,0xE9,0x4E,0xD5,0xEB,0xC0,0xE0,0x91,0xC6,0xD9,0x57,0xCD,0x35,0x62,0x7C};

  NodeFilterT() : regex(), locked(0) {
  }

  virtual ~NodeFilterT() throw() {}

  std::vector< ::Plow::Guid>  hostIds;
  std::vector< ::Plow::Guid>  clusterIds;
  std::string regex;
  std::vector<std::string>  hostnames;
  std::vector<NodeState::type>  states;
  bool locked;

  _NodeFilterT__isset __isset;

  void __set_hostIds(const std::vector< ::Plow::Guid> & val) {
    hostIds = val;
  }

  void __set_clusterIds(const std::vector< ::Plow::Guid> & val) {
    clusterIds = val;
  }

  void __set_regex(const std::string& val) {
    regex = val;
  }

  void __set_hostnames(const std::vector<std::string> & val) {
    hostnames = val;
  }

  void __set_states(const std::vector<NodeState::type> & val) {
    states = val;
  }

  void __set_locked(const bool val) {
    locked = val;
    __isset.locked = true;
  }

  bool operator == (const NodeFilterT & rhs) const
  {
    if (!(hostIds == rhs.hostIds))
      return false;
    if (!(clusterIds == rhs.clusterIds))
      return false;
    if (!(regex == rhs.regex))
      return false;
    if (!(hostnames == rhs.hostnames))
      return false;
    if (!(states == rhs.states))
      return false;
    if (__isset.locked != rhs.__isset.locked)
      return false;
    else if (__isset.locked && !(locked == rhs.locked))
      return false;
    return true;
  }
  bool operator != (const NodeFilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NodeFilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NodeFilterT &a, NodeFilterT &b);

typedef struct _QuotaFilterT__isset {
  _QuotaFilterT__isset() : project(false), cluster(false) {}
  bool project;
  bool cluster;
} _QuotaFilterT__isset;

class QuotaFilterT {
 public:

  static const char* ascii_fingerprint; // = "92AA23526EDCB0628C830C8758ED7059";
  static const uint8_t binary_fingerprint[16]; // = {0x92,0xAA,0x23,0x52,0x6E,0xDC,0xB0,0x62,0x8C,0x83,0x0C,0x87,0x58,0xED,0x70,0x59};

  QuotaFilterT() {
  }

  virtual ~QuotaFilterT() throw() {}

  std::vector< ::Plow::Guid>  project;
  std::vector< ::Plow::Guid>  cluster;

  _QuotaFilterT__isset __isset;

  void __set_project(const std::vector< ::Plow::Guid> & val) {
    project = val;
    __isset.project = true;
  }

  void __set_cluster(const std::vector< ::Plow::Guid> & val) {
    cluster = val;
    __isset.cluster = true;
  }

  bool operator == (const QuotaFilterT & rhs) const
  {
    if (__isset.project != rhs.__isset.project)
      return false;
    else if (__isset.project && !(project == rhs.project))
      return false;
    if (__isset.cluster != rhs.__isset.cluster)
      return false;
    else if (__isset.cluster && !(cluster == rhs.cluster))
      return false;
    return true;
  }
  bool operator != (const QuotaFilterT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QuotaFilterT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(QuotaFilterT &a, QuotaFilterT &b);

typedef struct _OutputT__isset {
  _OutputT__isset() : path(false), attrs(false) {}
  bool path;
  bool attrs;
} _OutputT__isset;

class OutputT {
 public:

  static const char* ascii_fingerprint; // = "F7C641917C22B35AE581CCD54910B00D";
  static const uint8_t binary_fingerprint[16]; // = {0xF7,0xC6,0x41,0x91,0x7C,0x22,0xB3,0x5A,0xE5,0x81,0xCC,0xD5,0x49,0x10,0xB0,0x0D};

  OutputT() : path() {
  }

  virtual ~OutputT() throw() {}

  std::string path;
   ::Plow::Attrs attrs;

  _OutputT__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_attrs(const  ::Plow::Attrs& val) {
    attrs = val;
  }

  bool operator == (const OutputT & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(attrs == rhs.attrs))
      return false;
    return true;
  }
  bool operator != (const OutputT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OutputT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(OutputT &a, OutputT &b);

} // namespace

#endif
