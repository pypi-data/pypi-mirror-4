"""Tools for configuring and packaging up sites and parts of sites.
"""

import base64
import hashlib
try:
    import ConfigParser as configparser
except ImportError:
    import configparser


class CachedAsset(object):
    """Serve a small static asset out of RAM.

    There are many reasons to prefer setting up a CDN or fast web server
    rather than handling this in Python. But this little facility can
    reduce friction in a new project which must serve small, one-off
    site-wide assets like favicon.ico and robots.txt, which are almost
    always needed and get requested frequently, out of root.
    """
    def __init__(self, typ, data):
        self.length = None
        self.etag = None
        self.type = typ
        self.data = data
        self.calculate_attributes()

    def calculate_attributes(self):
        """Update cached length and etag hash.
        """
        self.length = str(len(self.data))
        self.etag = hashlib.sha1(self.data).hexdigest()

    def headers(self):
        """Return WSGI-style list of header tuples.
        """
        temp = [
                ('Content-Type', self.type),
                ('Content-Length', self.length),
            ]
        if self.etag:
            temp += [('ETag', self.etag)]
        return temp

    def __call__(self, environ, start_response):
        """WSGI app serving the cached asset.
        """
        request_etag = environ.get('HTTP_IF_NONE_MATCH')
        headers = self.headers()
        if request_etag == self.etag:
            start_response("304 Not Modified", headers)
            return ['']
        start_response("200 OK", headers)
        return [self.data]


# Default to transparent .ico since some browsers choke on 0-length or
# .png favicons.
DEFAULT_FAVICON = CachedAsset(
    "image/x-icon",
    base64.b64decode(
        b"AAABAAEAEBACAAEAAQCwAAAAFgAAACgAAAAQAAAAIAAAAAEAAQAAAAAAAAAAAAAAAAA"
        b"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
        b"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//wAA//8AAP//AAD//wAA/"
        b"/8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA")
    )

DEFAULT_ROBOTSTXT = CachedAsset(
    "text/plain",
    "User-agent: *\r\n Disallow:\r\n"
    )


def cached_assets(asset_cache):
    """WSGI middleware to serve data like favicon.ico out of memory.

    This should be as close to outermost as possible in the middleware
    stack so no other middleware applies to it.
    """
    def make_wrapper(app):
        def cached_assets_wrapper(environ, start_response):
            """wrapper generated by cached_asset_wrapper().
            """
            this_app = asset_cache.get(environ.get('PATH_INFO'), app)
            iterable = this_app(environ, start_response)
            assert iterable
            return iterable
        return cached_assets_wrapper
    return make_wrapper


def status_handlers(status_handlers):
    """WSGI middleware to impose standard pages by code (403, 404, etc.)

    Wrapped stuff like error and 404 handlers can return a really minimal
    response.
    """
    def make_wrapper(app):
        def status_handlers_wrapper(environ, start_response):
            """wrapper generated by status_handler_wrapper().
            """
            # Run app with simple status interception
            data = []

            def intercept(status, headers, exc_info=None):
                "intercept start_response call by app"
                data[:] = status, headers, exc_info

            iterable = app(environ, intercept)

            # NEVER mess with response if exc_info was set
            if data[-1]:
                start_response(data[0], data[1], exc_info=data[-1])
                return iterable

            # Otherwise, avoid letting the server try to iterate over
            # None if user forgot to return from a status handler
            assert iterable

            # Look up status code in table. If absent, pass through.
            code = int(data[0].split(' ', 1)[0])
            handler = status_handlers.get(code)
            if not handler:
                start_response(*data[:2])
                return iterable
            iterable = handler(environ, start_response)
            assert iterable, "status handler for %s returned nothing" % code
            return iterable
        return status_handlers_wrapper
    return make_wrapper


def config_from_json(path):
    """Load simple JSON mapping to Python dict
    """
    import json
    with open(path, 'rb') as config_file:
        loaded = json.load(config_file)
    return loaded


def config_from_yaml(path):
    """Load simple YAML mapping to Python dict
    """
    import yaml
    with open(path, 'rb') as config_file:
        loaded = yaml.load(config_file)
    return loaded


def config_from_ini(path):
    """Load variables from .ini [DEFAULT] section to Python dict
    """
    parser = configparser.RawConfigParser()
    parser.read([path])
    items = parser.items('DEFAULT')
    loaded = dict(items)
    return loaded


def config_from_file(path):
    """Load config from file (with registered loaded) to Python dict
    """
    found = None
    for (ext, loader) in _LOADERS.items():
        if path.endswith('.' + ext):
            found = loader
            break
    if found is None:
        return None
    loaded = found(path)
    assert isinstance(loaded, dict)
    return loaded


def config_from_env(prefix, include=None, exclude=None):
    """Load specified os.environ keys into a Python dict.
    """
    # This is NOT to be confused with WSGI environ and should NEVER run
    # inside a WSGI handler.
    from os import environ
    exclude = exclude or set([])
    config = {}
    for (key, value) in environ.items():
        if include and key not in include:
            continue
        if key in exclude:
            continue
        if prefix:
            if not key.startswith(prefix):
                continue
            key = key[:len(prefix)]
        config[key.lower()] = value
    return config


def config_from_module(import_path, prefix=None, include=None, exclude=None):
    """Load configuration from globals in a simple Python module.
    """
    exclude = exclude or set([])
    module = __import__(import_path)
    keys = getattr(module, '__all__')
    if include is not None:
        keys = [key for key in keys if key in include]
    if not keys:
        keys = [key for key in dir(module) if key[0] != '_']
    keys = [key for key in keys
            if key.isupper() and key not in exclude]
    data = {}
    for key in keys:
        value = getattr(module, key)
        if prefix:
            if not key.startswith(prefix):
                continue
            key = key[:len(prefix)]
        data[key.lower()] = value


_LOADERS = {
        'json': config_from_json,
        'yaml': config_from_yaml,
        'ini': config_from_ini
        }


def register_loader(ext, function):
    """Register a function as a loader for the given extension.

    This will then be used by config_from_file.
    """
    _LOADERS[ext] = function


class _DictProxy(object):
    """Present simple, read-only, attribute view of dict's data.

    The read-only constraint is for ergonomics, not security. It can be
    circumvented - though to do that is entirely self-defeating; this is
    an easy non-magical way to encourage thread-safety, cross-process
    scaling, and the sanity of the code that should be consuming the
    config. If you need global state then look into a signals dispatcher
    or an external queue.

    The attribute access is for convenient syntax, to keep
    implementation simple (dict is a big interface) and to reinforce the
    message that this is not a dict but a way of getting access to
    config variables.

    This is for internal use only (hence the _) - please don't use it in
    outside code. This preserves room to improve how this job is done in
    the future.
    """
    def __init__(self, data):
        self._data = data

    def __getattr__(self, key):
        """Ultra simple attribute access, to reduce ['']
        """
        if key[0] == '_':
            return None
        return self._data.get(key, None)


class Bundle(object):
    """Encapsulate sites for configurable reuse by making subclasses.

    A Bundle subclass is a recipe for making a certain site. A bundle
    instance is a configuration attached to a root object (usually
    a dispatcher mapping some paths to handlers).
    """
    # Bundle's external mount path, without trailing slash
    prefix = ''
    # Seq of WSGI middleware wrappers defining site-wide behavior
    wrappers = None
    # Root dispatch mechanism, should be set by subclass
    root = None
    # Overrideable parameters to be exposed to parts inside bundle.
    default_config = {'debug': False, 'environment': 'dev'}
    # File to get key/value pairs from.
    config_file = ''
    # os.environ variables with prefix will be put in config (de-prefixed).
    config_prefix = None
    # Mapping of (int) HTTP status codes to WSGI apps to substitute responses
    status_handlers = None
    # Simple in-memory cache for small site-wide data
    asset_cache = {
        '/robots.txt': DEFAULT_ROBOTSTXT,
        '/favicon.ico': DEFAULT_FAVICON,
    }

    def __init__(self, config_file=None, config_prefix=None, prefix=None,
            **kwargs):
        """Set up deployable instance according to parameters.
        """
        self.id = None
        # Copy any class level wrappers as foolproofing
        self.wrappers = self.wrappers[:] if self.wrappers else None
        # To say 'no wrappers,' override w/wrappers=[] instead of None.
        if self.wrappers is None:
            self.wrappers = [self.default_wrapper]
        # Process configuration info, then do instance setup
        self.config_file = config_file or self.config_file
        self.config_prefix = config_prefix or self.config_prefix
        self.prefix = prefix if prefix is not None else self.prefix

        self._config = None
        self.configure(**kwargs)
        self._config_proxy = _DictProxy(self._config)
        self.setup()

        # Wrap the root dispatcher with site-wide behaviors.
        wrapped = self.root
        for wrapper in self.wrappers:
            wrapped = wrapper(wrapped)
        self.root = wrapped

    def configure(self, **kwargs):
        """Collect config parameters onto instance attributes.

        Override this if you want to customize how configuration is
        loaded. This isn't normally for direct use, except by __init__.
        Handlers and middleware should never touch this or _config.

        If you just want to pass in data for handlers to use, pass it in
        as keyword arguments to the Bundle constructor.
        """
        if not self._config:
            config = self.default_config.copy()
            loaded = config_from_file(self.config_file)
            config.update(loaded)
            yoinked = config_from_env(self.config_prefix)
            config.update(yoinked)
            self._config = config
        self._config.update(**kwargs)

    def setup(self):
        """Do instance-specific setup (after configuration is processed).

        This is an override point to allow the base class __init__ to be
        used intact without giving up instance-specific setups. It runs
        after config is loaded and configure is run, but before wrappers
        are applied.

        This should get parameters from self and/or self.config.
        """

    @property
    def config(self):
        """Provide config data on self without making changes too easy.

        e.g.: self.config.debug (which is readable but not writable)
        """
        return self._config_proxy

    def default_wrapper(self, app):
        """Wrap the provided app with a default wrapper stack.

        Override this to change which wrappers are applied when the user
        does not ask for a specific wrapper or no-wrapper.
        """
        app = cached_assets(self.asset_cache)(app)
        # incorporate the status middleware in case user expressed an
        # interest and did not specify own wrappers/nowrappers
        if self.status_handlers:
            app = status_handlers(self.status_handlers)(app)
        return app

    def __call__(self, environ, start_response):
        """Conventional WSGI entry point to deployed instance.

        Using __call__ here is to reduce user friction from awkwardness like
        remembering to pass bundle.dispatcher to the server.
        """
        # Call the dispatch root of the encapsulated stuff
        # kept in self.root rather than ad hoc
        # and rather than always creating Dispatcher
        iterable = self.root(environ, start_response)
        assert iterable, "Bundle root returned nothing"
        return iterable
