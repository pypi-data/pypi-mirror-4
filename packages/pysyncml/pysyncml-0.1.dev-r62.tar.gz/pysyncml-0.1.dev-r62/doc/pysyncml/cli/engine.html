

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementing a SyncML Command-Line Interface &mdash; pysyncml 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/theme_extras.js"></script>
    <link rel="top" title="pysyncml 0.1 documentation" href="../../index.html" />
    <link rel="next" title="Sample Implementation: sync-notes" href="notes.html" />
    <link rel="prev" title="Command-Line Programs" href="index.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../index.html">
          <span>pysyncml 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>Implementing a SyncML Command-Line Interface</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="index.html">Command-Line Programs</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="notes.html">Sample Implementation: sync-notes</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="implementing-a-syncml-command-line-interface">
<h1><a class="toc-backref" href="#id1">Implementing a SyncML Command-Line Interface</a><a class="headerlink" href="#implementing-a-syncml-command-line-interface" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#implementing-a-syncml-command-line-interface" id="id1">Implementing a SyncML Command-Line Interface</a><ul>
<li><a class="reference internal" href="#overview" id="id2">Overview</a></li>
<li><a class="reference internal" href="#subclass-a-syncengine" id="id3">Subclass a SyncEngine</a></li>
<li><a class="reference internal" href="#implement-an-agent" id="id4">Implement an Agent</a></li>
<li><a class="reference internal" href="#launch-the-syncengine" id="id5">Launch the SyncEngine</a></li>
<li><a class="reference internal" href="#example-implementation" id="id6">Example Implementation</a></li>
</ul>
</li>
</ul>
</div>
<p>Although implementing a command-line SyncML peer with pysyncml is no
different than implementing any other pysyncml client and/or server,
the <cite>pysyncml.cli</cite> module provides some helper classes that simplify
the task significantly for command-line interfaces. Specifically, the
<cite>pysyncml.cli.CommandLineSyncEngine</cite> class provides the following
functionality out-of-the-box:</p>
<ul class="simple">
<li>Basic data storage/model configuration and setup.</li>
<li>Simple single-user server implementation.</li>
<li>Common command-line option setup, parsing and usage, including:<ul>
<li>verbosity control,</li>
<li>help, configuration, and pending changes display,</li>
<li>device ID, name and label control,</li>
<li>remote URL/URI and username/password setting,</li>
<li>synchronization type, client and server modes control,</li>
<li>configuration name and location control.</li>
</ul>
</li>
</ul>
<p>Using the SyncEngine currently does imply some limitations, including:</p>
<ul class="simple">
<li>Only a single local datastore can be synchronized at a time.</li>
</ul>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id2">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>To implement a command-line program using the helper classes in
<cite>pysyncml.cli</cite>, you generally use one of the following approaches:</p>
<ul>
<li><p class="first"><strong>Directory based approach</strong>:</p>
<p>With this approach, the items being synchronized are stored in a
directory, and different directories can have different application
and synchronization profiles. This de-centralized method allows the
user to have multiple directories that represent &#8220;units of content&#8221;;
the directory can be moved around as long as it and all of its
contents remains together and intact.</p>
<p>This approach is implemented by subclassing
<a class="reference internal" href="base.html#pysyncml.cli.base.DirectorySyncEngine" title="pysyncml.cli.base.DirectorySyncEngine"><tt class="xref py py-class docutils literal"><span class="pre">pysyncml.cli.DirectorySyncEngine</span></tt></a>.</p>
</li>
<li><p class="first"><strong>Local-user based approach</strong>:</p>
<p>A more centralized approach, where the items being synchronized are
stored in some host-local per-user location that may or may not be a
file-based location. In this case, the user must specifically
request a different configuration in order to choose a different
synchronization profile. For example, this could be used when
synchronizing the settings of another application that are stored in
a pre-defined user-specific directory, such as
&#8220;~/.config/libreoffice&#8221;.</p>
<p>This approach is implemented by subclassing
<tt class="xref py py-class docutils literal"><span class="pre">pysyncml.cli.LocalUserSyncEngine</span></tt>.</p>
</li>
</ul>
<p>Once the right approach is found, then the following steps are required:</p>
<ol class="arabic">
<li><p class="first"><a class="reference internal" href="#extend"><em>Subclass a SyncEngine</em></a>:</p>
<p>Subclass the appropriate <cite>SyncEngine</cite> implementation and add any
relevant hooks.</p>
</li>
<li><p class="first"><a class="reference internal" href="#agent"><em>Implement an Agent</em></a>:</p>
<p>Provide a <a class="reference internal" href="../agents/index.html#pysyncml.agents.base.Agent" title="pysyncml.agents.base.Agent"><tt class="xref py py-class docutils literal"><span class="pre">pysyncml.Agent</span></tt></a>
implementation, which primarily exposes CRUD access to your data.</p>
</li>
<li><p class="first"><a class="reference internal" href="#invoke"><em>Launch the SyncEngine</em></a>:</p>
<p>Invoke your <cite>SyncEngine</cite>&#8216;s <cite>run()</cite> method and tie in execution
entrypoints.</p>
</li>
</ol>
</div>
<div class="section" id="subclass-a-syncengine">
<span id="extend"></span><h2><a class="toc-backref" href="#id3">Subclass a SyncEngine</a><a class="headerlink" href="#subclass-a-syncengine" title="Permalink to this headline">¶</a></h2>
<p>The base class <cite>CommandLineSyncEngine</cite> constructor accepts several
parameters which control the profile of the SyncML adapter. These
parameters are typically only used as <em>default</em> parameters, when
they cannot be loaded from a previous call to the engine.</p>
<p>The following example illustrates a typical subclass of the
directory-based approach:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sqlalchemy</span> <span class="kn">as</span> <span class="nn">sa</span>
<span class="kn">import</span> <span class="nn">pysyncml</span>
<span class="kn">import</span> <span class="nn">pysyncml.cli</span>

<span class="k">class</span> <span class="nc">MySyncEngine</span><span class="p">(</span><span class="n">pysyncml</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">DirectorySyncEngine</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">NotesEngine</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
      <span class="n">appLabel</span>          <span class="o">=</span> <span class="s">&#39;...&#39;</span><span class="p">,</span>           <span class="c"># a short label used to identify this program</span>
      <span class="n">appDisplay</span>        <span class="o">=</span> <span class="s">&#39;...&#39;</span><span class="p">,</span>           <span class="c"># a user-friendly title of this program</span>
      <span class="n">devinfoParams</span>     <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">...</span><span class="p">),</span>       <span class="c"># default local device information</span>
      <span class="n">storeParams</span>       <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="o">...</span><span class="p">),</span>       <span class="c"># default local datastore information</span>
      <span class="n">agent</span>             <span class="o">=</span> <span class="n">MyAgent</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>   <span class="c"># a reference to the local Agent</span>
      <span class="p">)</span>

  <span class="nd">@pysyncml.cli.hook</span><span class="p">(</span><span class="s">&#39;model.setup.extend&#39;</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_createDataItemModel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c"># extend the self.model to include any persistent data objects that</span>
    <span class="c"># this engine requires to maintain state, using the self.model.DatabaseObject</span>
    <span class="c"># SQLAlchemy declarative_base class as a base class. an example:</span>
    <span class="k">class</span> <span class="nc">MyDataItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">DatabaseObject</span><span class="p">):</span>
      <span class="c"># NOTE: an `id` attribute (a UUID string) is provided by the ORM</span>
      <span class="n">data</span> <span class="o">=</span> <span class="n">sa</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">sa</span><span class="o">.</span><span class="n">Text</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">MyDataItem</span> <span class="o">=</span> <span class="n">MyDataItem</span>

  <span class="nd">@pysyncml.cli.hook</span><span class="p">(</span><span class="s">&#39;adapter.create.store&#39;</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_scanDataItems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">adapter</span><span class="p">,</span> <span class="n">store</span><span class="p">):</span>
    <span class="c"># adding a hook to when the pysyncml store is created to detect changes</span>
    <span class="c"># in the local datastore and register them on the store, for example:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">agent</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
</pre></div>
</div>
<p>The following table details all the hooks that are available and when
they are called. In general, they fall into one of four categories:</p>
<ul>
<li><p class="first"><cite>options.setup</cite>:</p>
<p>These are called once during program initialization to setup the
options that this program can accept on the command line.</p>
</li>
<li><p class="first"><cite>options.parse</cite>:</p>
<p>These are called once during program start-up to parse the options
specified on the command line and to do preliminary SyncEngine
configuration. The options are actually parsed twice: once to
determine the data directory, and a second time within the context
of the data directory.</p>
</li>
<li><p class="first"><cite>options.persist</cite>:</p>
<p>These hooks are called to affect the serialization and
de-serialization of options to the data directory so that
appropriate data defaults can be persisted.</p>
</li>
<li><p class="first"><cite>model.setup</cite>:</p>
<p>These are called once after program start-up to configure the
program&#8217;s data model, check the integrity of the database and any
schema versioning, and apply any data migrations if needed.</p>
<p>TODO: integrity checking, schema versioning and data migrations are
not implemented yet.</p>
</li>
<li><p class="first"><cite>adapter.create</cite>:</p>
<p>These are called any time the SyncEngine needs a SyncML Adapter.
Generally speaking, in client-mode they will be called once when
starting the transaction with a remote peer and in server-mode, they
will be called for every request from the client (note that there
will be multiple requests were synchronization session).</p>
</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="27%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Hook</th>
<th class="head">Parameters</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>options.setup.init</td>
<td>(none)</td>
<td>Called when the ArgumentParser has
been created (and stored in
<tt class="docutils literal"><span class="pre">self.parser</span></tt>), but no options
have been added yet.</td>
</tr>
<tr class="row-odd"><td>options.setup.generic</td>
<td>(none)</td>
<td>Called after common command-line
options have been added (such as
<tt class="docutils literal"><span class="pre">--verbose</span></tt>), but before
SyncEngine specific options have
been added to <tt class="docutils literal"><span class="pre">self.parser</span></tt>
(such as <tt class="docutils literal"><span class="pre">--remote-uri</span></tt>).</td>
</tr>
<tr class="row-even"><td>options.setup.term</td>
<td>(none)</td>
<td>Called after all options have been
added to the ArgumentParser in
<tt class="docutils literal"><span class="pre">self.parser</span></tt>, but before the
options are parsed.</td>
</tr>
<tr class="row-odd"><td>options.parse.init</td>
<td>(none)</td>
<td>Called just before the ArgumentParser&#8217;s
<tt class="docutils literal"><span class="pre">parse_args()</span></tt> method is called for
the first time.</td>
</tr>
<tr class="row-even"><td>options.parse.datadir</td>
<td>(none)</td>
<td>Called immediately after the first
call to <tt class="docutils literal"><span class="pre">parse_args()</span></tt>, to establish
the data directory. The SyncEngine
expects <tt class="docutils literal"><span class="pre">self.dataDir</span></tt> to point
to a directory that can be used to
persist data to. Typically, this is
taken care of by an existing subclass
of <cite>CommandLineSyncEngine</cite>.</td>
</tr>
<tr class="row-odd"><td>options.parse.term</td>
<td>(none)</td>
<td>Called just after the ArgumentParser&#8217;s
<tt class="docutils literal"><span class="pre">parse_args()</span></tt> method is called,
and before the logging is configured
as specified in the command-line
options. The results of the parse
are available in <tt class="docutils literal"><span class="pre">self.options</span></tt>
(parameters) and in <tt class="docutils literal"><span class="pre">self.args</span></tt>
(arguments).</td>
</tr>
<tr class="row-even"><td>options.persist.load</td>
<td>option-dictionary</td>
<td>Called after the first call to
<tt class="docutils literal"><span class="pre">parse_args()</span></tt> and after any persisted
values stored in the passed-in dictionary
have been applied to the parser. This
hook can then do any &#8220;clean-up&#8221; if
necessary.</td>
</tr>
<tr class="row-odd"><td>options.persist.save</td>
<td>option-dictionary</td>
<td>Called after all options have been
processed and all <cite>options.parse.*</cite>
hooks have been called. The passed-in
dictionary should be modified to store
any key-value pairs that, upon
deserialization, will be provided to
<tt class="docutils literal"><span class="pre">self.parser.set_defaults()</span></tt>.</td>
</tr>
<tr class="row-even"><td>model.setup.init</td>
<td>(none)</td>
<td>Called after logging is setup, the
database backend engine has been
created (and stored in
<tt class="docutils literal"><span class="pre">self.dbengine</span></tt>), and the database
session is created (and stored in
<tt class="docutils literal"><span class="pre">self.dbsession</span></tt>), but before the
any models or database objects are
created.</td>
</tr>
<tr class="row-odd"><td>model.setup.extend</td>
<td>(none)</td>
<td>Called after the SyncEngine data
model has been created (and stored
in <tt class="docutils literal"><span class="pre">self.model</span></tt>), but before any
tables are created (if needed) or
model versions are checked. This is
the most common hook to bind to:
this is where the application will
add any models that it needs to
manage the datastore state.</td>
</tr>
<tr class="row-even"><td>model.setup.term</td>
<td>(none)</td>
<td>Called after the database integrity
is checked, model versions are
checked and any data migrations are
applied.</td>
</tr>
<tr class="row-odd"><td>adapter.create.init</td>
<td>(none)</td>
<td>Called when a SyncEngine needs an
Adapter, but before anything is
actually done.</td>
</tr>
<tr class="row-even"><td>adapter.create.context</td>
<td>context</td>
<td>Called after a <cite>pysyncml.Context</cite>
object is created. Note that the
context is never made into an
attribute of <tt class="docutils literal"><span class="pre">self</span></tt>, and is why
it is passed in as a parameter to
the hook function.</td>
</tr>
<tr class="row-odd"><td>adapter.create.adapter</td>
<td>context, adapter</td>
<td>Called after a <cite>context.Adapter</cite>
is either loaded from the database
or initialized based on the command
line options. Both the context and
the resulting adapter are provided
as hook parameters.</td>
</tr>
<tr class="row-even"><td>adapter.create.peer</td>
<td>context, adapter, peer</td>
<td>Called after the remote peer is
loaded from the database or
initialized based on the command
line options. Note that this hook
will <em>only</em> be called when running
in client-mode.</td>
</tr>
<tr class="row-odd"><td>adapter.create.store</td>
<td>context, adapter, store</td>
<td>Called after the <cite>self.model.Store</cite>
is loaded from the database or
initialized based on the command
line options. This hook is
typically used to then scan for
changes in the local datastore and
register them to the <cite>Store</cite>. This
will be called before any local
pending changes are reported to
the user (if requested).</td>
</tr>
<tr class="row-even"><td>adapter.create.term</td>
<td>context, adapter</td>
<td>Called after the context, adapter,
peer, and store are completely
ready for synchronization, but
before they are passed back to
the SyncEngine for consumption.</td>
</tr>
<tr class="row-odd"><td>describe</td>
<td>stream</td>
<td>Called when a <cite>describe</cite> operation
is requested. This is called after
the engine and adapters have displayed
their configuration description. The
<cite>stream</cite> is a file-like object where
program-specific descriptions should
be sent to via <tt class="docutils literal"><span class="pre">stream.write(...)</span></tt>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="implement-an-agent">
<span id="agent"></span><h2><a class="toc-backref" href="#id4">Implement an Agent</a><a class="headerlink" href="#implement-an-agent" title="Permalink to this headline">¶</a></h2>
<p>The <cite>pysyncml.Agent</cite> provides the binding between the pysyncml SyncML
synchronization engine and your data. As pysyncml treats your data as
opaque objects, you need to implement all CRUD operations and a
limited set of other optional functions (especially when handling
hierarchical data).</p>
<p>A stripped-down minimal API with typical functionality follows &#8212; see
<a class="reference internal" href="../agents/index.html"><em>Module: pysyncml.agents</em></a> for details:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pysyncml</span>

<span class="k">class</span> <span class="nc">MyAgent</span><span class="p">(</span><span class="n">pysyncml</span><span class="o">.</span><span class="n">Agent</span><span class="p">):</span>

  <span class="c"># An agent must declare what content types it can de/serialize,</span>
  <span class="c"># which must be a list of pysyncml.ContentTypeInfo objects.</span>
  <span class="n">contentTypes</span> <span class="o">=</span> <span class="p">[</span> <span class="n">pysyncml</span><span class="o">.</span><span class="n">ContentTypeInfo</span><span class="p">(</span><span class="s">&#39;text/plain&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">preferred</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="p">]</span>

  <span class="c"># The above MySyncEngine called the Agent constructor with itself</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">MyAgent</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">engine</span>

  <span class="c"># An agent must be able to serialize and deserialize items</span>
  <span class="k">def</span> <span class="nf">dumpItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># Usually, just invokes the item&#39;s dump method (if it has one):</span>
    <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">loadItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># Usually, just invokes the item&#39;s load method (if it has one):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">MyDataItem</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>

  <span class="c"># An agent must be able to list, add, fetch, modify and delete items</span>
  <span class="k">def</span> <span class="nf">getAllItems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">addItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">getItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itemID</span><span class="p">):</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">replaceItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">reportChanges</span><span class="p">):</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">deleteItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itemID</span><span class="p">):</span> <span class="o">...</span>

  <span class="c"># If an agent will also support matching, merging and conflict resolution</span>
  <span class="c"># (only used when run as server), then it must also implement mergeItems,</span>
  <span class="c"># and optionally matchItems (to make it more efficient than the default</span>
  <span class="c"># implementation).</span>
  <span class="k">def</span> <span class="nf">mergeItems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">localItem</span><span class="p">,</span> <span class="n">remoteItem</span><span class="p">,</span> <span class="n">changeSpec</span><span class="p">):</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">matchItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="launch-the-syncengine">
<span id="invoke"></span><h2><a class="toc-backref" href="#id5">Launch the SyncEngine</a><a class="headerlink" href="#launch-the-syncengine" title="Permalink to this headline">¶</a></h2>
<p>This is the easy part... cut-n-paste the following to make your python
file executable as well as providing a <tt class="docutils literal"><span class="pre">main</span></tt> entrypoint (which can
be used in the <tt class="docutils literal"><span class="pre">entry_points</span></tt> definition of your <tt class="docutils literal"><span class="pre">setup.py</span></tt>
file):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
  <span class="n">engine</span> <span class="o">=</span> <span class="n">MySyncEngine</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">engine</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="section" id="example-implementation">
<h2><a class="toc-backref" href="#id6">Example Implementation</a><a class="headerlink" href="#example-implementation" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="notes.html"><em>Sample Implementation: sync-notes</em></a> for an example of a real-world program provided by
the pysyncml package that uses the <cite>pysyncml.cli</cite> functionality.</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="index.html">Command-Line Programs</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="notes.html">Sample Implementation: sync-notes</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012-2012, UberDev, No Rights Reserved.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>