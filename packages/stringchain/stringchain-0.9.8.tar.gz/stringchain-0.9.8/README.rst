

=======================================================================================
 StringChain—efficient management of strings which are produced and consumed in chunks
=======================================================================================

PyPI:

https://pypi.python.org/pypi/stringchain

trac:

https://tahoe-lafs.org/trac/stringchain

darcs repository:

https://tahoe-lafs.org/source/stringchain/trunk/

To run tests:

python ./setup.py test

To run benchmarks:

python -OOu -c 'from stringchain.bench import bench; bench.quick_bench()'


Rationale
=========

Sometimes you want to accumulate data while occasionally consuming some of
the first bytes of the data. The naïve way to do it in Python is like this::

 class Stringy:
     def __init__(self):
         self.accum = '' # Will hold all unprocessed bytes

     def add_data(self, some_more_data):
         # some_more_data is a string
         self.accum += some_more_data

     def consume_some(self, how_much):
         some = self.accum[:how_much]
         self.accum = self.accum[how_much:]

This works fine as long as the total amount of bytes accumulated and the
number of separate add_data() events stay small, but it has O(N²) behavior
and it slows down drastically if those things become large.

Another approach is like this::

 class SimplerStringChain:
     def __init__(self):
         self.accum = [] # Will hold all unprocessed bytes

     def add_data(self, some_more_data):
         # some_more_data is a string
         self.accum.append(some_more_data)

     def consume_some(self, how_much):
         ss = ''.join(self.accum)
         del self.accum[:]
         result = ss[:how_much]
         leftovers = ss[how_much:]
         self.accum.append(leftovers)
         return result

This works fine as long as the total amount of bytes accumulated *or* the
number of separate consume_some() events is small, but has O(N²) behavior and
has bad performance if both of those get large.

   *Note that a common use case is where there is only a single consumption event — you accumulate data until some moment when you consume all of the accumulated data at once. In this case the number of consumption events is 1, and for this use case the "SimplerStringChain" approach is fine. The "accumulate_then_one_gulp" benchmark below measures performance under that usage.*

StringChain avoids both of these problems. It holds a list (actually a
deque_) of strings, appends to that list when you add a new string, and pops
from the beginning of the list when you consume some data. (It might have to
pop only part of the leading string since you might not consume a number of
bytes exactly equal to the size of the string.)

.. _deque: http://docs.python.org/library/collections.html#collections.deque


The naive "Stringy" approach is slower than StringChain, and the bigger the
dataset, the slower it goes. StringChain is fast and also scalable.

Benchmarks are generated by running::

    python -OOu -c 'from stringchain.bench import bench; bench.quick_bench()'

The the left-hand column is how many bytes were in the test dataset. The
results are nanoseconds per byte processed in exponential (scientific)
notation.

(Hint: the exponent — the thing that comes after the "+" or "-" — is the
important part. If it says +00 then it took about 1 nanosecond per byte
processed, if it says +01 then it took about 10 nanoseconds, if it says +02
then it took about 100 nanoseconds, and if it says +03 then it took about
1000 nanoseconds.)

"Stringy" and "SimplerStringChain" are the approaches sketched above.

Here are the benchmarks under CPython 2.7.3 on an Intel Core 2 Duo CPU P8800
at 2.66 GHz.::

 $ python -OOu -c 'from stringchain.bench import bench; bench.slow_bench()'                                                                                           

 N is the total number of bytes produced and consumed; results are in nanoseconds per byte (scientific notation)

 impl:  StringChain
 task:  accumulate_then_one_gulp
 N:    4000000 best: 3.412e-01,   3th-best: 3.428e-01, mean: 3.689e-01,   3th-worst: 3.873e-01, worst: 4.872e-01 (of     10)
 N:    8000000 best: 3.499e-01,   3th-best: 3.518e-01, mean: 3.561e-01,   3th-worst: 3.577e-01, worst: 3.690e-01 (of     10)
 N:   16000000 best: 3.563e-01,   3th-best: 3.569e-01, mean: 3.616e-01,   3th-worst: 3.615e-01, worst: 3.859e-01 (of     10)
 N:   32000000 best: 3.578e-01,   3th-best: 3.587e-01, mean: 3.602e-01,   3th-worst: 3.617e-01, worst: 3.620e-01 (of     10)
 task:  accumulate_then_many_gulps
 N:    4000000 best: 2.191e+00,   3th-best: 2.196e+00, mean: 2.218e+00,   3th-worst: 2.247e+00, worst: 2.256e+00 (of     10)
 N:    8000000 best: 2.180e+00,   3th-best: 2.188e+00, mean: 2.212e+00,   3th-worst: 2.249e+00, worst: 2.268e+00 (of     10)
 N:   16000000 best: 2.184e+00,   3th-best: 2.185e+00, mean: 2.198e+00,   3th-worst: 2.217e+00, worst: 2.235e+00 (of     10)
 N:   32000000 best: 2.182e+00,   3th-best: 2.187e+00, mean: 2.203e+00,   3th-worst: 2.227e+00, worst: 2.232e+00 (of     10)
 task:  produce_and_consume
 N:    4000000 best: 2.430e+00,   3th-best: 2.436e+00, mean: 2.474e+00,   3th-worst: 2.500e+00, worst: 2.503e+00 (of     10)
 N:    8000000 best: 2.385e+00,   3th-best: 2.385e+00, mean: 2.408e+00,   3th-worst: 2.430e+00, worst: 2.432e+00 (of     10)
 N:   16000000 best: 2.339e+00,   3th-best: 2.352e+00, mean: 2.380e+00,   3th-worst: 2.405e+00, worst: 2.413e+00 (of     10)
 N:   32000000 best: 2.343e+00,   3th-best: 2.348e+00, mean: 2.383e+00,   3th-worst: 2.406e+00, worst: 2.410e+00 (of     10)

 impl:  SimplerStringChain
 task:  accumulate_then_one_gulp
 N:    4000000 best: 9.402e-01,   3th-best: 9.425e-01, mean: 1.001e+00,   3th-worst: 1.113e+00, worst: 1.119e+00 (of     10)
 N:    8000000 best: 9.502e-01,   3th-best: 9.555e-01, mean: 9.888e-01,   3th-worst: 1.056e+00, worst: 1.137e+00 (of     10)
 N:   16000000 best: 9.549e-01,   3th-best: 9.619e-01, mean: 9.886e-01,   3th-worst: 1.051e+00, worst: 1.125e+00 (of     10)
 N:   32000000 best: 9.613e-01,   3th-best: 9.621e-01, mean: 9.938e-01,   3th-worst: 1.050e+00, worst: 1.132e+00 (of     10)
 task:  accumulate_then_many_gulps
 N:    4000000 best: 1.366e+03,   3th-best: 1.366e+03, mean: 1.368e+03,   3th-worst: 1.372e+03, worst: 1.372e+03 (of     10)
 N:    8000000 best: 2.777e+03,   1th-best: 2.777e+03, mean: 2.777e+03,   1th-worst: 2.777e+03, worst: 2.777e+03 (of      3)
 N:   16000000 best: 5.547e+03,   1th-best: 5.547e+03, mean: 5.547e+03,   1th-worst: 5.547e+03, worst: 5.547e+03 (of      1)
 N:   32000000 best: 2.810e+04,   1th-best: 2.810e+04, mean: 2.810e+04,   1th-worst: 2.810e+04, worst: 2.810e+04 (of      1)
 task:  produce_and_consume
 N:    4000000 best: 3.388e+02,   3th-best: 3.392e+02, mean: 3.396e+02,   3th-worst: 3.398e+02, worst: 3.411e+02 (of     10)
 N:    8000000 best: 7.537e+02,   3th-best: 7.537e+02, mean: 7.547e+02,   3th-worst: 7.558e+02, worst: 7.576e+02 (of      9)
 N:   16000000 best: 1.569e+03,   1th-best: 1.569e+03, mean: 1.570e+03,   1th-worst: 1.571e+03, worst: 1.571e+03 (of      3)
 N:   32000000 best: 3.153e+03,   1th-best: 3.153e+03, mean: 3.153e+03,   1th-worst: 3.153e+03, worst: 3.153e+03 (of      1)

 impl:  Stringy
 task:  accumulate_then_one_gulp
 N:    4000000 best: 3.695e+02,   3th-best: 3.696e+02, mean: 3.700e+02,   3th-worst: 3.705e+02, worst: 3.711e+02 (of     10)
 N:    8000000 best: 7.536e+02,   3th-best: 7.536e+02, mean: 7.546e+02,   3th-worst: 7.559e+02, worst: 7.561e+02 (of      9)
 N:   16000000 best: 1.525e+03,   1th-best: 1.525e+03, mean: 1.525e+03,   1th-worst: 1.525e+03, worst: 1.525e+03 (of      3)
 N:   32000000 best: 3.057e+03,   1th-best: 3.057e+03, mean: 3.057e+03,   1th-worst: 3.057e+03, worst: 3.057e+03 (of      1)
 task:  accumulate_then_many_gulps
 N:    4000000 best: 2.493e+03,   2th-best: 2.493e+03, mean: 2.497e+03,   2th-worst: 2.502e+03, worst: 2.502e+03 (of      6)
 N:    8000000 best: 5.057e+03,   1th-best: 5.057e+03, mean: 5.059e+03,   1th-worst: 5.061e+03, worst: 5.061e+03 (of      2)
 N:   16000000 best: 1.015e+04,   1th-best: 1.015e+04, mean: 1.015e+04,   1th-worst: 1.015e+04, worst: 1.015e+04 (of      1)
 N:   32000000 best: 5.278e+04,   1th-best: 5.278e+04, mean: 5.278e+04,   1th-worst: 5.278e+04, worst: 5.278e+04 (of      1)
 task:  produce_and_consume
 N:    4000000 best: 3.372e+02,   3th-best: 3.373e+02, mean: 3.378e+02,   3th-worst: 3.380e+02, worst: 3.407e+02 (of     10)
 N:    8000000 best: 7.515e+02,   3th-best: 7.515e+02, mean: 7.525e+02,   3th-worst: 7.541e+02, worst: 7.542e+02 (of      9)
 N:   16000000 best: 1.566e+03,   1th-best: 1.566e+03, mean: 1.567e+03,   1th-worst: 1.568e+03, worst: 1.568e+03 (of      3)
 N:   32000000 best: 3.149e+03,   1th-best: 3.149e+03, mean: 3.149e+03,   1th-worst: 3.149e+03, worst: 3.149e+03 (of      1)

 nanoseconds per byte produced and consumed


Here are benchmarks under PyPy 1.9dev0 on the same machine::

 $ pypy -OOu -c 'from stringchain.bench import bench; bench.slow_bench()'

 N is the total number of bytes produced and consumed; results are in nanoseconds per byte (scientific notation)

 impl:  StringChain
 task:  accumulate_then_one_gulp
 N:    4000000 best: 4.047e-02,   3th-best: 5.352e-02, mean: 3.423e-01,   3th-worst: 7.548e-01, worst: 1.408e+00 (of     10)
 N:    8000000 best: 4.011e-02,   3th-best: 4.151e-02, mean: 7.450e-02,   3th-worst: 4.676e-02, worst: 3.532e-01 (of     10)
 N:   16000000 best: 3.974e-02,   3th-best: 4.025e-02, mean: 4.254e-02,   3th-worst: 4.619e-02, worst: 4.819e-02 (of     10)
 N:   32000000 best: 3.778e-02,   3th-best: 3.794e-02, mean: 4.069e-02,   3th-worst: 3.912e-02, worst: 6.025e-02 (of     10)
 task:  accumulate_then_many_gulps
 N:    4000000 best: 1.348e+00,   3th-best: 1.467e+00, mean: 3.436e+00,   3th-worst: 5.982e+00, worst: 1.122e+01 (of     10)
 N:    8000000 best: 1.073e+00,   3th-best: 1.117e+00, mean: 1.328e+00,   3th-worst: 1.754e+00, worst: 1.767e+00 (of     10)
 N:   16000000 best: 1.002e+00,   3th-best: 1.038e+00, mean: 1.168e+00,   3th-worst: 1.302e+00, worst: 1.653e+00 (of     10)
 N:   32000000 best: 9.992e-01,   3th-best: 1.005e+00, mean: 1.054e+00,   3th-worst: 1.093e+00, worst: 1.095e+00 (of     10)
 task:  produce_and_consume
 N:    4000000 best: 1.317e+00,   3th-best: 1.428e+00, mean: 3.153e+00,   3th-worst: 3.596e+00, worst: 1.301e+01 (of     10)
 N:    8000000 best: 1.181e+00,   3th-best: 1.195e+00, mean: 1.666e+00,   3th-worst: 2.429e+00, worst: 2.554e+00 (of     10)
 N:   16000000 best: 1.171e+00,   3th-best: 1.182e+00, mean: 1.315e+00,   3th-worst: 1.437e+00, worst: 1.690e+00 (of     10)
 N:   32000000 best: 1.061e+00,   3th-best: 1.066e+00, mean: 1.118e+00,   3th-worst: 1.133e+00, worst: 1.222e+00 (of     10)

 impl:  SimplerStringChain
 task:  accumulate_then_one_gulp
 N:    4000000 best: 8.540e-01,   3th-best: 8.572e-01, mean: 1.436e+00,   3th-worst: 3.045e+00, worst: 3.106e+00 (of     10)
 N:    8000000 best: 9.286e-01,   3th-best: 1.985e+00, mean: 1.899e+00,   3th-worst: 1.999e+00, worst: 2.128e+00 (of     10)
 N:   16000000 best: 1.519e+00,   3th-best: 1.526e+00, mean: 1.646e+00,   3th-worst: 2.042e+00, worst: 2.171e+00 (of     10)
 N:   32000000 best: 1.269e+00,   3th-best: 1.271e+00, mean: 1.379e+00,   3th-worst: 1.719e+00, worst: 1.881e+00 (of     10)
 task:  accumulate_then_many_gulps
 N:    4000000 best: 3.751e+03,   2th-best: 3.751e+03, mean: 3.761e+03,   2th-worst: 3.772e+03, worst: 3.772e+03 (of      4)
 N:    8000000 best: 5.975e+03,   1th-best: 5.975e+03, mean: 5.982e+03,   1th-worst: 5.988e+03, worst: 5.988e+03 (of      2)
 N:   16000000 best: 1.018e+04,   1th-best: 1.018e+04, mean: 1.018e+04,   1th-worst: 1.018e+04, worst: 1.018e+04 (of      1)
 N:   32000000 best: 2.772e+04,   1th-best: 2.772e+04, mean: 2.772e+04,   1th-worst: 2.772e+04, worst: 2.772e+04 (of      1)
 task:  produce_and_consume
 N:    4000000 best: 9.741e+02,   3th-best: 9.749e+02, mean: 9.762e+02,   3th-worst: 9.801e+02, worst: 9.804e+02 (of     10)
 N:    8000000 best: 2.127e+03,   2th-best: 2.127e+03, mean: 2.129e+03,   2th-worst: 2.131e+03, worst: 2.131e+03 (of      4)
 N:   16000000 best: 3.675e+03,   1th-best: 3.675e+03, mean: 3.675e+03,   1th-worst: 3.675e+03, worst: 3.675e+03 (of      1)
 N:   32000000 best: 6.301e+03,   1th-best: 6.301e+03, mean: 6.301e+03,   1th-worst: 6.301e+03, worst: 6.301e+03 (of      1)

 impl:  Stringy
 task:  accumulate_then_one_gulp
 N:    4000000 best: 9.509e+02,   3th-best: 9.513e+02, mean: 9.536e+02,   3th-worst: 9.576e+02, worst: 9.577e+02 (of     10)
 N:    8000000 best: 1.974e+03,   2th-best: 1.974e+03, mean: 1.975e+03,   2th-worst: 1.976e+03, worst: 1.976e+03 (of      4)
 N:   16000000 best: 3.326e+03,   1th-best: 3.326e+03, mean: 3.326e+03,   1th-worst: 3.326e+03, worst: 3.326e+03 (of      2)
 N:   32000000 best: 5.818e+03,   1th-best: 5.818e+03, mean: 5.818e+03,   1th-worst: 5.818e+03, worst: 5.818e+03 (of      1)
 task:  accumulate_then_many_gulps
 N:    4000000 best: 6.880e+03,   1th-best: 6.880e+03, mean: 6.884e+03,   1th-worst: 6.889e+03, worst: 6.889e+03 (of      2)
 N:    8000000 best: 1.124e+04,   1th-best: 1.124e+04, mean: 1.124e+04,   1th-worst: 1.124e+04, worst: 1.124e+04 (of      1)
 N:   16000000 best: 1.904e+04,   1th-best: 1.904e+04, mean: 1.904e+04,   1th-worst: 1.904e+04, worst: 1.904e+04 (of      1)
 N:   32000000 best: 6.820e+04,   1th-best: 6.820e+04, mean: 6.820e+04,   1th-worst: 6.820e+04, worst: 6.820e+04 (of      1)
 task:  produce_and_consume
 N:    4000000 best: 9.787e+02,   3th-best: 9.792e+02, mean: 9.809e+02,   3th-worst: 9.851e+02, worst: 9.870e+02 (of     10)
 N:    8000000 best: 2.135e+03,   2th-best: 2.135e+03, mean: 2.135e+03,   2th-worst: 2.136e+03, worst: 2.136e+03 (of      4)
 N:   16000000 best: 3.683e+03,   1th-best: 3.683e+03, mean: 3.683e+03,   1th-worst: 3.683e+03, worst: 3.683e+03 (of      1)
 N:   32000000 best: 6.306e+03,   1th-best: 6.306e+03, mean: 6.306e+03,   1th-worst: 6.306e+03, worst: 6.306e+03 (of      1)

 nanoseconds per byte produced and consumed


Okay how do you use it? It offers a simple API -- read stringchain.py and let
me know if that interface doesn't fit your use case.

It has unit tests. It is written in pure Python (it uses collections.deque
and string).


LICENCE

You may use this package under the GNU General Public License, version 2 or, at
your option, any later version.  You may use this package under the Transitive
Grace Period Public Licence, version 1.0, or at your option, any later version.
(You may choose to use this package under the terms of either licence, at your
option.)  See the file COPYING.GPL for the terms of the GNU General Public
License, version 2.  See the file COPYING.TGPPL.html for the terms of the
Transitive Grace Period Public Licence, version 1.0.
