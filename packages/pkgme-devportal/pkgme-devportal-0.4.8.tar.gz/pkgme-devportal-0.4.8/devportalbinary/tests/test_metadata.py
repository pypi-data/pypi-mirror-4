# Copyright 2011-2012 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

from cStringIO import StringIO
import json
import os

from fixtures import TempDir
from mock import patch

from pkgme.info_elements import (
    Architecture,
    BuildDepends,
    Description,
    Depends,
    Distribution,
    ExplicitCopyright,
    ExtraControlBinaryFields,
    ExtraFiles,
    ExtraFilesFromPaths,
    Homepage,
    License,
    Maintainer,
    PackageName,
    Version,
    )
from pkgme.package_files import (
    DEBIAN_DIR,
    )
from pkgme.testing import AreDesktopValuesFor
from testtools import (
    TestCase,
    )
from treeshape import (
    FileTree,
    from_rough_spec,
    )

from devportalbinary.metadata import (
    format_install_map,
    get_desktop_file,
    get_desktop_install_map,
    get_excluded_package_files,
    get_files_install_map,
    get_icon_install_map,
    get_icon_size_from_string,
    get_install_file,
    get_package_files,
    load_json,
    make_all_info_fn,
    make_want_fn,
    MetadataBackend,
    )
from devportalbinary.testing import (
    BackendTests,
    MetadataFixture,
    )


class DummyBackend(MetadataBackend):
    """Dummy implementations of MetadataBackend's abstract methods."""

    def get_architecture(self):
        return None

    def get_build_depends(self):
        return 'build_depends', self.metadata

    def get_depends(self):
        return 'depends', self.metadata

    def get_description(self):
        return 'description', self.metadata

    def get_executable(self, package_name):
        return 'executable:' + package_name

    @classmethod
    def want_with_metadata(self, path, metadata):
        return {'score': 20, 'reason': "I'm a dummy", 'metadata': metadata}


class TestLoadJson(TestCase):

    def test_load_json_all_fields(self):
        metadata = {
            'foo': self.getUniqueString(),
            'bar': self.getUniqueInteger(),
            }
        path = self.useFixture(MetadataFixture(metadata)).metadata_path
        found_metadata, err = load_json(path)
        self.assertEqual(metadata, found_metadata)
        self.assertEqual(None, err)

    def test_load_json_not_present(self):
        # load_json returns None and a description when the file is
        # missing
        filename = 'metdata.json'
        path = self.useFixture(FileTree({})).join(filename)
        found_metadata, err = load_json(path)
        self.assertEqual(None, found_metadata)
        self.assertEqual('No metadata file', err)

    def test_load_json_not_json(self):
        # load_json returns None and a description when the file
        # does not contain json
        filename = 'metdata.json'
        path = self.useFixture(FileTree({filename: {}})).join(filename)
        found_metadata, err = load_json(path)
        self.assertEqual(None, found_metadata)
        self.assertEqual('Metadata file is not valid JSON', err)


class MetadataTests(BackendTests):

    BACKEND = DummyBackend

    def setUp(self):
        super(MetadataTests, self).setUp()
        # mock this for all tests to ensure we do not slow down because
        # of network access
        patcher = patch(
            'devportalbinary.metadata.get_latest_stable_ubuntu_distroseries')
        mock_get_latest_distroseries = patcher.start()
        mock_get_latest_distroseries.return_value = 'foo'
        self.addCleanup(patcher.stop)

    def test_metadata_file(self):
        self.assertEqual('devportal-metadata.json', MetadataBackend.METADATA_FILE)

    def test_get_extra_files_install_file(self):
        # ExtraFiles includes an install file generated by get_install_file.
        package_name = self.getUniqueString()
        install_basedir = '/opt/%s' % package_name
        extra_mappings = get_desktop_install_map(package_name)
        metadata = {MetadataBackend.PACKAGE_NAME: package_name}
        backend = self.make_backend(metadata=metadata)
        backend.get_executable = lambda x: x
        extra_files = backend.get_extra_files(package_name)
        install_file = extra_files['debian/install']
        self.assertEqual(
            get_install_file(install_basedir, backend.path,
                extra_mappings=extra_mappings),
            install_file)

    def test_extra_files_install_file_with_icons(self):
        # ExtraFiles includes an install file generated by get_install_file.
        package_name = self.getUniqueString()
        install_basedir = '/opt/%s' % package_name
        metadata = self.make_metadata()
        metadata[MetadataBackend.ICONS] = {
            '48x48': 'foo/bar.png',
            '128x128': 'baz/qux.png',
            }
        backend = self.make_backend(metadata=metadata)
        backend.get_executable = lambda x: x
        extra_files = backend.get_extra_files(package_name)
        install_file = extra_files['debian/install']
        extra_mappings = get_desktop_install_map(package_name)
        def convert_icon_path(resolution, path):
            return (resolution,
                'debian/icons/{0}/{1}.png'.format(resolution, package_name))
        icon_map = dict([convert_icon_path(res, path)
            for res, path in metadata[MetadataBackend.ICONS].items()])
        extra_mappings += get_icon_install_map(icon_map)
        self.assertEqual(
            get_install_file(install_basedir, backend.path,
                extra_mappings=extra_mappings),
            install_file)

    def test_pick_closest_icon_resolution_for_size_mixed(self):
        backend = self.make_backend()
        # multiple mixed resolutions
        icons = {'128x128': 'baz/qux.png',
                 '32x32': 'baz/foo.png',
                 '64x64': 'baz/foobar.png',
                 }
        self.assertEqual(
            backend._pick_closest_icon_resolution_for_size(icons, "48x48"),
            "64x64")

    def test_pick_closest_icon_resoluton_for_size_only_smaller_sizes(self):
        backend = self.make_backend()
        # only smaller resolutions
        icons = {'32x32': 'baz/foo.png',
                 '16x16': 'baz/foo.png',
                 }
        self.assertEqual(
            backend._pick_closest_icon_resolution_for_size(icons, "48x48"),
            "32x32")

    @patch('devportalbinary.metadata.convert_icon')
    def test_ensure_required_icon_size(self, mock_convert_icon):
        """Test _ensure_required_icon_size adds the required icon size
           to the metadata.
        """
        metadata = self.make_metadata()
        metadata[MetadataBackend.ICONS] = {
            '128x128': 'baz/qux.png',
            '32x32': 'baz/foo.png',
            '64x64': 'baz/foobar.png',
            }
        backend = self.make_backend(metadata=metadata)
        backend._ensure_required_icon_size(backend.REQUIRED_ICON_SIZE)
        self.assertIn(backend.REQUIRED_ICON_SIZE, metadata[backend.ICONS])
        mock_convert_icon.assert_called_with('baz/foobar.png', '48x48')

    def test_extra_files_desktop_file(self):
        # ExtraFiles includes a desktop file, named after the package, that is
        # generated using get_desktop_file on the backend.
        package_name = self.getUniqueString()
        tagline = self.getUniqueString()
        categories = self.getUniqueString()
        metadata = self.make_metadata(
            package_name=package_name,
            tagline=tagline,
            categories=categories,
            )
        backend = self.make_backend(metadata=metadata)
        backend.get_executable = lambda x: 'executable:' + x
        expected_desktop_file = get_desktop_file(
            package_name, backend.get_application_name(),
            backend.get_executable(package_name),
            tagline=tagline, categories=categories,
            working_directory=backend._get_install_basedir(package_name),
            ).get_contents()
        extra_files = backend.get_extra_files(package_name)
        desktop = extra_files['debian/%s.desktop' % (package_name,)]
        self.assertEqual(expected_desktop_file, desktop)

    def test_desktop_file_icons(self):
        # If there are icons in the metadata then the desktop file specifies
        # the name of the icon, which we have hard-coded to be the package
        # name.
        metadata = self.make_metadata(icons={'48x48': 'foo/bar.png'})
        backend = self.make_backend(metadata=metadata)
        package_name = backend.get_package_name()
        backend.get_executable = lambda x: 'executable:' + x
        expected_desktop_file = get_desktop_file(
            package_name,
            backend.get_application_name(),
            backend.get_executable(package_name),
            icon=package_name,
            tagline=metadata[MetadataBackend.TAGLINE],
            working_directory=backend._get_install_basedir(package_name),
            ).get_contents()
        extra_files = backend.get_extra_files(package_name)
        desktop = extra_files['debian/%s.desktop' % (package_name,)]
        self.assertEqual(expected_desktop_file, desktop)

    def test_get_info_with_architecture(self):
        # get_info consults various methods on the backend class and uses
        # those to figure out the info to return.
        class Backend(DummyBackend):
            def get_architecture(self):
                return 'architecture'

        package_name = self.getUniqueString('package-name')
        metadata = self.make_metadata(package_name=package_name)
        backend = Backend(self.useFixture(TempDir()).path, metadata)
        info = backend.get_info()
        self.assertEqual(
            {Architecture: 'architecture',
             BuildDepends: ('build_depends', metadata),
             Depends: ('depends', metadata),
             Description: ('description', metadata),
             Distribution: 'foo',
             ExtraFiles: backend.get_extra_files(package_name),
             PackageName: package_name,
             License: "unknown",
            }, info)

    def test_get_info_without_architecture(self):
        # get_info consults various methods on the backend class and uses
        # those to figure out the info to return.  If get_architecture returns
        # None, then it is excluded from the info.
        package_name = self.getUniqueString('package-name')
        metadata = self.make_metadata(package_name=package_name)
        backend = DummyBackend(self.useFixture(TempDir()).path, metadata)
        info = backend.get_info()
        self.assertEqual(
            {BuildDepends: ('build_depends', metadata),
             Depends: ('depends', metadata),
             Description: ('description', metadata),
             Distribution: 'foo',
             ExtraFiles: backend.get_extra_files(package_name),
             PackageName: package_name,
             License: "unknown",
            }, info)

    def test_maintainer(self):
        metadata = self.make_metadata()
        maintainer = 'Dude <dude@example.com>'
        metadata[MetadataBackend.MAINTAINER] = maintainer
        backend = self.make_backend(metadata=metadata)
        self.assertEqual(maintainer, backend.get_info()[Maintainer])

    def test_copyright(self):
        metadata = self.make_metadata()
        backend = self.make_backend(metadata=metadata)
        info = backend.get_info()
        marker = object()
        self.assertIs(marker, info.get(ExplicitCopyright, marker))

    def test_homepage(self):
        metadata = self.make_metadata()
        homepage = 'http://www.pkgme-rocks.com/'
        metadata[MetadataBackend.HOMEPAGE] = homepage
        backend = self.make_backend(metadata=metadata)
        self.assertEqual(homepage, backend.get_info()[Homepage])

    def test_version(self):
        metadata = self.make_metadata()
        metadata[MetadataBackend.SUGGESTED_VERSION] = '0.1'
        backend = self.make_backend(metadata=metadata)
        self.assertEqual('0.1', backend.get_version())

    def test_version_in_info(self):
        metadata = self.make_metadata()
        metadata[MetadataBackend.SUGGESTED_VERSION] = '0.1'
        backend = self.make_backend(metadata=metadata)
        self.assertEqual(
            backend.get_version(),
            backend.get_info()[Version])

    def test_get_extra_files_from_paths_no_icons(self):
        metadata = self.make_metadata()
        backend = self.make_backend(metadata=metadata)
        package_name = backend.get_package_name()
        self.assertEqual(
            {},
            backend._get_extra_icon_files_from_paths(package_name))

    def test_get_extra_files_from_paths_icons(self):
        metadata = self.make_metadata()
        metadata[MetadataBackend.ICONS] = {
            '48x48': 'foo.png',
            '64x64': '/cat.svg',
            '92x92': '/icon',
            '128x128': '/bar/qux.png',
            }
        backend = self.make_backend(metadata=metadata)
        package_name = backend.get_package_name()
        foo = os.path.normpath(os.path.join(backend.path, 'foo.png'))
        self.assertEqual(
            {'debian/icons/48x48/%s.png' % (package_name,): foo,
             'debian/icons/64x64/%s.svg' % (package_name,): '/cat.svg',
             'debian/icons/92x92/%s' % (package_name,): '/icon',
             'debian/icons/128x128/%s.png' % (package_name,): '/bar/qux.png',
             },
            backend._get_extra_icon_files_from_paths(package_name))

    def test_get_extra_files_from_paths_in_info_if_icons(self):
        package_name = self.getUniqueString()
        metadata = self.make_metadata(package_name=package_name)
        metadata[MetadataBackend.ICONS] = {
            '48x48': '/foo/bar.png',
            '128x128': '/baz/qux.png',
            }
        backend = self.make_backend(metadata=metadata)
        self.assertEqual(
            backend.get_extra_files_from_paths(
                PackageName.clean(package_name)),
            backend.get_info()[ExtraFilesFromPaths])

    def test_get_extra_files_from_paths_lintian_override(self):
        metadata = self.make_metadata()
        backend = self.make_backend(metadata=metadata)
        package_name = backend.get_package_name()
        self.assertIn(
            'debian/%s.lintian-overrides' % package_name,
            backend.get_extra_files(package_name))

    def test_get_info_uses_cleaned_package_name(self):
        application_name = 'foo bar'
        expected_package_name = 'foobar'
        metadata = self.make_metadata(package_name=application_name)
        backend = self.make_backend(metadata=metadata)
        self.assertIn(
            'debian/%s.lintian-overrides' % expected_package_name,
            backend.get_info()[ExtraFiles])

    def test_license_field_not_in_mapping(self):
        metadata = self.make_metadata()
        license = 'not-standard-license-that-is-not-mapped'
        metadata[MetadataBackend.LICENSE] = license
        backend = self.make_backend(metadata=metadata)
        self.assertEqual(license, backend.get_info()[License])

    def test_license_field_mapping(self):
        metadata = self.make_metadata()
        license = 'Apache License'
        metadata[MetadataBackend.LICENSE] = license
        backend = self.make_backend(metadata=metadata)
        self.assertEqual('Apache-2.0', backend.get_info()[License])

    def test_get_extra_control_binary_fields(self):
        metadata = self.make_metadata()
        backend = self.make_backend(metadata=metadata)
        self.assertNotIn(ExtraControlBinaryFields, backend.get_info())

    def test_distribution(self):
        metadata = self.make_metadata()
        backend = self.make_backend(metadata=metadata)
        self.assertEqual('foo', backend.get_info()[Distribution])

    def test_want_with_no_metadata(self):
        # If there's no metadata file, we don't want it.
        path = self.useFixture(TempDir()).path
        self.assertEqual(
            {'score': 0, 'reason': 'No metadata file'},
            DummyBackend.want(path))

    def test_want_with_invalid_json(self):
        # If there's a metadata file, but it's not valid JSON, we don't want
        # it.
        path = self.useFixture(FileTree(from_rough_spec(
            [(MetadataBackend.METADATA_FILE, 'not valid json')]))).path
        self.assertEqual(
            {'score': 0, 'reason': 'Metadata file is not valid JSON'},
            DummyBackend.want(path))

    def test_want_with_valid_metadata(self):
        # If there's a metadata file containing valid JSON, we delegate to the
        # backend's want_with_metadata method.  See
        # DummyBackend.want_with_metadata.
        metadata = {'foo': 'bar'}
        path = self.useFixture(FileTree(from_rough_spec(
            [(MetadataBackend.METADATA_FILE, json.dumps(metadata))]))).path
        self.assertEqual(
            {'score': 20, 'reason': "I'm a dummy", 'metadata': metadata},
            DummyBackend.want(path))

    def test__get_install_basedir(self):
        backend = self.make_backend()
        package_name = self.getUniqueString()
        self.assertEqual('/opt/%s' % package_name,
                backend._get_install_basedir(package_name))


class DesktopFileTests(TestCase):

    def test_makes_desktop_file_with_given_values(self):
        package_name = self.getUniqueString()
        executable = self.getUniqueString()
        app_name = self.getUniqueString()
        tagline = self.getUniqueString()
        categories = ['cat1', 'cat2']
        icon = self.getUniqueString()
        working_directory = self.getUniqueString()
        desktop_file = get_desktop_file(
            package_name, app_name, executable, tagline=tagline,
            categories=categories, icon=icon,
            working_directory=working_directory)
        self.assertThat(
            {'Name': app_name, 'Comment': tagline, 'Categories': 'cat1;cat2;',
             'Exec': executable, 'Icon': icon, 'Path': working_directory},
            AreDesktopValuesFor(desktop_file))


class InstallFileTests(TestCase):

    def test_format_install_map(self):
        # format_install_map takes an install map and returns the
        # contents of a correctly formatted install file.
        install = format_install_map([('foo', 'bar'), ('baz', 'qux')])
        self.assertEqual('baz qux\nfoo bar\n', install)

    def test_install_map(self):
        # The install file instructs debhelper to copy everything in the
        # top-level to /opt/<package-name>.
        path = self.useFixture(FileTree({'some-file': {}})).path
        install_basedir = '/opt/package-name'
        install_map = get_files_install_map(install_basedir, path)
        self.assertEqual([("some-file", "opt/package-name")], install_map)

    def test_get_install_file_returns_formatted_map(self):
        path = self.useFixture(FileTree({'some-file': {}})).path
        install_basedir = '/opt/package-name'
        install_map = get_files_install_map(install_basedir, path)
        install_file = get_install_file(install_basedir, path)
        self.assertEqual(format_install_map(install_map), install_file)

    def test_install_map_many_files_and_directories(self):
        # The install file instructs debhelper to copy everything in the
        # top-level to /opt/<package-name>.
        tree = {
            'some-file': {},
            'directory/': {},
            }
        path = self.useFixture(FileTree(tree)).path
        install_basedir = '/opt/package-name'
        install_map = get_files_install_map(install_basedir, path)
        self.assertEqual(
            [("directory", "opt/package-name"),
             ("some-file", "opt/package-name")], install_map)

    def test_skip_debian(self):
        # The install file instructs debhelper to copy everything in the
        # top-level to /opt/<package-name>, except for the 'debian' directory.
        tree = {
            'some-file': {},
            'directory/': {},
            DEBIAN_DIR + '/': {},
            }
        path = self.useFixture(FileTree(tree)).path
        install_basedir = '/opt/package-name'
        install_map = get_files_install_map(install_basedir, path)
        self.assertEqual(
            [("directory", "opt/package-name"),
             ("some-file", "opt/package-name")], install_map)

    def test_skip_metadata(self):
        # The install file instructs debhelper to copy everything in the
        # top-level to /opt/<package-name>, except for the 'debian' directory
        # and the metadata file.
        tree = {
            'some-file': {},
            'directory/': {},
            MetadataBackend.METADATA_FILE: {},
            }
        path = self.useFixture(FileTree(tree)).path
        install_basedir = '/opt/package-name'
        install_map = get_files_install_map(install_basedir, path)
        self.assertEqual(
            [("directory", "opt/package-name"),
             ("some-file", "opt/package-name")], install_map)


class PackageNameTests(TestCase):

    def test_package_name_provided(self):
        # If the package name is supplied in the metadata, then that's what we
        # use.
        package_name = self.getUniqueString()
        metadata = {MetadataBackend.PACKAGE_NAME: package_name}
        backend = MetadataBackend(os.getcwd(), metadata)
        self.assertEqual(package_name, backend.get_package_name())

    def test_application_name_not_provided(self):
        # If the application name is not provided, use the capitalized package
        # name.
        package_name = self.getUniqueString()
        metadata = {MetadataBackend.PACKAGE_NAME: package_name}
        backend = MetadataBackend(os.getcwd(), metadata)
        self.assertEqual(
            package_name.capitalize(), backend.get_application_name())

    def test_application_name_provided(self):
        # If the application name is provided, then use that.
        app_name = self.getUniqueString('app-name')
        metadata = {MetadataBackend.APPLICATION_NAME: app_name}
        backend = MetadataBackend(os.getcwd(), metadata)
        self.assertEqual(app_name, backend.get_application_name())

    def test_package_name_empty(self):
        # If the package name is supplied in the metadata, but it's empty,
        # then we use the app name instead.
        app_name = self.getUniqueString('app-name')
        metadata = {
            MetadataBackend.APPLICATION_NAME: app_name,
            MetadataBackend.PACKAGE_NAME: ''}
        backend = MetadataBackend(os.getcwd(), metadata)
        self.assertEqual(app_name, backend.get_package_name())

    def test_package_name_not_provided(self):
        app_name = self.getUniqueString('app-name')
        metadata = {MetadataBackend.APPLICATION_NAME: app_name}
        backend = MetadataBackend(os.getcwd(), metadata)
        self.assertEqual(app_name, backend.get_package_name())

    def test_package_name_both_not_provided(self):
        metadata = {}
        backend = MetadataBackend(os.getcwd(), metadata)
        e = self.assertRaises(
            AssertionError, backend.get_package_name)
        self.assertEqual("Could not determine package name", str(e))

    def test_package_name_empty_app_name_not_provided(self):
        metadata = {MetadataBackend.PACKAGE_NAME: ''}
        backend = MetadataBackend(os.getcwd(), metadata)
        e = self.assertRaises(
            AssertionError, backend.get_package_name)
        self.assertEqual("Could not determine package name", str(e))

    def test_app_name_both_not_provided(self):
        metadata = {}
        backend = MetadataBackend(os.getcwd(), metadata)
        e = self.assertRaises(
            AssertionError, backend.get_application_name)
        self.assertEqual("Could not determine application name", str(e))

    def test_unclean_app_name(self):
        # It's OK if we get an invalid package name from the backend, because
        # pkgme will clean it first.
        metadata = {MetadataBackend.APPLICATION_NAME: 'Foo'}
        backend = MetadataBackend(os.getcwd(), metadata)
        package_name = backend.get_package_name()
        self.assertEqual('Foo', package_name)

    def test_suggested_package_name(self):
        # If suggested_package_name is provided and package_name is not, then
        # we'll use the (cleaned) suggested package name as the package name.
        metadata = {MetadataBackend.SUGGESTED_PACKAGE_NAME: 'foo'}
        backend = MetadataBackend(os.getcwd(), metadata)
        package_name = backend.get_package_name()
        self.assertEqual('foo', package_name)

    def test_suggested_package_name_trumps_app_name(self):
        # If suggested_package_name is provided as well as an
        # application_name, we get the package name from the explicit
        # suggestion rather than inferring from the application name.
        metadata = {MetadataBackend.SUGGESTED_PACKAGE_NAME: 'foo',
                    MetadataBackend.APPLICATION_NAME: 'bar'}
        backend = MetadataBackend(os.getcwd(), metadata)
        package_name = backend.get_package_name()
        self.assertEqual('foo', package_name)

    def test_package_name_trumps_suggestion(self):
        # If both package_name and suggested_package_name are provided, we use
        # package_name.
        metadata = {MetadataBackend.SUGGESTED_PACKAGE_NAME: 'foo',
                    MetadataBackend.PACKAGE_NAME: 'bar'}
        backend = MetadataBackend(os.getcwd(), metadata)
        package_name = backend.get_package_name()
        self.assertEqual('bar', package_name)


class TestMakeWantFn(TestCase):

    def test_calls_want(self):
        want = make_want_fn(DummyBackend)
        path = self.getUniqueString()
        output = StringIO()
        want(path, output)
        self.assertEqual(DummyBackend.want(path),
                json.loads(output.getvalue()))

    def test_names_fn(self):
        want = make_want_fn(DummyBackend)
        self.assertEqual('DummyBackend_want', want.__name__)


class TestMakeAllInfoFn(TestCase):

    def test_calls_get_info(self):
        class VeryDummyBackend(MetadataBackend):
            def get_info(self):
                return {PackageName: self.metadata}
        expected_metadata = dict(foo="bar")
        all_info = make_all_info_fn(VeryDummyBackend)
        path = self.useFixture(MetadataFixture(expected_metadata)).path
        output = StringIO()
        all_info(path, output)
        self.assertEqual({PackageName.name: expected_metadata},
                json.loads(output.getvalue()))

    def test_names_fn(self):
        all_info = make_all_info_fn(DummyBackend)
        self.assertEqual('DummyBackend_all_info', all_info.__name__)


# XXX: Assuming icon name in desktop == package name


class GetPackageFilesTests(TestCase):

    def make_tree(self, spec):
        return self.useFixture(FileTree(from_rough_spec(spec))).path

    def test_returns_filename(self):
        path = self.make_tree(['a', 'b'])
        self.assertEqual(set(['a', 'b']), get_package_files(path, set()))

    def test_ignores_excluded_files(self):
        path = self.make_tree(['debian/', 'a', 'b'])
        self.assertEqual(set(['a', 'b']),
                get_package_files(path, set(['debian'])))


class GetExcludedPackageFilesTests(TestCase):

    def test_excludes_standard_files(self):
        self.assertEqual(set(['debian', MetadataBackend.METADATA_FILE]),
                get_excluded_package_files(MetadataBackend, {}))

    def test_excludes_icons(self):
        self.assertEqual(
                set(['debian', MetadataBackend.METADATA_FILE,
                    '64.png']),
                get_excluded_package_files(MetadataBackend,
                    {MetadataBackend.ICONS: {'64': '64.png'}}))

    def test_excludes_icons_in_subdir(self):
        self.assertEqual(
                set(['debian', MetadataBackend.METADATA_FILE,
                    'subdir']),
                get_excluded_package_files(MetadataBackend,
                    {MetadataBackend.ICONS: {'64': 'subdir/64.png'}}))


class GetIconSizeFromStringTests(TestCase):

    def test_mismatched(self):
        e = self.assertRaises(ValueError, get_icon_size_from_string, '64x48')
        self.assertEqual(
            "Got ('64', '48') size, but only square sizes are supported",
            str(e))

    def test_matched(self):
        self.assertEqual(64, get_icon_size_from_string('64x64'))

    def test_one_dimension(self):
        self.assertEqual(64, get_icon_size_from_string('64'))


class GetIconInstallMapTests(TestCase):

    def test_creates_map(self):
        icons = {'64x64': 'path'}
        self.assertEqual([('path', 'usr/share/icons/hicolor/64x64/apps')],
                get_icon_install_map(icons))

    def test_uses_icon_theme(self):
        icon_theme = 'lowcolor'
        icons = {'64x64': 'path'}
        self.assertEqual([('path', 'usr/share/icons/lowcolor/64x64/apps')],
                get_icon_install_map(icons, icon_theme=icon_theme))


class GetDesktopInstallMap(TestCase):

    def test_creates_map(self):
        package_name = self.getUniqueString()
        self.assertEqual(
            [('debian/{}.desktop'.format(package_name),
                'usr/share/applications')],
            get_desktop_install_map(package_name))
