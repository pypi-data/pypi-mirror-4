

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>tabular.spreadsheet &mdash; tabular v0.0.8 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="tabular v0.0.8 documentation" href="../index.html" />
    <link rel="next" title="tabular.fast" href="tabular.fast.html" />
    <link rel="prev" title="tabular.io" href="tabular.io.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tabular.fast.html" title="tabular.fast"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tabular.io.html" title="tabular.io"
             accesskey="P">previous</a> |</li>
    
        <li><a href="../index.html">tabular</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-tabular.spreadsheet">
<span id="tabular-spreadsheet"></span><h1><a class="reference internal" href="#module-tabular.spreadsheet" title="tabular.spreadsheet"><tt class="xref py py-mod docutils literal"><span class="pre">tabular.spreadsheet</span></tt></a><a class="headerlink" href="#module-tabular.spreadsheet" title="Permalink to this headline">¶</a></h1>
<p>Spreadsheet-style functions for NumPy ndarray with structured dtype or
recarray objects:</p>
<p>aggregate, aggregate_in, pivot, addrecords, addcols, deletecols, renamecol, 
replace, colstack, rowstack, nullvalue</p>
<p>Note that these functions are also wrapped as methods of the tabular tabarray 
object, which is a subclass of the numpy ndarray.</p>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray" title="tabular.tab.tabarray"><tt class="xref py py-class docutils literal"><span class="pre">tabular.tab.tabarray</span></tt></a></div></blockquote>
<dl class="function">
<dt id="tabular.spreadsheet.aggregate">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">aggregate</tt><big>(</big><em>X</em>, <em>On=None</em>, <em>AggFuncDict=None</em>, <em>AggFunc=None</em>, <em>AggList=None</em>, <em>returnsort=False</em>, <em>KeepOthers=True</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate a ndarray with structured dtype (or recarray) on columns for 
given functions.</p>
<p>Aggregate a numpy recarray (or tabular tabarray) on a set of specified 
factors, using specified aggregation functions.</p>
<p>Intuitively, this function will aggregate the dataset <cite>X</cite> on a set of 
columns, whose names are listed in <cite>On</cite>, so that the resulting aggregate 
data set has one record for each unique tuples of values in those columns.</p>
<p>The more factors listed in <cite>On</cite> argument, the &#8220;finer&#8221; is the aggregation, 
the fewer factors, the &#8220;coarser&#8221; the aggregation.  For example, if:</p>
<div class="highlight-rest"><div class="highlight"><pre>On = [&#39;A&#39;,&#39;B&#39;]
</pre></div>
</div>
<p>the resulting data set will have one record for each unique value of pairs 
(a,b) in:</p>
<div class="highlight-rest"><div class="highlight"><pre>X[[&#39;A&#39;,&#39;B&#39;]]
</pre></div>
</div>
<p>The <cite>AggFuncDict</cite> argument specifies how to aggregate the factors _not_ 
listed in <cite>On</cite>, e.g. the so-called <cite>Off</cite> columns.  For example, if</p>
<blockquote>
<div>On = [&#8216;A&#8217;,&#8217;B&#8217;]</div></blockquote>
<p>and <cite>C</cite> is some other column, then:</p>
<div class="highlight-rest"><div class="highlight"><pre>AggFuncDict[&#39;C&#39;]
</pre></div>
</div>
<p>is the function that will be used to reduce to a single value the 
(potentially multiple) values in the <cite>C</cite> column corresponding to unique 
values in the <cite>A</cite>, <cite>B</cite> columns.  For instance, if:</p>
<div class="highlight-rest"><div class="highlight"><pre>AggFuncDict[&#39;C&#39;] = numpy.mean
</pre></div>
</div>
<p>then the result will be that the values in the <cite>C</cite> column corresponding to 
a single <cite>A</cite>, <cite>B</cite> value will be averaged.</p>
<p>If an <cite>Off</cite> column is _not_ provided as a key in <cite>AggFuncDict</cite>, a default 
aggregator function will be used:  the sum function for numerical columns, 
concatenation for string columns.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.aggregate" title="tabular.tab.tabarray.aggregate"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.aggregate()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The data set to aggregate.</div></blockquote>
<p><strong>On</strong> :  list of  strings, optional</p>
<blockquote>
<div>List of column names in <cite>X</cite>.</div></blockquote>
<p><strong>AggFuncDict</strong> :  dictionary, optional</p>
<blockquote>
<div><p>Dictionary where</p>
<ul class="simple">
<li>keys are some (all) column names of <cite>X</cite> that are NOT
in <cite>On</cite></li>
<li>values are functions that can be applied to lists or
numpy arrays.</li>
</ul>
<p>This specifies how to aggregate the factors _not_ listed in
<cite>On</cite>, e.g. the so-called <cite>Off</cite> columns.</p>
</div></blockquote>
<p><strong>AggFunc</strong> :  function, optional</p>
<blockquote>
<div>Function that can be applied to lists or numpy arrays,
specifying how to aggregate factors not listed in either
<cite>On</cite> or the keys of <cite>AggFuncDict</cite>, e.g. a &#8220;default&#8221;
aggregation function for the <cite>Off</cite> columns not explicitly
listed in <cite>AggFuncDict</cite>.</div></blockquote>
<p><strong>returnsort</strong> :        Boolean, optional</p>
<blockquote>
<div>If <cite>returnsort == True</cite>, then return a list of indices
describing how <cite>X</cite> was sorted as a result of aggregation.
Default value is <cite>False</cite>.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>agg</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Aggregated data set.</div></blockquote>
<p><strong>index_array</strong> :  numpy ndarray (int, 1D)</p>
<blockquote>
<div>Returned only if <cite>returnsort == True</cite>.  List of indices
describing how <cite>X</cite> was sorted as a result of aggregation.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.spreadsheet.aggregate_in" title="tabular.spreadsheet.aggregate_in"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate_in()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.aggregate_in">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">aggregate_in</tt><big>(</big><em>Data</em>, <em>On=None</em>, <em>AggFuncDict=None</em>, <em>AggFunc=None</em>, <em>AggList=None</em>, <em>interspersed=True</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.aggregate_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate a ndarray with structured dtype or recarray
and include original data in the result.</p>
<p>Take aggregate of data set on specified columns, then add the resulting 
rows back into data set to make a composite object containing both original 
non-aggregate data rows as well as the aggregate rows.</p>
<p>First read comments for <a class="reference internal" href="#tabular.spreadsheet.aggregate" title="tabular.spreadsheet.aggregate"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate()</span></tt></a>.</p>
<p>This function returns a numpy ndarray, with the number of rows equaling:</p>
<div class="highlight-rest"><div class="highlight"><pre>len(Data) + len(A)
</pre></div>
</div>
<p>where <cite>A</cite> is the the result of:</p>
<div class="highlight-rest"><div class="highlight"><pre>Data.aggregate(On,AggFuncDict)
</pre></div>
</div>
<p><cite>A</cite> represents the aggregate rows; the other rows were the original data 
rows.</p>
<p>This function supports _multiple_ aggregation, meaning that one can first 
aggregate on one set of factors, then repeat aggregation on the result for 
another set of factors, without the results of the first aggregation 
interfering the second.  To achieve this, the method adds two new columns:</p>
<ul class="simple">
<li>a column called &#8220;__aggregates__&#8221; specifying on which factors the rows 
that are aggregate rows were aggregated.  Rows added by aggregating on 
factor <cite>A</cite> (a column in the original data set) will have <cite>A</cite> in the 
&#8220;__aggregates__&#8221; column.  When multiple factors <cite>A1</cite>, <cite>A2</cite> , ... are 
aggregated on, the notation is a comma-separated list:  <cite>A1,A2,...</cite>.  
This way, when you call <cite>aggregate_in</cite> again, the function only 
aggregates on the columns that have the empty char &#8216;&#8217; in their 
&#8220;__aggregates__&#8221; column.</li>
<li>a column called &#8216;__color__&#8217;, specifying Gray-Scale colors for 
aggregated rows that will be used by the Data Environment system 
browser for colorizing the  data.   When there are multiple levels of 
aggregation, the coarser aggregate groups (e.g. on fewer factors) get 
darker gray color then those on finer aggregate groups (e.g. more 
factors).</li>
</ul>
<p>Implemented by the tabarray method 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.aggregate_in" title="tabular.tab.tabarray.aggregate_in"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.aggregate_in()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>Data</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The data set to aggregate in.</div></blockquote>
<p><strong>On</strong> :  list of  strings, optional</p>
<blockquote>
<div>List of column names in <cite>X</cite>.</div></blockquote>
<p><strong>AggFuncDict</strong> :  dictionary, optional</p>
<blockquote>
<div><p>Dictionary where</p>
<ul class="simple">
<li>keys are some (all) column names of <cite>X</cite> that are NOT in 
<cite>On</cite></li>
<li>values are functions that can be applied to lists or
numpy arrays.</li>
</ul>
<p>This specifies how to aggregate the factors _not_ listed in
<cite>On</cite>, e.g. the so-called <cite>Off</cite> columns.</p>
</div></blockquote>
<p><strong>AggFunc</strong> :  function, optional</p>
<blockquote>
<div>Function that can be applied to lists or numpy arrays,
specifying how to aggregate factors not listed in either 
<cite>On</cite> or the keys of <cite>AggFuncDict</cite>, e.g. a &#8220;default&#8221;
aggregation function for the <cite>Off</cite> columns not explicitly
listed in <cite>AggFuncDict</cite>.</div></blockquote>
<p><strong>interspersed</strong> :  boolean, optional</p>
<blockquote>
<div><ul class="simple">
<li>If <cite>True</cite>, aggregate rows are interleaved with the data 
of which they are aggregates.</li>
<li>If <cite>False</cite>, all aggregate rows placed at the end of the 
array.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>agg</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Composite aggregated data set plus original data set.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.spreadsheet.aggregate" title="tabular.spreadsheet.aggregate"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.pivot">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">pivot</tt><big>(</big><em>X</em>, <em>a</em>, <em>b</em>, <em>Keep=None</em>, <em>NullVals=None</em>, <em>order=None</em>, <em>prefix='_'</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.pivot" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements pivoting on numpy ndarrays (with structured dtype) or recarrays.</p>
<p>See <a class="reference external" href="http://en.wikipedia.org/wiki/Pivot_table">http://en.wikipedia.org/wiki/Pivot_table</a> for information about pivot 
tables.</p>
<p>Returns <cite>X</cite> pivoted on (a,b) with <cite>a</cite> as the row axis and <cite>b</cite> values as the 
column axis.</p>
<p>So-called &#8220;nontrivial columns relative to <cite>b</cite>&#8221; in <cite>X</cite> are added as 
color-grouped sets of columns, and &#8220;trivial columns relative to <cite>b</cite>&#8221; are 
also retained as cross-grouped sets of columns if they are listed in <cite>Keep</cite> 
argument.</p>
<p>Note that a column <cite>c</cite> in <cite>X</cite> is &#8220;trivial relative to <cite>b</cite>&#8221; if for all rows 
i, X[c][i] can be determined from X[b][i], e.g the elements in X[c] are in 
many-to-any correspondence with the values in X[b].</p>
<p>The function will raise an exception if the list of pairs of value in 
X[[a,b]] is not the product of the individual columns values, e.g.:</p>
<div class="highlight-rest"><div class="highlight"><pre>X[[a,b]] == set(X[a]) x set(X[b])
</pre></div>
</div>
<p>in some ordering.</p>
<p>Implemented by the tabarray method <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.pivot" title="tabular.tab.tabarray.pivot"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.pivot()</span></tt></a></p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The  data set to pivot.</div></blockquote>
<p><strong>a</strong> : string</p>
<blockquote>
<div>Column name in <cite>X</cite>.</div></blockquote>
<p><strong>b</strong> : string</p>
<blockquote>
<div>Another column name in <cite>X</cite>.</div></blockquote>
<p><strong>Keep</strong> :  list of strings, optional</p>
<blockquote>
<div>List of other columns names in <cite>X</cite>.</div></blockquote>
<p><strong>NullVals</strong> :  optional</p>
<blockquote>
<div><p>Dictionary mapping column names in <cite>X</cite> other than <cite>a</cite> or 
<cite>b</cite> to appropriate null values for their types.</p>
<p>If <cite>None</cite>, then the null values defined by the <cite>nullvalue</cite>
function are used, see
<tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.nullvalue()</span></tt>.</p>
</div></blockquote>
<p><strong>prefix</strong> :  string, optional</p>
<blockquote>
<div>Prefix to add to <cite>coloring</cite> keys corresponding to 
cross-grouped &#8220;trivial columns relative to <cite>b</cite>&#8221;.  Default 
value is an underscore, &#8216;_&#8217;.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>ptable</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>The resulting pivot table.</div></blockquote>
<p><strong>coloring</strong> :  dictionary</p>
<blockquote>
<div><p>Dictionary whose keys are strings and corresponding values 
are lists of column names (e.g. strings).</p>
<p>There are two groups of keys:</p>
<ul>
<li><p class="first">So-called &#8220;nontrivial columns relative to <cite>b</cite>&#8221; in <cite>X</cite>.  
These correspond to columns in:</p>
<div class="highlight-rest"><div class="highlight"><pre>set(<span class="nv">`X.dtype.names`</span>) - set([a, b])
</pre></div>
</div>
</li>
<li><p class="first">Cross-grouped &#8220;trivial columns relative to <cite>b</cite>&#8221;.  The 
<cite>prefix</cite> is used to distinguish these.</p>
</li>
</ul>
<p>The <cite>coloring</cite> parameter is used by the the tabarray pivot 
method, <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.pivot" title="tabular.tab.tabarray.pivot"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.pivot()</span></tt></a>.</p>
<p>See <a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.__new__" title="tabular.tab.tabarray.__new__"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.__new__()</span></tt></a> for more
information about coloring.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.addrecords">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">addrecords</tt><big>(</big><em>X</em>, <em>new</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.addrecords" title="Permalink to this definition">¶</a></dt>
<dd><p>Append one or more records to the end of a numpy recarray or ndarray .</p>
<p>Can take a single record, void or tuple, or a list of records, voids or 
tuples.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.addrecords" title="tabular.tab.tabarray.addrecords"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.addrecords()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The array to add records to.</div></blockquote>
<p><strong>new</strong> :  record, void or tuple, or list of them</p>
<blockquote>
<div>Record(s) to add to <cite>X</cite>.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>New numpy array made up of <cite>X</cite> plus the new records.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong>  <a class="reference internal" href="#tabular.spreadsheet.rowstack" title="tabular.spreadsheet.rowstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.rowstack()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.addcols">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">addcols</tt><big>(</big><em>X</em>, <em>cols</em>, <em>names=None</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.addcols" title="Permalink to this definition">¶</a></dt>
<dd><p>Add one or more columns to a numpy ndarray.</p>
<p>Technical dependency of <a class="reference internal" href="#tabular.spreadsheet.aggregate_in" title="tabular.spreadsheet.aggregate_in"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.aggregate_in()</span></tt></a>.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.addcols" title="tabular.tab.tabarray.addcols"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.addcols()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype or recarray</p>
<blockquote>
<div>The recarray to add columns to.</div></blockquote>
<p><strong>cols</strong> :  numpy ndarray, or list of arrays of columns</p>
<blockquote>
<div>Column(s) to add.</div></blockquote>
<p><strong>names</strong>:  list of strings, optional</p>
<blockquote>
<div>Names of the new columns. Only applicable when <cite>cols</cite> is a 
list of arrays.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>New numpy array made up of <cite>X</cite> plus the new columns.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong>  <a class="reference internal" href="#tabular.spreadsheet.colstack" title="tabular.spreadsheet.colstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.colstack()</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.deletecols">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">deletecols</tt><big>(</big><em>X</em>, <em>cols</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.deletecols" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete columns from a numpy ndarry or recarray.</p>
<p>Can take a string giving a column name or comma-separated list of column 
names, or a list of string column names.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.deletecols" title="tabular.tab.tabarray.deletecols"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.deletecols()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy recarray or ndarray with structured dtype</p>
<blockquote>
<div>The numpy array from which to delete columns.</div></blockquote>
<p><strong>cols</strong> :  string or list of strings</p>
<blockquote>
<div>Name or list of names of columns in <cite>X</cite>.  This can be
a string giving a column name or comma-separated list of 
column names, or a list of string column names.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>New numpy ndarray with structured dtype
given by <cite>X</cite>, excluding the columns named in <cite>cols</cite>.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.renamecol">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">renamecol</tt><big>(</big><em>X</em>, <em>old</em>, <em>new</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.renamecol" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename column of a numpy ndarray with structured dtype, in-place.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.renamecol" title="tabular.tab.tabarray.renamecol"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.renamecol()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>The numpy array for which a column is to be renamed.</div></blockquote>
<p><strong>old</strong> :  string</p>
<blockquote>
<div>Old column name, e.g. a name in <cite>X.dtype.names</cite>.</div></blockquote>
<p><strong>new</strong> :  string</p>
<blockquote>
<div>New column name to replace <cite>old</cite>.</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.replace">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">replace</tt><big>(</big><em>X</em>, <em>old</em>, <em>new</em>, <em>strict=True</em>, <em>cols=None</em>, <em>rows=None</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace value <cite>old</cite> with <cite>new</cite> everywhere it appears in-place.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.replace" title="tabular.tab.tabarray.replace"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.replace()</span></tt></a>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>X</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Numpy array for which in-place replacement of <cite>old</cite> with 
<cite>new</cite> is to be done.</div></blockquote>
<p><strong>old</strong> : string</p>
<p><strong>new</strong> : string</p>
<p><strong>strict</strong> :  boolean, optional</p>
<ul class="simple">
<li>If <cite>strict</cite> = <cite>True</cite>, replace only exact occurences of <cite>old</cite>.</li>
<li>If <cite>strict</cite> = <cite>False</cite>, assume <cite>old</cite> and <cite>new</cite> are strings and   
replace all occurences of substrings (e.g. like 
<tt class="xref py py-func docutils literal"><span class="pre">str.replace()</span></tt>)</li>
</ul>
<p><strong>cols</strong> :  list of strings, optional</p>
<blockquote>
<div>Names of columns to make replacements in; if <cite>None</cite>, make 
replacements everywhere.</div></blockquote>
<p><strong>rows</strong> : list of booleans or integers, optional</p>
<blockquote>
<div>Rows to make replacements in; if <cite>None</cite>, make replacements 
everywhere.</div></blockquote>
</div></blockquote>
<p>Note:  This function does in-place replacements.  Thus there are issues 
handling data types here when replacement dtype is larger than original 
dtype.  This can be resolved later by making a new array when necessary ...</p>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.colstack">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">colstack</tt><big>(</big><em>seq</em>, <em>mode='abort'</em>, <em>returnnaming=False</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.colstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Horizontally stack a sequence of numpy ndarrays with structured dtypes</p>
<p>Analog of numpy.hstack for recarrays.</p>
<p>Implemented by the tabarray method 
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.colstack" title="tabular.tab.tabarray.colstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.colstack()</span></tt></a> which uses 
<tt class="xref py py-func docutils literal"><span class="pre">tabular.tabarray.tab_colstack()</span></tt>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>seq</strong> :  sequence of numpy ndarray with structured dtype</p>
<blockquote>
<div>List, tuple, etc. of numpy recarrays to stack vertically.</div></blockquote>
<p><strong>mode</strong> :  string in [&#8216;first&#8217;,&#8217;drop&#8217;,&#8217;abort&#8217;,&#8217;rename&#8217;]</p>
<blockquote>
<div><p>Denotes how to proceed if when multiple recarrays share the 
same column name:</p>
<ul class="simple">
<li>if <cite>mode</cite> == <tt class="docutils literal"><span class="pre">first</span></tt>, take the column from the first
recarray in <cite>seq</cite> containing the shared column name.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">abort</span></tt>, raise an error when the 
recarrays to stack share column names; this is the
default mode.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">drop</span></tt>, drop any column that shares    
its name with any other column among the sequence of 
recarrays.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">rename</span></tt>, for any set of all columns
sharing the same name, rename all columns by appending 
an underscore, &#8216;_&#8217;, followed by an integer, starting 
with &#8216;0&#8217; and incrementing by 1 for each subsequent 
column.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Result of horizontally stacking the arrays in <cite>seq</cite>.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong>  <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.hstack.html">numpy.hstack</a>.</p>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.rowstack">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">rowstack</tt><big>(</big><em>seq</em>, <em>mode='nulls'</em>, <em>nullvals=None</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.rowstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertically stack a sequence of numpy ndarrays with structured dtype</p>
<p>Analog of numpy.vstack</p>
<p>Implemented by the tabarray method
<a class="reference internal" href="tabular.tab.html#tabular.tab.tabarray.rowstack" title="tabular.tab.tabarray.rowstack"><tt class="xref py py-func docutils literal"><span class="pre">tabular.tab.tabarray.rowstack()</span></tt></a> which uses 
<tt class="xref py py-func docutils literal"><span class="pre">tabular.tabarray.tab_rowstack()</span></tt>.</p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>seq</strong> :  sequence of numpy recarrays</p>
<blockquote>
<div>List, tuple, etc. of numpy recarrays to stack vertically.</div></blockquote>
<p><strong>mode</strong> :  string in [&#8216;nulls&#8217;, &#8216;commons&#8217;, &#8216;abort&#8217;]</p>
<blockquote>
<div><p>Denotes how to proceed if the recarrays have different
dtypes, e.g. different sets of named columns.</p>
<ul class="simple">
<li>if <cite>mode</cite> == <tt class="docutils literal"><span class="pre">nulls</span></tt>, the resulting set of columns is
determined by the union of the dtypes of all recarrays
to be stacked, and missing data is filled with null 
values as defined by 
<tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.nullvalue()</span></tt>; this is the 
default mode.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">commons</span></tt>, the resulting set of 
columns is determined by the intersection of the dtypes 
of all recarrays to be stacked, e.g. common columns.</li>
<li>elif <cite>mode</cite> == <tt class="docutils literal"><span class="pre">abort</span></tt>, raise an error when the
recarrays to stack have different dtypes.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>out</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Result of vertically stacking the arrays in <cite>seq</cite>.</div></blockquote>
</div></blockquote>
<p><strong>See also:</strong>  <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.vstack.html">numpy.vstack</a>.</p>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.join">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">join</tt><big>(</big><em>L</em>, <em>keycols=None</em>, <em>nullvals=None</em>, <em>renamer=None</em>, <em>returnrenaming=False</em>, <em>Names=None</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two or more numpy ndarray with structured dtype on common key 
column(s).</p>
<p>Merge a list (or dictionary) of numpy ndarray with structured dtype, given
by <cite>L</cite>, on key columns listed in <cite>keycols</cite>.</p>
<p>This function is actually a wrapper for 
<a class="reference internal" href="#tabular.spreadsheet.strictjoin" title="tabular.spreadsheet.strictjoin"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.strictjoin()</span></tt></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">strictjoin</span></tt> function has a few restrictions, and this <tt class="docutils literal"><span class="pre">join</span></tt>
function will try to ensure that they are satisfied:</p>
<ul class="simple">
<li>each element of <cite>keycol</cite> must be a valid column name in <cite>X</cite>
and each array in <cite>L</cite>, and all of the same data-type.</li>
<li>for each column <cite>col</cite>  in <cite>keycols</cite>, and each array <cite>A</cite> in <cite>L</cite>, the 
values in <cite>A[col]</cite> must be unique, e.g. no repeats of values &#8211; and 
same for <cite>X[col]</cite>.</li>
<li>the <em>non</em>-key-column column names in each of the arrays must be 
disjoint from each other &#8211; or disjoint after a renaming (see below).</li>
</ul>
<p>An error will be thrown if these conditions are not met.</p>
<p>If you don&#8217;t provide a value of <cite>keycols</cite>, the algorithm will attempt to 
infer which columns should be used by trying to find the largest set of 
common column names that contain unique values in each array and have the 
same data type.  An error will be thrown if no such inference can be made.</p>
<p><em>Renaming of overlapping columns</em></p>
<blockquote>
<div><p>If the non-keycol column names of the arrays overlap, <tt class="docutils literal"><span class="pre">join</span></tt> will 
by default attempt to rename the columns by using a simple 
convention:</p>
<ul class="simple">
<li>If <cite>L</cite> is a list, it will append the number in the list to the 
key associated with the array.</li>
<li>If <cite>L</cite> is a dictionary, the algorithm will append the string 
representation of the key associated with an array to the 
overlapping columns from that array.</li>
</ul>
<p>You can override the default renaming scheme using the <cite>renamer</cite> 
parameter.</p>
</div></blockquote>
<p><em>Nullvalues for keycolumn differences</em></p>
<blockquote>
<div><p>If there are regions of the keycolumns that are not overlapping 
between merged arrays, <cite>join</cite> will fill in the relevant entries 
with null values chosen by default:</p>
<ul class="simple">
<li>&#8216;0&#8217; for integer columns</li>
<li>&#8216;0.0&#8217; for float columns</li>
<li>the empty character (&#8216;&#8217;) for string columns.</li>
</ul>
</div></blockquote>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>L</strong> :  list or dictionary</p>
<blockquote>
<div>Numpy recarrays to merge.  If <cite>L</cite> is a dictionary, the keys
name each numpy recarray, and the corresponding values are 
the actual numpy recarrays.</div></blockquote>
<p><strong>keycols</strong> :  list of strings</p>
<blockquote>
<div>List of the names of the key columns along which to do the 
merging.</div></blockquote>
<p><strong>nullvals</strong> :  function, optional</p>
<blockquote>
<div><p>A function that returns a null value for a numpy format
descriptor string, e.g. <tt class="docutils literal"><span class="pre">'&lt;i4'</span></tt> or <tt class="docutils literal"><span class="pre">'|S5'</span></tt>.</p>
<p>See the default function for further documentation:</p>
<blockquote>
<div><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.DEFAULT_NULLVALUEFORMAT()</span></tt></div></blockquote>
</div></blockquote>
<p><strong>renamer</strong> :  function, optional</p>
<blockquote>
<div><p>A function for renaming overlapping non-key column names 
among the numpy recarrays to merge.</p>
<p>See the default function for further documentation:</p>
<blockquote>
<div><a class="reference internal" href="#tabular.spreadsheet.DEFAULT_RENAMER" title="tabular.spreadsheet.DEFAULT_RENAMER"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.DEFAULT_RENAMER()</span></tt></a></div></blockquote>
</div></blockquote>
<p><strong>returnrenaming</strong> :  Boolean, optional</p>
<blockquote>
<div><p>Whether to return the result of the <cite>renamer</cite> function.</p>
<p>See the default function for further documentation:</p>
<blockquote>
<div><a class="reference internal" href="#tabular.spreadsheet.DEFAULT_RENAMER" title="tabular.spreadsheet.DEFAULT_RENAMER"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.DEFAULT_RENAMER()</span></tt></a></div></blockquote>
</div></blockquote>
<p><strong>Names</strong>: list of strings:</p>
<blockquote>
<div><p>If <cite>L</cite> is a list, than names for elements of <cite>L</cite> can be 
specified with <cite>Names</cite> (without losing the ordering as you 
would if you did it with a dictionary).</p>
<p><cite>len(L)</cite> must equal <cite>len(Names)</cite></p>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>result</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Result of the join, e.g. the result of merging the input
numpy arrays defined in <cite>L</cite> on the key columns listed in 
<cite>keycols</cite>.</div></blockquote>
<p><strong>renaming</strong> :  dictionary of dictionaries, optional</p>
<blockquote>
<div><p>The result returned by the <cite>renamer</cite> function. Returned 
only if <cite>returnrenaming == True</cite>.</p>
<p>See the default function for further documentation:</p>
<blockquote>
<div><a class="reference internal" href="#tabular.spreadsheet.DEFAULT_RENAMER" title="tabular.spreadsheet.DEFAULT_RENAMER"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.DEFAULT_RENAMER()</span></tt></a></div></blockquote>
</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.spreadsheet.strictjoin" title="tabular.spreadsheet.strictjoin"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.strictjoin()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.strictjoin">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">strictjoin</tt><big>(</big><em>L</em>, <em>keycols</em>, <em>nullvals=None</em>, <em>renaming=None</em>, <em>Names=None</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.strictjoin" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two or more numpy ndarray with structured dtypes on common key
column(s).</p>
<p>Merge a list (or dictionary) of numpy arrays, given by <cite>L</cite>, on key 
columns listed in <cite>keycols</cite>.</p>
<p>The <tt class="docutils literal"><span class="pre">strictjoin</span></tt> assumes the following restrictions:</p>
<ul class="simple">
<li>each element of <cite>keycol</cite> must be a valid column name in <cite>X</cite> and each 
array in <cite>L</cite>, and all of the same data-type.</li>
<li>for each column <cite>col</cite>  in <cite>keycols</cite>, and each array <cite>A</cite> in <cite>L</cite>, the 
values in <cite>A[col]</cite> must be unique, e.g. no repeats of values &#8211; and 
same for <cite>X[col]</cite>.</li>
<li>the <em>non</em>-key-column column names in each of the arrays must be 
disjoint from each other &#8211; or disjoint after a renaming (see below).</li>
</ul>
<p>An error will be thrown if these conditions are not met.</p>
<p>For a wrapper that attempts to meet these restrictions, see 
<a class="reference internal" href="#tabular.spreadsheet.join" title="tabular.spreadsheet.join"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.join()</span></tt></a>.</p>
<p>If you don&#8217;t provide a value of <cite>keycols</cite>, the algorithm will attempt to 
infer which columns should be used by trying to find the largest set of 
common column names that contain unique values in each array and have the 
same data type.  An error will be thrown if no such inference can be made.</p>
<p><em>Renaming of overlapping columns</em></p>
<blockquote>
<div><p>If the non-keycol column names of the arrays overlap, <tt class="docutils literal"><span class="pre">join</span></tt> will 
by default attempt to rename the columns by using a simple 
convention:</p>
<ul class="simple">
<li>If <cite>L</cite> is a list, it will append the number in the list to the 
key associated with the array.</li>
<li>If <cite>L</cite> is a dictionary, the algorithm will append the string 
representation of the key associated with an array to the 
overlapping columns from that array.</li>
</ul>
<p>You can override the default renaming scheme using the <cite>renamer</cite> 
parameter.</p>
</div></blockquote>
<p><em>Nullvalues for keycolumn differences</em></p>
<blockquote>
<div><p>If there are regions of the keycolumns that are not overlapping 
between merged arrays, <cite>join</cite> will fill in the relevant entries 
with null values chosen by default:</p>
<ul class="simple">
<li>&#8216;0&#8217; for integer columns</li>
<li>&#8216;0.0&#8217; for float columns</li>
<li>the empty character (&#8216;&#8217;) for string columns.</li>
</ul>
</div></blockquote>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>L</strong> :  list or dictionary</p>
<blockquote>
<div>Numpy recarrays to merge.  If <cite>L</cite> is a dictionary, the keys
name each numpy recarray, and the corresponding values are 
the actual numpy recarrays.</div></blockquote>
<p><strong>keycols</strong> :  list of strings</p>
<blockquote>
<div>List of the names of the key columns along which to do the 
merging.</div></blockquote>
<p><strong>nullvals</strong> :  function, optional</p>
<blockquote>
<div><p>A function that returns a null value for a numpy format
descriptor string, e.g. <tt class="docutils literal"><span class="pre">'&lt;i4'</span></tt> or <tt class="docutils literal"><span class="pre">'|S5'</span></tt>.</p>
<p>See the default function for further documentation:</p>
<blockquote>
<div><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.DEFAULT_NULLVALUEFORMAT()</span></tt></div></blockquote>
</div></blockquote>
<p><strong>renaming</strong> :  dictionary of dictionaries, optional</p>
<blockquote>
<div><p>Dictionary mapping each input numpy recarray to a 
dictionary mapping each original column name to its new 
name following the convention above.</p>
<p>For example, the result returned by:</p>
<blockquote>
<div><a class="reference internal" href="#tabular.spreadsheet.DEFAULT_RENAMER" title="tabular.spreadsheet.DEFAULT_RENAMER"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.DEFAULT_RENAMER()</span></tt></a></div></blockquote>
</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>result</strong> :  numpy ndarray with structured dtype</p>
<blockquote>
<div>Result of the join, e.g. the result of merging the input
numpy arrays defined in <cite>L</cite> on the key columns listed in 
<cite>keycols</cite>.</div></blockquote>
</div></blockquote>
<p><strong>See Also:</strong></p>
<blockquote>
<div><a class="reference internal" href="#tabular.spreadsheet.join" title="tabular.spreadsheet.join"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.join()</span></tt></a></div></blockquote>
</dd></dl>

<dl class="function">
<dt id="tabular.spreadsheet.DEFAULT_RENAMER">
<tt class="descclassname">tabular.spreadsheet.</tt><tt class="descname">DEFAULT_RENAMER</tt><big>(</big><em>L</em>, <em>Names=None</em><big>)</big><a class="headerlink" href="#tabular.spreadsheet.DEFAULT_RENAMER" title="Permalink to this definition">¶</a></dt>
<dd><p>Renames overlapping column names of numpy ndarrays with structured dtypes</p>
<p>Rename the columns by using a simple convention:</p>
<ul class="simple">
<li>If <cite>L</cite> is a list, it will append the number in the list to the key 
associated with the array.</li>
<li>If <cite>L</cite> is a dictionary, the algorithm will append the string 
representation of the key associated with an array to the overlapping 
columns from that array.</li>
</ul>
<p>Default renamer function used by <a class="reference internal" href="#tabular.spreadsheet.join" title="tabular.spreadsheet.join"><tt class="xref py py-func docutils literal"><span class="pre">tabular.spreadsheet.join()</span></tt></a></p>
<p><strong>Parameters</strong></p>
<blockquote>
<div><p><strong>L</strong> :  list or dictionary</p>
<blockquote>
<div>Numpy recarrays with columns to be renamed.</div></blockquote>
</div></blockquote>
<p><strong>Returns</strong></p>
<blockquote>
<div><p><strong>D</strong> :  dictionary of dictionaries</p>
<blockquote>
<div>Dictionary mapping each input numpy recarray to a 
dictionary mapping each original column name to its new 
name following the convention above.</div></blockquote>
</div></blockquote>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<p class="logo"><a href="http://web.mit.edu/yamins/www/tabular">
  <img class="logo" src="../_static/tabularclear.png" alt="Logo"/>
</a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="tabular.io.html"
                        title="previous chapter"><tt class="docutils literal docutils literal"><span class="pre">tabular.io</span></tt></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tabular.fast.html"
                        title="next chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">tabular.fast</span></tt></a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/tabular.spreadsheet.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tabular.fast.html" title="tabular.fast"
             >next</a> |</li>
        <li class="right" >
          <a href="tabular.io.html" title="tabular.io"
             >previous</a> |</li>
    
        <li><a href="../index.html">tabular</a> &raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Elaine Angelino and Daniel Yamins.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>