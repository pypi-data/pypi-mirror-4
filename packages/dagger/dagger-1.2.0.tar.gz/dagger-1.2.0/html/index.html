<h1>Python Dagger - The File Dependency Graph Engine</h1>

<p><img src="banner.png" alt="Banner image" title="Dagger graphs." /></p>

<h2>Overview</h2>

<p><a href="http://sourceforge.net/projects/pythondagger">Dagger</a> evaluates file dependencies in a directed-acyclic-graph (DAG) 
like GNU make, but timestamps or hashes can be enabled per-file. 
This allows you to use fast timestamp comparisons with large files, 
and hashing on small files. When hashing is used, it's stored in a 
simple 2 column text file with filename,hash per line or in a sqlite 
database. Dagger can be used as a building block for a larger build 
system that is serial or parallel.</p>

<p>Dagger is written in Python to make it portable and extensible. It's 
graph evaluation engine is non-recursive, so it can handle very deep
dependency paths. A benchmark tool (see below) is available to test and visualize complex graphs, and demonstrates using 1 million files.</p>

<h2>Features</h2>

<ul>
<li>Dependency based on modified time or hash (md5) for individual or all files.</li>
<li>Force individual files as stale or uptodate.</li>
<li>All-paths computation for every node and discovery order.</li>
<li>Written in pure Python to be platform agnostic.</li>
<li>Non-recursive graph algorithm.</li>
<li>Hash database in text or sqlite (and in-memory during runtime).</li>
<li>Graphviz dot file export that colors stale file nodes.</li>
<li>Iterate over results in chunks that are mutually independent to allow parallel processing. </li>
</ul>

<h2>Quick Example</h2>

<pre><code>import dagger

dag = dagger.dagger()
dag.add('1', ['2','3'])
dag.add('3', ['4','5'])
dag.add('6', ['3','7'])

# Force this node to be old, and all its dependent parents.
dag.stale('4') # You can force "freshness" with dag.stale('4', 0).
dag.run()

# Export for visualizing.
dag.dot('example.dot')

# Get iterator.
it = dag.iter()

# See how many items there are in total.
print len(it)
# 4

# Get next 2 files we can process in parallel.
todo = it.next(2)
print todo 
# ['4']: Only one is returned because others depend on it.

# Pretend we finished first task, so remove it and get next 2.
it.remove('4')
todo = it.next(2) 
print todo 
# ['3'] We still get single item because 6 &amp; 1 depend on 3.    

it.remove('3')
todo = it.next(2)
print todo 
# ['1','6'] We finally get two independent items.
</code></pre>

<p><img src="dot.png" alt="Example image" title="Example of dot export with color enabled." /></p>

<p><strong>example.dot</strong> visualized with kgraphviewer. Old/stale nodes are colored in red by dagger.</p>

<h2>Download</h2>

<p><a href="http://sourceforge.net/projects/pythondagger/files/">Source code</a>
<a href="http://pypi.python.org/pypi/dagger">PYPI</a></p>

<h2>Testing</h2>

<pre><code>make test
</code></pre>

<h2>Installation</h2>

<pre><code># With PIP.
pip install dagger

# If PIP is not available, use source distribution.
sudo python setup.py install

# For Windows, download and run the binary installer at PYPI.
</code></pre>

<h2>Benchmarking</h2>

<p>There is a helper script in <code>bench/</code> to help you see how fast dagger can evaluate the dependency graph.
You can specify how many children and depth of the mock graph.</p>

<pre><code># Small trees visualized with dot.
$ python bench.py --levels 3 --width 2 --dot 3x2.dot
nodes: inner=6 outer=8 total=14
0.0s Run
</code></pre>

<p><img src="dot3x2.png" alt="dot3x2 image" title="Small trees output by bench.py with 1 old node." /></p>

<p>Small 3 level, 2 child wide graph output by bench.py with 1 old node ('7').</p>

<pre><code># Larger test case. Does your project use 56,000 files?
$ python bench.py --levels 6 --width 6 --allpaths
nodes: inner=9330 outer=46656 total=55986
0.24s Run   

# See if even faster with pypy.
$ pypy bench.py --levels 6 --width 6 --allpaths
nodes: inner=9330 outer=46656 total=55986
0.16s Run   

# Try extreme case of simulating 1 million files.
$ python bench.py --levels 7 --width 7 --allpaths
nodes: inner=137256 outer=823543 total=960799
6.35s Run   

# pypy reports a shorter runtime for the 1 million node graph.
$ pypy ...
3.17s Run
</code></pre>

<h2>Example: Hashing</h2>

<pre><code># Use a text file for file hashes.
# It's ok if it doesn't exist. 
dag = dagger.dagger('/home/project/hash.txt')

# dag.add(...)

# Enable hashing for all files.
dag.hashall = 1

# Evaluates the dependencies and computes hashes if none existed.
dag.run()

# Export the file.
dag.exporthash()
</code></pre>

<h2>Example: Hashing and Sqlite</h2>

<pre><code># This time use sqlite (in-memory) database instead of a text file.
# Ok if doesn't exist yet. It will be created.
dag = dagger.dagger('hash.sqlite', sqlite=1, sqlite_memory=1)

# dag.add(...)

# Export the file.
dag.exporthash()
</code></pre>

<h2>Example: Control Hashing for Specific Files</h2>

<pre><code>dag.hash('myfile.txt', 1) # Enable hashing for file.
dag.hash('myfile.txt', 0) # Turn it off (hashing is off by default for all).
</code></pre>

<h2>Example: Using Graph Search Results</h2>

<pre><code>dag.add(...)
dag.run()
# See the depth-first-search node order.
print dag.ordernames() 
# 2,4,5,3,1,7,6

# Access the search ordered nodes directly.
print dag.order.list
# [&lt;dagger.node object at ...&gt;, &lt;dagger.node object at ...&gt;, ...]

# Get path names; root nodes are rightmost in list. For our quick example graph:
print dag.pathnames('4')
# [['3', '1'], ['3', '6']]
</code></pre>

<h2>News</h2>

<p>v1.2.0 2012/11/21</p>

<ul>
<li>Made private container "idict" iterable.</li>
</ul>

<p>v1.1.0 2012/11/19</p>

<ul>
<li>Added <code>__len__</code> function to iterator to see how many tasks remain.</li>
</ul>

<p>v1.0.0 2012/11/14</p>

<ul>
<li>Iterator added to access independent sets of nodes, thus allowing parallel processing in context of "make" processflows.</li>
</ul>

<p>v0.0.0 2012/10/15</p>

<ul>
<li>Initial release.</li>
</ul>

<h2>Distribution</h2>

<pre><code>make html
make dist VER=0.0.0
make pypidocs
make pypi
</code></pre>

<h2>Publishing</h2>

<pre><code>ssh -t rsz,pythondagger@shell.sourceforge.net create
scp html/* rsz,pythondagger@shell.sourceforge.net:/home/project-web/pythondagger/htdocs
scp ../pythondagger-0.0.0.tar.gz rsz,pythondagger@shell.sourceforge.net:/home/frs/project/p/py/pythondagger
</code></pre>

<h2>License</h2>

<p>Copyright 2012 Remik Ziemlinski under the terms of the GNU General Public License</p>

<p><link rel="stylesheet" href="http://yandex.st/highlightjs/7.0/styles/default.min.css"></p>

<script src="http://yandex.st/highlightjs/7.0/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>

<p><style type="text/css">
body {
  font-family: Sans-Serif;
}
</style></p>
