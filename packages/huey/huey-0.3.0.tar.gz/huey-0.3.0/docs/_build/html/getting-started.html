
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Getting Started &mdash; huey 0.2.2 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="huey 0.2.2 documentation" href="index.html" />
    <link rel="next" title="Understanding how commands are imported" href="imports.html" />
    <link rel="prev" title="Installing" href="installation.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="imports.html" title="Understanding how commands are imported"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installing"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">huey 0.2.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="getting-started">
<span id="id1"></span><h1>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<p>The goal of this document is to help you get running quickly and with as little
fuss as possible.  Because huey works with python in general but also has some
special django integration, this guide is broken up into two parts.  Read the
general guide first, then continue on to the django guide, as information is
presented in the general guide that is not covered in the django parts.</p>
<ul class="simple">
<li><a class="reference internal" href="#getting-started-python"><em>General guide</em></a></li>
<li><a class="reference internal" href="#getting-started-django"><em>Django integration</em></a></li>
</ul>
<div class="section" id="general-guide">
<span id="getting-started-python"></span><h2>General guide<a class="headerlink" href="#general-guide" title="Permalink to this headline">¶</a></h2>
<p>There are three main components (or processes) to consider when running huey:</p>
<ul class="simple">
<li>the producer(s), i.e. a web application</li>
<li>the consumer(s), which executes jobs placed into the queue</li>
<li>the queue where tasks are stored, e.g. Redis</li>
</ul>
<p>These three processes are shown in the screenshot below &#8211; the left-hand pane
shows the producer: a simple program that asks the user for input on how many
&#8220;beans&#8221; to count.  In the top-right, the consumer is running.  It is doing the
actual &#8220;computation&#8221; and simply printing the number of beans counted.  In the
bottom-right is the queue, Redis in this example, which we&#8217;re monitoring and
shows tasks being enqueued (<tt class="docutils literal"><span class="pre">LPUSH</span></tt>) and read (<tt class="docutils literal"><span class="pre">BRPOP</span></tt>) from the database.</p>
<img alt="_images/example.jpg" src="_images/example.jpg" />
<div class="section" id="trying-it-out-yourself">
<h3>Trying it out yourself<a class="headerlink" href="#trying-it-out-yourself" title="Permalink to this headline">¶</a></h3>
<p>Assuming you&#8217;ve got <a class="reference internal" href="installation.html#installation"><em>huey installed</em></a>, let&#8217;s look at the code
from this example.</p>
<p>The first step is to configure your queue.  The consumer needs to be pointed at
a subclass of <tt class="xref py py-class docutils literal"><span class="pre">BaseConfiguration</span></tt>, which specifies things like the backend to
use, where to log activity, etc.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># config.py</span>
<span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">BaseConfiguration</span><span class="p">,</span> <span class="n">Invoker</span>
<span class="kn">from</span> <span class="nn">huey.backends.redis_backend</span> <span class="kn">import</span> <span class="n">RedisBlockingQueue</span>


<span class="n">queue</span> <span class="o">=</span> <span class="n">RedisBlockingQueue</span><span class="p">(</span><span class="s">&#39;test-queue&#39;</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s">&#39;localhost&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">)</span>
<span class="n">invoker</span> <span class="o">=</span> <span class="n">Invoker</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Configuration</span><span class="p">(</span><span class="n">BaseConfiguration</span><span class="p">):</span>
    <span class="n">QUEUE</span> <span class="o">=</span> <span class="n">queue</span>
    <span class="n">THREADS</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>The interesting parts of this configuration module are the <tt class="xref py py-class docutils literal"><span class="pre">Invoker</span></tt> object
and the <tt class="xref py py-class docutils literal"><span class="pre">RedisBlockingQueue</span></tt> object.  The <tt class="docutils literal"><span class="pre">queue</span></tt> is responsible for
storing and retrieving messages, and the <tt class="docutils literal"><span class="pre">invoker</span></tt> is used by your application
code to coordinate function calls with a queue backend.  We&#8217;ll see how the <tt class="docutils literal"><span class="pre">invoker</span></tt>
is used when looking at the actual function responsible for counting beans:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># commands.py</span>
<span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">queue_command</span>

<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">invoker</span> <span class="c"># import the invoker we instantiated in config.py</span>


<span class="nd">@queue_command</span><span class="p">(</span><span class="n">invoker</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">count_beans</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;Counted </span><span class="si">%s</span><span class="s"> beans&#39;</span> <span class="o">%</span> <span class="n">num</span>
</pre></div>
</div>
<p>The above example shows the API for writing &#8220;commands&#8221; that are executed by the
queue consumer &#8211; simply decorate the code you want executed by the consumer
with the <tt class="xref py py-func docutils literal"><span class="pre">queue_command()</span></tt> decorator and when it is called, the main
process will return <em>immediately</em> after enqueueing the function call.  The
<tt class="docutils literal"><span class="pre">invoker</span></tt> is passed in to the decorator, which instructs huey where to send
the message.</p>
<p>The main executable is very simple.  It imports both the configuration <strong>and</strong>
the commands - this is to ensure that when we run the consumer by pointing it
at the configuration, the commands are also imported and loaded into memory.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># main.py</span>
<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">Configuration</span> <span class="c"># import the configuration class</span>
<span class="kn">from</span> <span class="nn">commands</span> <span class="kn">import</span> <span class="n">count_beans</span> <span class="c"># import our command</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">beans</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s">&#39;How many beans? &#39;</span><span class="p">)</span>
    <span class="n">count_beans</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">beans</span><span class="p">))</span>
    <span class="k">print</span> <span class="s">&#39;Enqueued job to count </span><span class="si">%s</span><span class="s"> beans&#39;</span> <span class="o">%</span> <span class="n">beans</span>
</pre></div>
</div>
<p>To run these scripts, follow these steps:</p>
<ol class="arabic simple">
<li>Ensure you have <a class="reference external" href="http://redis.io">Redis</a> running locally</li>
<li>Ensure you have <a class="reference internal" href="installation.html#installation"><em>installed huey</em></a></li>
<li>Start the consumer: <tt class="docutils literal"><span class="pre">huey_consumer.py</span> <span class="pre">main.Configuration</span></tt></li>
<li>Run the main program: <tt class="docutils literal"><span class="pre">python</span> <span class="pre">main.py</span></tt></li>
</ol>
</div>
<div class="section" id="getting-results-from-jobs">
<h3>Getting results from jobs<a class="headerlink" href="#getting-results-from-jobs" title="Permalink to this headline">¶</a></h3>
<p>The above example illustrates a &#8220;send and forget&#8221; approach, but what if your
application needs to do something with the results of a task?  To get results
from your tasks, we&#8217;ll set up the <tt class="docutils literal"><span class="pre">RedisDataStore</span></tt> by adding the following
lines to the <tt class="docutils literal"><span class="pre">config.py</span></tt> module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">BaseConfiguration</span><span class="p">,</span> <span class="n">Invoker</span>
<span class="kn">from</span> <span class="nn">huey.backends.redis_backend</span> <span class="kn">import</span> <span class="n">RedisBlockingQueue</span><span class="p">,</span> <span class="n">RedisDataStore</span>


<span class="n">queue</span> <span class="o">=</span> <span class="n">RedisBlockingQueue</span><span class="p">(</span><span class="s">&#39;test-queue&#39;</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s">&#39;localhost&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">)</span>
<span class="n">result_store</span> <span class="o">=</span> <span class="n">RedisDataStore</span><span class="p">(</span><span class="s">&#39;results&#39;</span><span class="p">,</span> <span class="n">host</span><span class="o">=</span><span class="s">&#39;localhost&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">6379</span><span class="p">)</span> <span class="c"># new</span>

<span class="n">invoker</span> <span class="o">=</span> <span class="n">Invoker</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">result_store</span><span class="o">=</span><span class="n">result_store</span><span class="p">)</span> <span class="c"># added result store</span>


<span class="k">class</span> <span class="nc">Configuration</span><span class="p">(</span><span class="n">BaseConfiguration</span><span class="p">):</span>
    <span class="n">QUEUE</span> <span class="o">=</span> <span class="n">queue</span>
    <span class="n">RESULT_STORE</span> <span class="o">=</span> <span class="n">result_store</span> <span class="c"># added</span>
    <span class="n">THREADS</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>To better illustrate getting results, we&#8217;ll also modify the <tt class="docutils literal"><span class="pre">commands.py</span></tt>
module to return a string rather than simply printing to stdout:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">queue_command</span>

<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">invoker</span>


<span class="nd">@queue_command</span><span class="p">(</span><span class="n">invoker</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">count_beans</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;Counted </span><span class="si">%s</span><span class="s"> beans&#39;</span> <span class="o">%</span> <span class="n">num</span> <span class="c"># changed &quot;print&quot; to &quot;return&quot;</span>
</pre></div>
</div>
<p>We&#8217;re ready to fire up the consumer.  Instead of simply executing the main
program, though, we&#8217;ll start an interpreter and run the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">main</span> <span class="kn">import</span> <span class="n">count_beans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">count_beans</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="c"># &lt;--- what is &quot;res&quot; ?</span>
<span class="go">&lt;huey.queue.AsyncData object at 0xb7471a4c&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="c"># &lt;--- get the result of this task</span>
<span class="go">&#39;Counted 100 beans&#39;</span>
</pre></div>
</div>
<p>Following the same layout as our last example, here is a screenshot of the three
main processes at work:</p>
<ol class="arabic simple">
<li>Top-left, interpreter which produces a job then asks for the result</li>
<li>Top-right, the consumer which runs the job and stores the result</li>
<li>Bottom-right, the Redis database, which we can see is storing the results and
then deleting them after they&#8217;ve been retrieved</li>
</ol>
<img alt="_images/example_results.jpg" src="_images/example_results.jpg" />
</div>
<div class="section" id="executing-tasks-in-the-future">
<h3>Executing tasks in the future<a class="headerlink" href="#executing-tasks-in-the-future" title="Permalink to this headline">¶</a></h3>
<p>It is often useful to enqueue a particular task to execute at some arbitrary time
in the future, for example, mark a blog entry as published at a certain time.</p>
<p>This is very simple to do with huey.  Returning to the interpreter session from
the last section, let&#8217;s schedule a bean counting to happen one minute in the future
and see how huey handles it.  Execute the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_a_minute</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">count_beans</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,),</span> <span class="n">eta</span><span class="o">=</span><span class="n">in_a_minute</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span>
<span class="go">&lt;huey.queue.AsyncData object at 0xb72915ec&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="c"># &lt;--- this returns None, no data is ready</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">()</span> <span class="c"># &lt;--- still no data...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># &lt;--- ok, let&#39;s just block until its ready</span>
<span class="go">&#39;Counted 100 beans&#39;</span>
</pre></div>
</div>
<p>Looking at the redis output, we see the following (simplified for reability):</p>
<div class="highlight-python"><pre>+1325563365.910640 "LPUSH" count_beans(100)
+1325563365.911912 "BRPOP" wait for next job
+1325563365.912435 "HSET" store 'Counted 100 beans'
+1325563366.393236 "HGET" retrieve result from task
+1325563366.393464 "HDEL" delete result after reading</pre>
</div>
<p>Here is a screenshot showing the same:</p>
<img alt="_images/example_schedule.jpg" src="_images/example_schedule.jpg" />
</div>
<div class="section" id="retrying-tasks-that-fail">
<h3>Retrying tasks that fail<a class="headerlink" href="#retrying-tasks-that-fail" title="Permalink to this headline">¶</a></h3>
<p>Huey supports retrying tasks a finite number of times.  If an exception is raised
during the execution of the task and <tt class="docutils literal"><span class="pre">retries</span></tt> have been specified, the task
will be re-queued and tried again, up to the number of retries specified.</p>
<p>Here is a task that will be retried 3 times and will blow up every time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># commands.py</span>
<span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">queue_command</span>

<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">invoker</span>


<span class="nd">@queue_command</span><span class="p">(</span><span class="n">invoker</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">count_beans</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;Counted </span><span class="si">%s</span><span class="s"> beans&#39;</span> <span class="o">%</span> <span class="n">num</span> <span class="c"># changed &quot;print&quot; to &quot;return&quot;</span>

<span class="nd">@queue_command</span><span class="p">(</span><span class="n">invoker</span><span class="p">,</span> <span class="n">retries</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">try_thrice</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;trying....&#39;</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;nope&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The console output shows our task being called in the main interpreter session,
and then when the consumer picks it up and executes it we see it failing and being
retried:</p>
<img alt="_images/example_retry.jpg" src="_images/example_retry.jpg" />
<p>Oftentimes it is a good idea to wait a certain amount of time between retries.
You can specify a <em>delay</em> between retries, in seconds, which is the minimum time
before the task will be retried.  Here we&#8217;ve modified the command to include a
delay, and also to print the current time to show that its working.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># commands.py</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="nd">@queue_command</span><span class="p">(</span><span class="n">invoker</span><span class="p">,</span> <span class="n">retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">retry_delay</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">try_thrice</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;trying....</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;nope&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The console output below shows the task being retried, but in between retries I&#8217;ve
also &#8220;counted some beans&#8221; &#8211; that gets executed normally, in between retries.</p>
<img alt="_images/example_retry_delay.jpg" src="_images/example_retry_delay.jpg" />
</div>
<div class="section" id="executing-tasks-at-regular-intervals">
<h3>Executing tasks at regular intervals<a class="headerlink" href="#executing-tasks-at-regular-intervals" title="Permalink to this headline">¶</a></h3>
<p>The final usage pattern supported by huey is the execution of tasks at regular
intervals.  This is modeled after <tt class="docutils literal"><span class="pre">crontab</span></tt> behavior, and even follows similar
syntax.  Tasks run at regular intervals and should not return meaningful results, nor
should they accept any parameters.</p>
<p>Let&#8217;s add a new task that prints the time every minute &#8211; we&#8217;ll use this to
test that the consumer is executing the tasks on schedule.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># commands.py</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">huey</span> <span class="kn">import</span> <span class="n">queue_command</span><span class="p">,</span> <span class="n">periodic_command</span><span class="p">,</span> <span class="n">crontab</span>

<span class="kn">from</span> <span class="nn">config</span> <span class="kn">import</span> <span class="n">invoker</span>


<span class="nd">@queue_command</span><span class="p">(</span><span class="n">invoker</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">count_beans</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">&#39;Counted </span><span class="si">%s</span><span class="s"> beans&#39;</span> <span class="o">%</span> <span class="n">num</span>

<span class="nd">@queue_command</span><span class="p">(</span><span class="n">invoker</span><span class="p">,</span> <span class="n">retries</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">retry_delay</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">try_thrice</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&#39;trying....</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;nope&#39;</span><span class="p">)</span>

<span class="nd">@periodic_command</span><span class="p">(</span><span class="n">invoker</span><span class="p">,</span> <span class="n">crontab</span><span class="p">(</span><span class="n">minute</span><span class="o">=</span><span class="s">&#39;*&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">print_time</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
</pre></div>
</div>
<p>Additionally, we need to indicate in the <tt class="docutils literal"><span class="pre">Configuration</span></tt> object that we want
to run periodic tasks.  The reason this is configurable is because if you were
wanting to run multiple consumer processes, only <em>one</em> of them should be responsible
for enqueueing periodic commands.  The configuration now looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># config.py excerpt</span>
<span class="k">class</span> <span class="nc">Configuration</span><span class="p">(</span><span class="n">BaseConfiguration</span><span class="p">):</span>
    <span class="n">QUEUE</span> <span class="o">=</span> <span class="n">queue</span>
    <span class="n">RESULT_STORE</span> <span class="o">=</span> <span class="n">result_store</span>
    <span class="n">PERIODIC</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># &lt;-- new</span>
</pre></div>
</div>
<p>Now, when we run the consumer it will start printing the time every minute:</p>
<img alt="_images/example_crontab.jpg" src="_images/example_crontab.jpg" />
</div>
<div class="section" id="reading-more">
<h3>Reading more<a class="headerlink" href="#reading-more" title="Permalink to this headline">¶</a></h3>
<p>That sums up the basic usage patterns of huey.  If you plan on using with django,
read on &#8211; otherwise check the detailed documentation on the following:</p>
<ul class="simple">
<li><a class="reference internal" href="api.html#huey.bin.config.BaseConfiguration" title="huey.bin.config.BaseConfiguration"><tt class="xref py py-class docutils literal"><span class="pre">BaseConfiguration</span></tt></a> - configuration options</li>
<li><a class="reference internal" href="api.html#huey.backends.base.BaseQueue" title="huey.backends.base.BaseQueue"><tt class="xref py py-class docutils literal"><span class="pre">BaseQueue</span></tt></a> - the queue interface and writing your own backends</li>
<li><a class="reference internal" href="api.html#huey.backends.base.BaseDataStore" title="huey.backends.base.BaseDataStore"><tt class="xref py py-class docutils literal"><span class="pre">BaseDataStore</span></tt></a> - the simple data store used for results and schedule serialization</li>
<li><a class="reference internal" href="api.html#huey.queue.Invoker" title="huey.queue.Invoker"><tt class="xref py py-class docutils literal"><span class="pre">Invoker</span></tt></a> - responsible for coordinating executable tasks and queue backends</li>
<li><a class="reference internal" href="api.html#huey.decorators.queue_command" title="huey.decorators.queue_command"><tt class="xref py py-func docutils literal"><span class="pre">queue_command()</span></tt></a> - decorator to indicate an executable task</li>
<li><a class="reference internal" href="api.html#huey.decorators.periodic_command" title="huey.decorators.periodic_command"><tt class="xref py py-func docutils literal"><span class="pre">periodic_command()</span></tt></a> - decorator to indicate a task that executes at periodic intervals</li>
<li><a class="reference internal" href="api.html#huey.decorators.crontab" title="huey.decorators.crontab"><tt class="xref py py-func docutils literal"><span class="pre">crontab()</span></tt></a> - a function for defining what intervals to execute a periodic command</li>
</ul>
</div>
</div>
<div class="section" id="django-integration">
<span id="getting-started-django"></span><h2>Django integration<a class="headerlink" href="#django-integration" title="Permalink to this headline">¶</a></h2>
<p>Configuring huey to work with django is actually more simple due to the centralized
nature of django&#8217;s configuration and conventions.  Rather than maintaining a <tt class="docutils literal"><span class="pre">Configuration</span></tt>
object, as in the above example, everything is configured automatically using django
settings.  Following the previous example, we&#8217;ll re-create the bean counting task
using django:</p>
<p>First let&#8217;s get the settings.  In the interests of focusing on the bare minimum
to get things running, here are the only settings you need.  It assumes, in addition
to the <tt class="docutils literal"><span class="pre">huey.djhuey</span></tt> app, a single app called <tt class="docutils literal"><span class="pre">test_app</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">INSTALLED_APPS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;huey.djhuey&#39;</span><span class="p">,</span>
    <span class="s">&#39;test_app&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">HUEY_CONFIG</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;QUEUE&#39;</span><span class="p">:</span> <span class="s">&#39;huey.backends.redis_backend.RedisBlockingQueue&#39;</span><span class="p">,</span>
    <span class="s">&#39;QUEUE_NAME&#39;</span><span class="p">:</span> <span class="s">&#39;test-queue&#39;</span><span class="p">,</span>
    <span class="s">&#39;QUEUE_CONNECTION&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;host&#39;</span><span class="p">:</span> <span class="s">&#39;localhost&#39;</span><span class="p">,</span>
        <span class="s">&#39;port&#39;</span><span class="p">:</span> <span class="mi">6379</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s">&#39;THREADS&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">test_app</span></tt> will be as simple as possible:</p>
<ul>
<li><p class="first">__init__.py (empty)</p>
</li>
<li><p class="first">manage.py (standard)</p>
</li>
<li><p class="first">settings.py</p>
</li>
<li><dl class="first docutils">
<dt>test_app/</dt>
<dd><ul class="first last simple">
<li>__init__.py (empty)</li>
<li>models.py (empty)</li>
<li>commands.py</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>The only file with any code in it is <tt class="docutils literal"><span class="pre">test_app.commands</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">huey.djhuey.decorators</span> <span class="kn">import</span> <span class="n">queue_command</span>


<span class="nd">@queue_command</span>
<span class="k">def</span> <span class="nf">count_beans</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;Counted </span><span class="si">%s</span><span class="s"> beans&#39;</span> <span class="o">%</span> <span class="n">number</span>
</pre></div>
</div>
<p>If you&#8217;re comparing against the example describe in the previous section, there
are a couple key differences:</p>
<ul class="simple">
<li>import has change from <tt class="docutils literal"><span class="pre">huey.decorators</span></tt> to <tt class="docutils literal"><span class="pre">huey.djhuey.decorators</span></tt></li>
<li><tt class="docutils literal"><span class="pre">&#64;queue_command</span></tt> decorator does not take any parameters</li>
</ul>
<p>Let&#8217;s test it out:</p>
<ol class="arabic simple">
<li>Start up the consumer using the management command: <tt class="docutils literal"><span class="pre">./manage.py</span> <span class="pre">run_huey</span></tt> (<tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">run_huey</span></tt> also works)</li>
<li>Open up a shell: <tt class="docutils literal"><span class="pre">./manage.py</span> <span class="pre">shell</span></tt></li>
<li>Try running the <tt class="docutils literal"><span class="pre">count_beans()</span></tt> function a couple times</li>
</ol>
<img alt="_images/example_django.jpg" src="_images/example_django.jpg" />
<div class="section" id="configuring-a-result-backend">
<h3>Configuring a result backend<a class="headerlink" href="#configuring-a-result-backend" title="Permalink to this headline">¶</a></h3>
<p>To enable support for task results, define a <tt class="docutils literal"><span class="pre">RESULT_STORE</span></tt> in the django
settings module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">HUEY_CONFIG</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;QUEUE&#39;</span><span class="p">:</span> <span class="s">&#39;huey.backends.redis_backend.RedisBlockingQueue&#39;</span><span class="p">,</span>
    <span class="s">&#39;QUEUE_NAME&#39;</span><span class="p">:</span> <span class="s">&#39;test-queue&#39;</span><span class="p">,</span>
    <span class="s">&#39;QUEUE_CONNECTION&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;host&#39;</span><span class="p">:</span> <span class="s">&#39;localhost&#39;</span><span class="p">,</span>
        <span class="s">&#39;port&#39;</span><span class="p">:</span> <span class="mi">6379</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s">&#39;RESULT_STORE&#39;</span><span class="p">:</span> <span class="s">&#39;huey.backends.redis_backend.RedisDataStore&#39;</span><span class="p">,</span>
    <span class="s">&#39;RESULT_STORE_CONNECTION&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;host&#39;</span><span class="p">:</span> <span class="s">&#39;localhost&#39;</span><span class="p">,</span>
        <span class="s">&#39;port&#39;</span><span class="p">:</span> <span class="mi">6379</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s">&#39;THREADS&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Getting Started</a><ul>
<li><a class="reference internal" href="#general-guide">General guide</a><ul>
<li><a class="reference internal" href="#trying-it-out-yourself">Trying it out yourself</a></li>
<li><a class="reference internal" href="#getting-results-from-jobs">Getting results from jobs</a></li>
<li><a class="reference internal" href="#executing-tasks-in-the-future">Executing tasks in the future</a></li>
<li><a class="reference internal" href="#retrying-tasks-that-fail">Retrying tasks that fail</a></li>
<li><a class="reference internal" href="#executing-tasks-at-regular-intervals">Executing tasks at regular intervals</a></li>
<li><a class="reference internal" href="#reading-more">Reading more</a></li>
</ul>
</li>
<li><a class="reference internal" href="#django-integration">Django integration</a><ul>
<li><a class="reference internal" href="#configuring-a-result-backend">Configuring a result backend</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installation.html"
                        title="previous chapter">Installing</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="imports.html"
                        title="next chapter">Understanding how commands are imported</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/getting-started.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="imports.html" title="Understanding how commands are imported"
             >next</a> |</li>
        <li class="right" >
          <a href="installation.html" title="Installing"
             >previous</a> |</li>
        <li><a href="index.html">huey 0.2.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, charles leifer.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>