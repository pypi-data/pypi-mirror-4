from pyutil import benchutil

import hashlib, random, os

from decimal import Decimal
D=Decimal

p1 = 'a'*32
p1a = 'a'*32
p2 = 'a'*31+'b' # close, but no cigar
p3 = 'b'*32 # different in the first byte

def randstr(n, alphabetsize):
    alphabet = [ chr(x) for x in range(alphabetsize) ] 
    return ''.join([random.choice(alphabet) for i in range(n)])

def compare(n, f, a, b):
    for i in xrange(n):
        f(a, b)

def eqeqcomp(a, b):
    return a == b

def sillycomp(a, b):
    # This exposes a lot of information in its timing about how many leading bytes match.
    for i in range(len(a)):
        if a[i] != b[i]:
            return False
        for i in xrange(2**9):
            pass
    if len(a) == len(b):
        return True
    else:
        return False

def hashcomp(a, b):
    # Brian Warner invented this for Tahoe-LAFS. It seems like it should be very safe agaist timing leakage of any kind, because of the inclusion of a new random randkey every time. Note that exposing the value of the hash (i.e. the output of md5(randkey+secret)) is *not* a security problem. You can post that on your web site and let all attackers have it, no problem. (Provided that the value of "randkey" remains secret.)

    randkey = os.urandom(32)
    return hashlib.md5(randkey+ a).digest() == hashlib.md5(randkey+b).digest()

def xorcomp(a, b):
    # This appears to be the most popular timing-insensitive string comparison function. I'm not completely sure it is fully timing-insensitive. (There are all sorts of funny things inside Python, such as caching of integer objects < 100...)
    if len(a) != len(b):
        return False
    result = 0
    for x, y in zip(a, b):
        result |= ord(x) ^ ord(y)
    return result == 0

def print_measurements():
    N=10**4
    REPS=10**2

    print "all times are in nanoseconds per comparison (in scientific notation)"
    print

    for comparator in [eqeqcomp, hashcomp, xorcomp, sillycomp]:
        print "using comparator ", comparator

        # for (a, b, desc) in [(p1, p1a, 'same'), (p1, p2, 'close'), (p1, p3, 'far')]:
        trials = [(p1, p1a, 'same'), (p1, p2, 'close'), (p1, p3, 'far')]
        random.shuffle(trials)
        for (a, b, desc) in trials:
            print "comparing two strings that are %s to each other" % (desc,)

            def f(n):
                compare(n, comparator, a, b)

            benchutil.rep_bench(f, N, UNITS_PER_SECOND=10**9, MAXREPS=REPS)

            print

def try_to_crack_secret(cracker, comparator, secretlen, alphabetsize):
    secret = randstr(secretlen, alphabetsize)

    def test_guess(x):
        return comparator(secret, x)

    print "Giving cracker %s a chance to figure out the secret. Don't tell him, but the secret is %s. Whenever he makes a guess, we'll use comparator %s to decide if his guess is right ..." % (cracker, secret.encode('hex'), comparator,)

    guess = cracker(test_guess, secretlen, alphabetsize)

    print "Cracker %s guessed %r" % (cracker, guess,)
    if guess == secret:
        print "HE FIGURED IT OUT!? HOW DID HE DO THAT."
    else:
        print "HAHA. Our secret is safe."

def byte_at_a_time_cracker(test_guess, secretlen, alphabetsize):
    # If we were cleverer, we'd add some backtracking behaviour where, if we can't find any x such that ABCx stands out from the crowd as taking longer than all the other ABCy's, then we start to think that we've taken a wrong step and we go back to trying ABy's. Make sense? But we're not that clever. Once we take a step, we don't backtrack.

    print 

    guess=[]

    while len(guess) < secretlen:
        best_next_byte = None
        best_next_byte_time = None

        # For each possible byte...
        for next_byte in range(alphabetsize):
            c = chr(next_byte)

            # Construct a guess with our best candidate so far...
            candidate_guess = guess[:]

            # Plus that byte...
            candidate_guess.append(c)
            s = ''.join(candidate_guess)

            # Plus random bytes...
            s += os.urandom(32 - len(s))

            # And see how long it takes the test_guess to consider it...
            def f(n):
                for i in xrange(n):
                    test_guess(s)

            times = benchutil.rep_bench(f, 10**7, MAXREPS=10**3, quiet=True)

            fastesttime = times['mean']

            print "%s..."%(c.encode('hex'),),
            if best_next_byte is None or fastesttime > best_next_byte_time:
                print "new candidate for slowest next-char: %s, took: %s" % (c.encode('hex'), fastesttime,),

                best_next_byte_time = fastesttime
                best_next_byte = c

        # Okay we've tried all possible next bytes. Our guess is this one (the one that took longest to be tested by test_guess):
        guess.append(best_next_byte)
        print "SLOWEST next-char %s! Current guess at secret: %s" % (best_next_byte.encode('hex'), ''.join(guess).encode('hex'),)

    guess = ''.join(guess)
    print "Our guess for the secret: %r" % (guess,)
    return guess

if __name__ == '__main__':
    import sys
    secretlen = int(sys.argv[1])
    alphabetsize = int(sys.argv[2])
    if alphabetsize > 256:
        raise Exception("We assume we can fit one element of the alphabet into a byte.")

    print "secretlen: %d, alphabetsize: %d" % (secretlen, alphabetsize,)
    
    # try_to_crack_secret(byte_at_a_time_cracker, sillycomp, secretlen, alphabetsize)
    try_to_crack_secret(byte_at_a_time_cracker, eqeqcomp, secretlen, alphabetsize)
