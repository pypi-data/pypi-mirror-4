import threading
import time
import weakref

from paste.deploy.converters import asbool
from pylons import request

from pylons_debugtoolbar.panels import DebugPanel
from pylons_debugtoolbar.utils import format_sql, db_to_unicode


lock = threading.Lock()


try:
    from sqlalchemy import event
    from sqlalchemy.engine.base import Engine


    @event.listens_for(Engine, "before_cursor_execute")
    def _before_cursor_execute(conn, cursor, stmt, params, context, execmany):
        setattr(conn, 'pdtb_start_timer', time.time())


    @event.listens_for(Engine, "after_cursor_execute")
    def _after_cursor_execute(conn, cursor, stmt, params, context, execmany):
        stop_timer = time.time()
        if request is not None:
            with lock:
                engines = getattr(request, 'pdtb_sqla_engines', {})
                engines[id(conn.engine)] = weakref.ref(conn.engine)
                setattr(request, 'pdtb_sqla_engines', engines)
                queries = getattr(request, 'pdtb_sqla_queries', [])
                duration = round((stop_timer - conn.pdtb_start_timer)*1000, 2)
                queries.append({
                    'engine_id': id(conn.engine),
                    'duration': duration,
                    'statement': stmt,
                    'parameters': params,
                })
                setattr(request, 'pdtb_sqla_queries', queries)
        delattr(conn, 'pdtb_start_timer')

    has_sqla = True
except ImportError:
    has_sqla = False


class SQLAlchemyDebugPanel(DebugPanel):
    """Panel that displays the SQL generated by SQLAlchemy plus the time each
    SQL statement took in milliseconds.
    """
    name = 'SQLAlchemy'
    has_content = has_sqla

    def __init__(self, request, config):
        self.config = config
        if asbool(config.get('pdtb.panel_sqlalchemy', True)):
            self.is_active = True

    @property
    def queries(self):
        return getattr(request, 'pdtb_sqla_queries', [])

    def nav_title(self):
        return 'SQLAlchemy'

    def nav_subtitle(self):
        queries_info = self._get_total_queries_info()
        return "%(count)s queries (%(duration)sms)" % dict(
            count=queries_info['count'],
            duration=queries_info['duration'],
        )

    def title(self):
        queries_info = self._get_total_queries_info()
        return "SQLAlchemy queries: %(count)s queries (%(duration)sms)" % dict(
            count=queries_info['count'],
            duration=queries_info['duration'],
        )

    def _get_total_queries_info(self):
        return {
            'count': len(self.queries),
            'duration': round(sum([q['duration'] for q in self.queries]), 4),
        }

    def content(self):
        if not self.queries:
            return 'No queries executed in request.'

        data = []
        for query in sorted(self.queries, key=lambda x: x['duration'], reverse=True):
            result = headers = None
            if asbool(self.config.get('pdtb.sqlalchemy_result')):
                engine_id = query['engine_id']
                is_select = (
                    query['statement'].lower().strip().startswith('select')
                    and engine_id
                )
                if is_select:
                    engines = getattr(request, 'pdtb_sqla_engines')
                    eng = engines[int(engine_id)]()
                    res = eng.execute(query['statement'], query['parameters'])
                    result = res.fetchall()
                    headers = res.keys()
            data.append({
                'duration': query['duration'],
                'sql': format_sql(query['statement'] % query['parameters']),
                'result': result,
                'headers': headers,
            })

        max_len = self.config.get('pdtb.sqlalchemy_result_max_len', 1000)
        vars = {
            'queries': data,
            'db_to_unicode': db_to_unicode,
            'max_length': int(max_len),
        }
        delattr(request, 'pdtb_sqla_queries')

        return self.render('/panels/templates/sqlalchemy.mako', **vars)
