
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API &mdash; dogpile.cache 0.4.3 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="dogpile.cache 0.4.3 documentation" href="index.html" />
    <link rel="next" title="Changelog" href="changelog.html" />
    <link rel="prev" title="Usage Guide" href="usage.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Changelog"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="usage.html" title="Usage Guide"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">dogpile.cache 0.4.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-dogpile.cache.region">
<span id="region"></span><h2>Region<a class="headerlink" href="#module-dogpile.cache.region" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="dogpile.cache.region.CacheRegion">
<em class="property">class </em><tt class="descclassname">dogpile.cache.region.</tt><tt class="descname">CacheRegion</tt><big>(</big><em>name=None</em>, <em>function_key_generator=&lt;function function_key_generator at 0x1019032a8&gt;</em>, <em>key_mangler=None</em>, <em>async_creation_runner=None</em><big>)</big><a class="headerlink" href="#dogpile.cache.region.CacheRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>A front end to a particular cache backend.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; Optional, a string name for the region.
This isn&#8217;t used internally
but can be accessed via the <tt class="docutils literal"><span class="pre">.name</span></tt> parameter, helpful
for configuring a region from a config file.</li>
<li><strong>function_key_generator</strong> &#8211; <p>Optional.  A
function that will produce a &#8220;cache key&#8221; given
a data creation function and arguments, when using
the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></tt></a> method.
The structure of this function
should be two levels: given the data creation function,
return a new function that generates the key based on
the given arguments.  Such as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_key_generator</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">def</span> <span class="nf">generate_key</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">namespace</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">fname</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">generate_key</span>


<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">(</span>
    <span class="n">function_key_generator</span> <span class="o">=</span> <span class="n">my_key_generator</span>
<span class="p">)</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s">&quot;dogpile.cache.dbm&quot;</span><span class="p">,</span>
    <span class="n">expiration_time</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
        <span class="s">&quot;filename&quot;</span><span class="p">:</span><span class="s">&quot;file.dbm&quot;</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">namespace</span></tt> is that passed to
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></tt></a>.  It&#8217;s not consulted
outside this function, so in fact can be of any form.
For example, it can be passed as a tuple, used to specify
arguments to pluck from **kw:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_key_generator</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">generate_key</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span><span class="n">kw</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">namespace</span><span class="p">]</span> <span class="o">+</span>
                <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">]</span>
            <span class="p">)</span>
</pre></div>
</div>
<p>Where the decorator might be used as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@my_region.cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">my_data</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><strong>key_mangler</strong> &#8211; Function which will be used on all incoming
keys before passing to the backend.  Defaults to <tt class="docutils literal"><span class="pre">None</span></tt>,
in which case the key mangling function recommended by
the cache backend will be used.    A typical mangler
is the SHA1 mangler found at <a class="reference internal" href="#dogpile.cache.util.sha1_mangle_key" title="dogpile.cache.util.sha1_mangle_key"><tt class="xref py py-func docutils literal"><span class="pre">sha1_mangle_key()</span></tt></a>
which coerces keys into a SHA1
hash, so that the string length is fixed.  To
disable all key mangling, set to <tt class="docutils literal"><span class="pre">False</span></tt>.   Another typical
mangler is the built-in Python function <tt class="docutils literal"><span class="pre">str</span></tt>, which can be used
to convert non-string or Unicode keys to bytestrings, which is
needed when using a backend such as bsddb or dbm under Python 2.x
in conjunction with Unicode keys.</li>
<li><strong>async_creation_runner</strong> &#8211; <p>A callable that, when specified,
will be passed to and called by dogpile.lock when
there is a stale value present in the cache.  It will be passed the
mutex and is responsible releasing that mutex when finished.
This can be used to defer the computation of expensive creator
functions to later points in the future by way of, for example, a
background thread, a long-running queue, or a task manager system
like Celery.</p>
<p>For a specific example using async_creation_runner, new values can
be created in a background thread like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">def</span> <span class="nf">async_creation_runner</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">somekey</span><span class="p">,</span> <span class="n">creator</span><span class="p">,</span> <span class="n">mutex</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Used by dogpile.core:Lock when appropriate  &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">runner</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">creator</span><span class="p">()</span>
            <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">somekey</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">mutex</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">runner</span><span class="p">)</span>
    <span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>


<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">(</span>
    <span class="n">async_creation_runner</span><span class="o">=</span><span class="n">async_creation_runner</span><span class="p">,</span>
<span class="p">)</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s">&#39;dogpile.cache.memcached&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
        <span class="s">&#39;url&#39;</span><span class="p">:</span> <span class="s">&#39;127.0.0.1:11211&#39;</span><span class="p">,</span>
        <span class="s">&#39;distributed_lock&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Remember that the first request for a key with no associated
value will always block; async_creator will not be invoked.
However, subsequent requests for cached-but-expired values will
still return promptly.  They will be refreshed by whatever
asynchronous means the provided async_creation_runner callable
implements.</p>
<p>By default the async_creation_runner is disabled and is set
to <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.4.2: </span>added the async_creation_runner
feature.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.cache_on_arguments">
<tt class="descname">cache_on_arguments</tt><big>(</big><em>namespace=None</em>, <em>expiration_time=None</em>, <em>should_cache_fn=None</em><big>)</big><a class="headerlink" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>A function decorator that will cache the return
value of the function using a key derived from the
function itself and its arguments.</p>
<p>The decorator internally makes use of the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></tt></a> method to access the
cache and conditionally call the function.  See that
method for additional behavioral details.</p>
<p>E.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@someregion.cache_on_arguments</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">generate_something</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">somedatabase</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>The decorated function can then be called normally, where
data will be pulled from the cache region unless a new
value is needed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span> <span class="o">=</span> <span class="n">generate_something</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>The function is also given an attribute <tt class="docutils literal"><span class="pre">invalidate</span></tt>, which
provides for invalidation of the value.  Pass to <tt class="docutils literal"><span class="pre">invalidate()</span></tt>
the same arguments you&#8217;d pass to the function itself to represent
a particular value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">generate_something</span><span class="o">.</span><span class="n">invalidate</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>Another attribute <tt class="docutils literal"><span class="pre">set</span></tt> is added to provide extra caching
possibilities relative to the function.   This is a convenience
method for <a class="reference internal" href="#dogpile.cache.region.CacheRegion.set" title="dogpile.cache.region.CacheRegion.set"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.set()</span></tt></a> which will store a given
value directly without calling the decorated function.
The value to be cached is passed as the first argument, and the
arguments which would normally be passed to the function
should follow:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">generate_something</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>The above example is equivalent to calling <tt class="docutils literal"><span class="pre">generate_something(5,</span> <span class="pre">6)</span></tt>,
if the function were to produce the value <tt class="docutils literal"><span class="pre">3</span></tt> as the value to be
cached.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.4.1: </span>Added set() method to decorated function.</p>
<p>The default key generation will use the name
of the function, the module name for the function,
the arguments passed, as well as an optional &#8220;namespace&#8221;
parameter in order to generate a cache key.</p>
<p>Given a function <tt class="docutils literal"><span class="pre">one</span></tt> inside the module
<tt class="docutils literal"><span class="pre">myapp.tools</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@region.cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>Above, calling <tt class="docutils literal"><span class="pre">one(3,</span> <span class="pre">4)</span></tt> will produce a
cache key as follows:</p>
<div class="highlight-python"><pre>myapp.tools:one|foo|3 4</pre>
</div>
<p>The key generator will ignore an initial argument
of <tt class="docutils literal"><span class="pre">self</span></tt> or <tt class="docutils literal"><span class="pre">cls</span></tt>, making the decorator suitable
(with caveats) for use with instance or class methods.
Given the example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@region.cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="s">&quot;foo&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>The cache key above for <tt class="docutils literal"><span class="pre">MyClass().one(3,</span> <span class="pre">4)</span></tt> will
again produce the same cache key of <tt class="docutils literal"><span class="pre">myapp.tools:one|foo|3</span> <span class="pre">4</span></tt> -
the name <tt class="docutils literal"><span class="pre">self</span></tt> is skipped.</p>
<p>The <tt class="docutils literal"><span class="pre">namespace</span></tt> parameter is optional, and is used
normally to disambiguate two functions of the same
name within the same module, as can occur when decorating
instance or class methods as below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@region.cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="s">&#39;MC&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">somemethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="s">&quot;&quot;</span>

<span class="k">class</span> <span class="nc">MyOtherClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@region.cache_on_arguments</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="s">&#39;MOC&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">somemethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="s">&quot;&quot;</span>
</pre></div>
</div>
<p>Above, the <tt class="docutils literal"><span class="pre">namespace</span></tt> parameter disambiguates
between <tt class="docutils literal"><span class="pre">somemethod</span></tt> on <tt class="docutils literal"><span class="pre">MyClass</span></tt> and <tt class="docutils literal"><span class="pre">MyOtherClass</span></tt>.
Python class declaration mechanics otherwise prevent
the decorator from having awareness of the <tt class="docutils literal"><span class="pre">MyClass</span></tt>
and <tt class="docutils literal"><span class="pre">MyOtherClass</span></tt> names, as the function is received
by the decorator before it becomes an instance method.</p>
<p>The function key generation can be entirely replaced
on a per-region basis using the <tt class="docutils literal"><span class="pre">function_key_generator</span></tt>
argument present on <a class="reference internal" href="#dogpile.cache.region.make_region" title="dogpile.cache.region.make_region"><tt class="xref py py-func docutils literal"><span class="pre">make_region()</span></tt></a> and
<a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a>. If defaults to
<a class="reference internal" href="#dogpile.cache.util.function_key_generator" title="dogpile.cache.util.function_key_generator"><tt class="xref py py-func docutils literal"><span class="pre">function_key_generator()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>namespace</strong> &#8211; optional string argument which will be
established as part of the cache key.   This may be needed
to disambiguate functions of the same name within the same
source file, such as those
associated with classes - note that the decorator itself
can&#8217;t see the parent class on a function as the class is
being declared.</li>
<li><strong>expiration_time</strong> &#8211; if not None, will override the normal
expiration time.</li>
<li><strong>should_cache_fn</strong> &#8211; <p>passed to <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></tt></a>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.4.3.</span></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.configure">
<tt class="descname">configure</tt><big>(</big><em>backend</em>, <em>expiration_time=None</em>, <em>arguments=None</em>, <em>_config_argument_dict=None</em>, <em>_config_prefix=None</em><big>)</big><a class="headerlink" href="#dogpile.cache.region.CacheRegion.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure a <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a>.</p>
<p>The <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a> itself
is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>backend</strong> &#8211; Required.  This is the name of the
<a class="reference internal" href="#dogpile.cache.api.CacheBackend" title="dogpile.cache.api.CacheBackend"><tt class="xref py py-class docutils literal"><span class="pre">CacheBackend</span></tt></a> to use, and is resolved by loading
the class from the <tt class="docutils literal"><span class="pre">dogpile.cache</span></tt> entrypoint.</li>
<li><strong>expiration_time</strong> &#8211; Optional.  The expiration time passed
to the dogpile system.  The <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></tt></a>
method as well as the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></tt></a>
decorator (though note:  <strong>not</strong> the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get" title="dogpile.cache.region.CacheRegion.get"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get()</span></tt></a>
method) will call upon the value creation function after this
time period has passed since the last generation.</li>
<li><strong>arguments</strong> &#8211; Optional.  The structure here is passed
directly to the constructor of the <a class="reference internal" href="#dogpile.cache.api.CacheBackend" title="dogpile.cache.api.CacheBackend"><tt class="xref py py-class docutils literal"><span class="pre">CacheBackend</span></tt></a>
in use, though is typically a dictionary.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.configure_from_config">
<tt class="descname">configure_from_config</tt><big>(</big><em>config_dict</em>, <em>prefix</em><big>)</big><a class="headerlink" href="#dogpile.cache.region.CacheRegion.configure_from_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure from a configuration dictionary
and a prefix.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">local_region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span>
<span class="n">memcached_region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span>

<span class="c"># regions are ready to use for function</span>
<span class="c"># decorators, but not yet for actual caching</span>

<span class="c"># later, when config is available</span>
<span class="n">myconfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&quot;cache.local.backend&quot;</span><span class="p">:</span><span class="s">&quot;dogpile.cache.dbm&quot;</span><span class="p">,</span>
    <span class="s">&quot;cache.local.arguments.filename&quot;</span><span class="p">:</span><span class="s">&quot;/path/to/dbmfile.dbm&quot;</span><span class="p">,</span>
    <span class="s">&quot;cache.memcached.backend&quot;</span><span class="p">:</span><span class="s">&quot;dogpile.cache.pylibmc&quot;</span><span class="p">,</span>
    <span class="s">&quot;cache.memcached.arguments.url&quot;</span><span class="p">:</span><span class="s">&quot;127.0.0.1, 10.0.0.1&quot;</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">local_region</span><span class="o">.</span><span class="n">configure_from_config</span><span class="p">(</span><span class="n">myconfig</span><span class="p">,</span> <span class="s">&quot;cache.local.&quot;</span><span class="p">)</span>
<span class="n">memcached_region</span><span class="o">.</span><span class="n">configure_from_config</span><span class="p">(</span><span class="n">myconfig</span><span class="p">,</span>
                                    <span class="s">&quot;cache.memcached.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.delete">
<tt class="descname">delete</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#dogpile.cache.region.CacheRegion.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a value from the cache.</p>
<p>This operation is idempotent (can be called multiple times, or on a
non-existent key, safely)</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.get">
<tt class="descname">get</tt><big>(</big><em>key</em>, <em>expiration_time=None</em>, <em>ignore_expiration=False</em><big>)</big><a class="headerlink" href="#dogpile.cache.region.CacheRegion.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a value from the cache, based on the given key.</p>
<p>If the value is not present, the method returns the token
<tt class="docutils literal"><span class="pre">NO_VALUE</span></tt>. <tt class="docutils literal"><span class="pre">NO_VALUE</span></tt> evaluates to False, but is separate from
<tt class="docutils literal"><span class="pre">None</span></tt> to distinguish between a cached value of <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>By default, the configured expiration time of the
<a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a>, or alternatively the expiration
time supplied by the <tt class="docutils literal"><span class="pre">expiration_time</span></tt> argument,
is tested against the creation time of the retrieved
value versus the current time (as reported by <tt class="docutils literal"><span class="pre">time.time()</span></tt>).
If stale, the cached value is ignored and the <tt class="docutils literal"><span class="pre">NO_VALUE</span></tt>
token is returned.  Passing the flag <tt class="docutils literal"><span class="pre">ignore_expiration=True</span></tt>
bypasses the expiration time check.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.3.0: </span><a class="reference internal" href="#dogpile.cache.region.CacheRegion.get" title="dogpile.cache.region.CacheRegion.get"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get()</span></tt></a> now checks the value&#8217;s creation time
against the expiration time, rather than returning
the value unconditionally.</p>
<p>The method also interprets the cached value in terms
of the current &#8220;invalidation&#8221; time as set by
the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><tt class="xref py py-meth docutils literal"><span class="pre">invalidate()</span></tt></a> method.   If a value is present,
but its creation time is older than the current
invalidation time, the <tt class="docutils literal"><span class="pre">NO_VALUE</span></tt> token is returned.
Passing the flag <tt class="docutils literal"><span class="pre">ignore_expiration=True</span></tt> bypasses
the invalidation time check.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.3.0: </span>Support for the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.invalidate()</span></tt></a>
method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> &#8211; Key to be retrieved. While it&#8217;s typical for a key to be a
string, it is ultimately passed directly down to the cache backend,
before being optionally processed by the key_mangler function, so can
be of any type recognized by the backend or by the key_mangler
function, if present.</li>
<li><strong>expiration_time</strong> &#8211; <p>Optional expiration time value
which will supersede that configured on the <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a>
itself.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.3.0.</span></p>
</li>
<li><strong>ignore_expiration</strong> &#8211; <p>if <tt class="docutils literal"><span class="pre">True</span></tt>, the value is returned
from the cache if present, regardless of configured
expiration times or whether or not <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><tt class="xref py py-meth docutils literal"><span class="pre">invalidate()</span></tt></a>
was called.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.3.0.</span></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.get_or_create">
<tt class="descname">get_or_create</tt><big>(</big><em>key</em>, <em>creator</em>, <em>expiration_time=None</em>, <em>should_cache_fn=None</em><big>)</big><a class="headerlink" href="#dogpile.cache.region.CacheRegion.get_or_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cached value based on the given key.</p>
<p>If the value does not exist or is considered to be expired
based on its creation time, the given
creation function may or may not be used to recreate the value
and persist the newly generated value in the cache.</p>
<p>If the creation function returns <tt class="xref py py-const docutils literal"><span class="pre">NO_VALUE</span></tt>, nothing is cached.
Note that if the returns <cite>None</cite>, <cite>None</cite> will be cached.</p>
<p>Whether or not the function is used depends on if the
<em>dogpile lock</em> can be acquired or not.  If it can&#8217;t, it means
a different thread or process is already running a creation
function for this key against the cache.  When the dogpile
lock cannot be acquired, the method will block if no
previous value is available, until the lock is released and
a new value available.  If a previous value
is available, that value is returned immediately without blocking.</p>
<p>If the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><tt class="xref py py-meth docutils literal"><span class="pre">invalidate()</span></tt></a> method has been called, and
the retrieved value&#8217;s timestamp is older than the invalidation
timestamp, the value is unconditionally prevented from
being returned.  The method will attempt to acquire the dogpile
lock to generate a new value, or will wait
until the lock is released to return the new value.</p>
<p class="versionchanged">
<span class="versionmodified">Changed in version 0.3.0: </span>The value is unconditionally regenerated if the creation
time is older than the last call to <a class="reference internal" href="#dogpile.cache.region.CacheRegion.invalidate" title="dogpile.cache.region.CacheRegion.invalidate"><tt class="xref py py-meth docutils literal"><span class="pre">invalidate()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> &#8211; Key to be retrieved. While it&#8217;s typical for a key to be a
string, it is ultimately passed directly down to the cache backend,
before being optionally processed by the key_mangler function, so can
be of any type recognized by the backend or by the key_mangler
function, if present.</li>
<li><strong>creator</strong> &#8211; function which creates a new value.</li>
<li><strong>expiration_time</strong> &#8211; optional expiration time which will overide
the expiration time already configured on this <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a>
if not None.   To set no expiration, use the value -1.</li>
<li><strong>should_cache_fn</strong> &#8211; <p>optional callable function which will receive the
value returned by the &#8220;creator&#8221;, and will then return True or False,
indicating if the value should actually be cached or not.  If it
returns False, the value is still returned, but isn&#8217;t cached.
E.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">dont_cache_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

<span class="n">value</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="s">&quot;some key&quot;</span><span class="p">,</span>
                    <span class="n">create_value</span><span class="p">,</span>
                    <span class="n">should_cache_fn</span><span class="o">=</span><span class="n">dont_cache_none</span><span class="p">)</span>
</pre></div>
</div>
<p>Above, the function returns the value of create_value() if
the cache is invalid, however if the return value is None,
it won&#8217;t be cached.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.4.3.</span></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>See also:</p>
<p><a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></tt></a> - applies <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><tt class="xref py py-meth docutils literal"><span class="pre">get_or_create()</span></tt></a>
to any function using a decorator.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.invalidate">
<tt class="descname">invalidate</tt><big>(</big><big>)</big><a class="headerlink" href="#dogpile.cache.region.CacheRegion.invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate this <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a>.</p>
<p>Invalidation works by setting a current timestamp
(using <tt class="docutils literal"><span class="pre">time.time()</span></tt>)
representing the &#8220;minimum creation time&#8221; for
a value.  Any retrieved value whose creation
time is prior to this timestamp
is considered to be stale.  It does not
affect the data in the cache in any way, and is also
local to this instance of <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a>.</p>
<p>Once set, the invalidation time is honored by
the <a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></tt></a> and
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get" title="dogpile.cache.region.CacheRegion.get"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get()</span></tt></a> methods.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.3.0.</span></p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.region.CacheRegion.set">
<tt class="descname">set</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#dogpile.cache.region.CacheRegion.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Place a new value in the cache under the given key.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dogpile.cache.region.make_region">
<tt class="descclassname">dogpile.cache.region.</tt><tt class="descname">make_region</tt><big>(</big><em>*arg</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#dogpile.cache.region.make_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a new <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a>.</p>
<p>Currently, <a class="reference internal" href="#dogpile.cache.region.make_region" title="dogpile.cache.region.make_region"><tt class="xref py py-func docutils literal"><span class="pre">make_region()</span></tt></a> is a passthrough
to <a class="reference internal" href="#dogpile.cache.region.CacheRegion" title="dogpile.cache.region.CacheRegion"><tt class="xref py py-class docutils literal"><span class="pre">CacheRegion</span></tt></a>.  See that class for
constructor arguments.</p>
</dd></dl>

<dl class="data">
<dt id="dogpile.cache.region.value_version">
<tt class="descclassname">dogpile.cache.region.</tt><tt class="descname">value_version</tt><em class="property"> = 1</em><a class="headerlink" href="#dogpile.cache.region.value_version" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer placed in the <a class="reference internal" href="#dogpile.cache.api.CachedValue" title="dogpile.cache.api.CachedValue"><tt class="xref py py-class docutils literal"><span class="pre">CachedValue</span></tt></a>
so that new versions of dogpile.cache can detect cached
values from a previous, backwards-incompatible version.</p>
</dd></dl>

<dl class="function">
<dt id="dogpile.cache.util.function_key_generator">
<tt class="descclassname">dogpile.cache.util.</tt><tt class="descname">function_key_generator</tt><big>(</big><em>namespace</em>, <em>fn</em><big>)</big><a class="headerlink" href="#dogpile.cache.util.function_key_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a function that generates a string
key, based on a given function as well as
arguments to the returned function itself.</p>
<p>This is used by <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></tt></a>
to generate a cache key from a decorated function.</p>
<p>It can be replaced using the <tt class="docutils literal"><span class="pre">function_key_generator</span></tt>
argument passed to <a class="reference internal" href="#dogpile.cache.region.make_region" title="dogpile.cache.region.make_region"><tt class="xref py py-func docutils literal"><span class="pre">make_region()</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="backend-api">
<h2>Backend API<a class="headerlink" href="#backend-api" title="Permalink to this headline">¶</a></h2>
<p>See the section <a class="reference internal" href="usage.html#creating-backends"><em>Creating Backends</em></a> for details on how to
register new backends.</p>
<span class="target" id="module-dogpile.cache.api"></span><dl class="class">
<dt id="dogpile.cache.api.CacheBackend">
<em class="property">class </em><tt class="descclassname">dogpile.cache.api.</tt><tt class="descname">CacheBackend</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#dogpile.cache.api.CacheBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for backend implementations.</p>
<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.delete">
<tt class="descname">delete</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#dogpile.cache.api.CacheBackend.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a value from the cache.</p>
<p>The key will be whatever was passed
to the registry, processed by the
&#8220;key mangling&#8221; function, if any.</p>
<p>The behavior here should be idempotent,
that is, can be called any number of times
regardless of whether or not the
key exists.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.get">
<tt class="descname">get</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#dogpile.cache.api.CacheBackend.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a value from the cache.</p>
<p>The returned value should be an instance of
<a class="reference internal" href="#dogpile.cache.api.CachedValue" title="dogpile.cache.api.CachedValue"><tt class="xref py py-class docutils literal"><span class="pre">CachedValue</span></tt></a>, or <tt class="docutils literal"><span class="pre">NO_VALUE</span></tt> if
not present.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.get_mutex">
<tt class="descname">get_mutex</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#dogpile.cache.api.CacheBackend.get_mutex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an optional mutexing object for the given key.</p>
<p>This object need only provide an <tt class="docutils literal"><span class="pre">acquire()</span></tt>
and <tt class="docutils literal"><span class="pre">release()</span></tt> method.</p>
<p>May return <tt class="docutils literal"><span class="pre">None</span></tt>, in which case the dogpile
lock will use a regular <tt class="docutils literal"><span class="pre">threading.Lock</span></tt>
object to mutex concurrent threads for
value creation.   The default implementation
returns <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>Different backends may want to provide various
kinds of &#8220;mutex&#8221; objects, such as those which
link to lock files, distributed mutexes,
memcached semaphores, etc.  Whatever
kind of system is best suited for the scope
and behavior of the caching backend.</p>
<p>A mutex that takes the key into account will
allow multiple regenerate operations across
keys to proceed simultaneously, while a mutex
that does not will serialize regenerate operations
to just one at a time across all keys in the region.
The latter approach, or a variant that involves
a modulus of the given key&#8217;s hash value,
can be used as a means of throttling the total
number of value recreation operations that may
proceed at one time.</p>
</dd></dl>

<dl class="attribute">
<dt id="dogpile.cache.api.CacheBackend.key_mangler">
<tt class="descname">key_mangler</tt><em class="property"> = None</em><a class="headerlink" href="#dogpile.cache.api.CacheBackend.key_mangler" title="Permalink to this definition">¶</a></dt>
<dd><p>Key mangling function.</p>
<p>May be None, or otherwise declared
as an ordinary instance method.</p>
</dd></dl>

<dl class="method">
<dt id="dogpile.cache.api.CacheBackend.set">
<tt class="descname">set</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#dogpile.cache.api.CacheBackend.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a value in the cache.</p>
<p>The key will be whatever was passed
to the registry, processed by the
&#8220;key mangling&#8221; function, if any.
The value will always be an instance
of <a class="reference internal" href="#dogpile.cache.api.CachedValue" title="dogpile.cache.api.CachedValue"><tt class="xref py py-class docutils literal"><span class="pre">CachedValue</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dogpile.cache.api.CachedValue">
<em class="property">class </em><tt class="descclassname">dogpile.cache.api.</tt><tt class="descname">CachedValue</tt><a class="headerlink" href="#dogpile.cache.api.CachedValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent a value stored in the cache.</p>
<p><a class="reference internal" href="#dogpile.cache.api.CachedValue" title="dogpile.cache.api.CachedValue"><tt class="xref py py-class docutils literal"><span class="pre">CachedValue</span></tt></a> is a two-tuple of
<tt class="docutils literal"><span class="pre">(payload,</span> <span class="pre">metadata)</span></tt>, where <tt class="docutils literal"><span class="pre">metadata</span></tt>
is dogpile.cache&#8217;s tracking information (
currently the creation time).  The metadata
and tuple structure is pickleable, if
the backend requires serialization.</p>
<dl class="attribute">
<dt id="dogpile.cache.api.CachedValue.metadata">
<tt class="descname">metadata</tt><a class="headerlink" href="#dogpile.cache.api.CachedValue.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Named accessor for the dogpile.cache metadata dictionary.</p>
</dd></dl>

<dl class="attribute">
<dt id="dogpile.cache.api.CachedValue.payload">
<tt class="descname">payload</tt><a class="headerlink" href="#dogpile.cache.api.CachedValue.payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Named accessor for the payload.</p>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="dogpile.cache.api.NO_VALUE">
<tt class="descclassname">dogpile.cache.api.</tt><tt class="descname">NO_VALUE</tt><em class="property"> = &lt;dogpile.cache.api.NoValue object at 0x101910c50&gt;</em><a class="headerlink" href="#dogpile.cache.api.NO_VALUE" title="Permalink to this definition">¶</a></dt>
<dd><p>Value returned from <tt class="docutils literal"><span class="pre">get()</span></tt> that describes
a  key not present.</p>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.api.NoValue">
<em class="property">class </em><tt class="descclassname">dogpile.cache.api.</tt><tt class="descname">NoValue</tt><a class="headerlink" href="#dogpile.cache.api.NoValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Describe a missing cache value.</p>
<p>The <tt class="xref py py-attr docutils literal"><span class="pre">NO_VALUE</span></tt> module global
should be used.</p>
</dd></dl>

</div>
<div class="section" id="module-dogpile.cache.backends.memory">
<span id="backends"></span><h2>Backends<a class="headerlink" href="#module-dogpile.cache.backends.memory" title="Permalink to this headline">¶</a></h2>
<div class="section" id="memory-backend">
<h3>Memory Backend<a class="headerlink" href="#memory-backend" title="Permalink to this headline">¶</a></h3>
<p>Provides a simple dictionary-based backend.</p>
<dl class="class">
<dt id="dogpile.cache.backends.memory.MemoryBackend">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.memory.</tt><tt class="descname">MemoryBackend</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.memory.MemoryBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A backend that uses a plain dictionary.</p>
<p>There is no size management, and values which
are placed into the dictionary will remain
until explicitly removed.   Note that
Dogpile&#8217;s expiration of items is based on
timestamps and does not remove them from
the cache.</p>
<p>E.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="kn">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s">&#39;dogpile.cache.memory&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To use a Python dictionary of your choosing,
it can be passed in with the <tt class="docutils literal"><span class="pre">cache_dict</span></tt>
argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">my_dictionary</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s">&#39;dogpile.cache.memory&#39;</span><span class="p">,</span>
    <span class="n">arguments</span><span class="o">=</span><span class="p">{</span>
        <span class="s">&quot;cache_dict&quot;</span><span class="p">:</span><span class="n">my_dictionary</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<span class="target" id="module-dogpile.cache.backends.memcached"></span><div class="section" id="memcached-backends">
<h3>Memcached Backends<a class="headerlink" href="#memcached-backends" title="Permalink to this headline">¶</a></h3>
<p>Provides backends for talking to <a class="reference external" href="http://memcached.org">memcached</a>.</p>
<dl class="class">
<dt id="dogpile.cache.backends.memcached.GenericMemcachedBackend">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.memcached.</tt><tt class="descname">GenericMemcachedBackend</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for memcached backends.</p>
<p>This base class accepts a number of paramters
common to all backends.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>url</strong> &#8211; the string URL to connect to.  Can be a single
string or a list of strings.  This is the only argument
that&#8217;s required.</li>
<li><strong>distributed_lock</strong> &#8211; boolean, when True, will use a
memcached-lock as the dogpile lock (see <a class="reference internal" href="#dogpile.cache.backends.memcached.MemcachedLock" title="dogpile.cache.backends.memcached.MemcachedLock"><tt class="xref py py-class docutils literal"><span class="pre">MemcachedLock</span></tt></a>).
Use this when multiple
processes will be talking to the same memcached instance.
When left at False, dogpile will coordinate on a regular
threading mutex.</li>
<li><strong>memcached_expire_time</strong> &#8211; <p>integer, when present will
be passed as the <tt class="docutils literal"><span class="pre">time</span></tt> parameter to <tt class="docutils literal"><span class="pre">pylibmc.Client.set</span></tt>.
This is used to set the memcached expiry time for a value.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This parameter is <strong>different</strong> from Dogpile&#8217;s own
<tt class="docutils literal"><span class="pre">expiration_time</span></tt>, which is the number of seconds after
which Dogpile will consider the value to be expired.
When Dogpile considers a value to be expired,
it <strong>continues to use the value</strong> until generation
of a new value is complete, when using
<a class="reference internal" href="#dogpile.cache.region.CacheRegion.get_or_create" title="dogpile.cache.region.CacheRegion.get_or_create"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.get_or_create()</span></tt></a>.
Therefore, if you are setting <tt class="docutils literal"><span class="pre">memcached_expire_time</span></tt>, you&#8217;ll
want to make sure it is greater than <tt class="docutils literal"><span class="pre">expiration_time</span></tt>
by at least enough seconds for new values to be generated,
else the value won&#8217;t be available during a regeneration,
forcing all threads to wait for a regeneration each time
a value expires.</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The <tt class="xref py py-class docutils literal"><span class="pre">GenericMemachedBackend</span></tt> uses a <tt class="docutils literal"><span class="pre">threading.local()</span></tt>
object to store individual client objects per thread,
as most modern memcached clients do not appear to be inherently
threadsafe.</p>
<p>In particular, <tt class="docutils literal"><span class="pre">threading.local()</span></tt> has the advantage over pylibmc&#8217;s
built-in thread pool in that it automatically discards objects
associated with a particular thread when that thread ends.</p>
<dl class="attribute">
<dt id="dogpile.cache.backends.memcached.GenericMemcachedBackend.client">
<tt class="descname">client</tt><a class="headerlink" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend.client" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memcached client.</p>
<p>This uses a threading.local by
default as it appears most modern
memcached libs aren&#8217;t inherently
threadsafe.</p>
</dd></dl>

<dl class="attribute">
<dt id="dogpile.cache.backends.memcached.GenericMemcachedBackend.set_arguments">
<tt class="descname">set_arguments</tt><em class="property"> = {}</em><a class="headerlink" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend.set_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional arguments which will be passed
to the <tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt> method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.memcached.MemcachedBackend">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.memcached.</tt><tt class="descname">MemcachedBackend</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.memcached.MemcachedBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A backend using the standard <a class="reference external" href="http://www.tummy.com/Community/software/python-memcached/">Python-memcached</a>
library.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="kn">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s">&#39;dogpile.cache.memcached&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;url&#39;</span><span class="p">:</span><span class="s">&quot;127.0.0.1:11211&quot;</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.memcached.PylibmcBackend">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.memcached.</tt><tt class="descname">PylibmcBackend</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.memcached.PylibmcBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A backend for the
<a class="reference external" href="http://sendapatch.se/projects/pylibmc/index.html">pylibmc</a>
memcached client.</p>
<p>A configuration illustrating several of the optional
arguments described in the pylibmc documentation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="kn">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s">&#39;dogpile.cache.pylibmc&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;url&#39;</span><span class="p">:[</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">],</span>
        <span class="s">&#39;binary&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span>
        <span class="s">&#39;behaviors&#39;</span><span class="p">:{</span><span class="s">&quot;tcp_nodelay&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span><span class="s">&quot;ketama&quot;</span><span class="p">:</span><span class="bp">True</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Arguments accepted here include those of
<a class="reference internal" href="#dogpile.cache.backends.memcached.GenericMemcachedBackend" title="dogpile.cache.backends.memcached.GenericMemcachedBackend"><tt class="xref py py-class docutils literal"><span class="pre">GenericMemcachedBackend</span></tt></a>, as well as
those below.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>binary</strong> &#8211; sets the <tt class="docutils literal"><span class="pre">binary</span></tt> flag understood by
<tt class="docutils literal"><span class="pre">pylibmc.Client</span></tt>.</li>
<li><strong>behaviors</strong> &#8211; a dictionary which will be passed to
<tt class="docutils literal"><span class="pre">pylibmc.Client</span></tt> as the <tt class="docutils literal"><span class="pre">behaviors</span></tt> parameter.</li>
<li><strong>min_compres_len</strong> &#8211; Integer, will be passed as the
<tt class="docutils literal"><span class="pre">min_compress_len</span></tt> parameter to the <tt class="docutils literal"><span class="pre">pylibmc.Client.set</span></tt>
method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.memcached.BMemcachedBackend">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.memcached.</tt><tt class="descname">BMemcachedBackend</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.memcached.BMemcachedBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A backend for the
<a class="reference external" href="https://github.com/jaysonsantos/python-binary-memcached">python-binary-memcached</a>
memcached client.</p>
<p>This is a pure Python memcached client which
includes the ability to authenticate with a memcached
server using SASL.</p>
<p>A typical configuration using username/password:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="kn">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s">&#39;dogpile.cache.bmemcached&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;url&#39;</span><span class="p">:[</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">],</span>
        <span class="s">&#39;username&#39;</span><span class="p">:</span><span class="s">&#39;scott&#39;</span><span class="p">,</span>
        <span class="s">&#39;password&#39;</span><span class="p">:</span><span class="s">&#39;tiger&#39;</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Arguments which can be passed to the <tt class="docutils literal"><span class="pre">arguments</span></tt>
dictionary include:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>username</strong> &#8211; optional username, will be used for
SASL authentication.</li>
<li><strong>password</strong> &#8211; optional password, will be used for
SASL authentication.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.memcached.MemcachedLock">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.memcached.</tt><tt class="descname">MemcachedLock</tt><big>(</big><em>client_fn</em>, <em>key</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.memcached.MemcachedLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple distributed lock using memcached.</p>
<p>This is an adaptation of the lock featured at
<a class="reference external" href="http://amix.dk/blog/post/19386">http://amix.dk/blog/post/19386</a></p>
</dd></dl>

</div>
<span class="target" id="module-dogpile.cache.backends.redis"></span><div class="section" id="redis-backends">
<h3>Redis Backends<a class="headerlink" href="#redis-backends" title="Permalink to this headline">¶</a></h3>
<p>Provides backends for talking to <a class="reference external" href="http://redis.io">Redis</a>.</p>
<dl class="class">
<dt id="dogpile.cache.backends.redis.RedisBackend">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.redis.</tt><tt class="descname">RedisBackend</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.redis.RedisBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://redis.io/">Redis</a> backend, using the
<a class="reference external" href="http://pypi.python.org/pypi/redis/">redis-py</a> backend.</p>
<p>Example configuration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="kn">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s">&#39;dogpile.cache.redis&#39;</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;host&#39;</span><span class="p">:</span> <span class="s">&#39;localhost&#39;</span><span class="p">,</span>
        <span class="s">&#39;port&#39;</span><span class="p">:</span> <span class="mi">6379</span><span class="p">,</span>
        <span class="s">&#39;db&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">&#39;redis_expiration_time&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>   <span class="c"># 2 hours</span>
        <span class="s">&#39;distributed_lock&#39;</span><span class="p">:</span><span class="bp">True</span>
        <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Arguments accepted in the arguments dictionary:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>url</strong> &#8211; <p>string. If provided, will override separate host/port/db
params.  The format is that accepted by <tt class="docutils literal"><span class="pre">StrictRedis.from_url()</span></tt>.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.4.1.</span></p>
</li>
<li><strong>host</strong> &#8211; string, default is <tt class="docutils literal"><span class="pre">localhost</span></tt>.</li>
<li><strong>password</strong> &#8211; <p>string, default is no password.</p>
<p class="versionadded">
<span class="versionmodified">New in version 0.4.1.</span></p>
</li>
<li><strong>port</strong> &#8211; integer, default is <tt class="docutils literal"><span class="pre">6379</span></tt>.</li>
<li><strong>db</strong> &#8211; integer, default is <tt class="docutils literal"><span class="pre">0</span></tt>.</li>
<li><strong>redis_expiration_time</strong> &#8211; integer, number of seconds after setting
a value that Redis should expire it.  This should be larger than dogpile&#8217;s
cache expiration.  By default no expiration is set.</li>
<li><strong>distributed_lock</strong> &#8211; boolean, when True, will use a
redis-lock as the dogpile lock (see <a class="reference internal" href="#dogpile.cache.backends.redis.RedisLock" title="dogpile.cache.backends.redis.RedisLock"><tt class="xref py py-class docutils literal"><span class="pre">RedisLock</span></tt></a>).
Use this when multiple
processes will be talking to the same redis instance.
When left at False, dogpile will coordinate on a regular
threading mutex.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.redis.RedisLock">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.redis.</tt><tt class="descname">RedisLock</tt><big>(</big><em>client_fn</em>, <em>key</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.redis.RedisLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple distributed lock using Redis.</p>
<p>This is an adaptation of the memcached lock featured at
<a class="reference external" href="http://amix.dk/blog/post/19386">http://amix.dk/blog/post/19386</a></p>
</dd></dl>

</div>
<span class="target" id="module-dogpile.cache.backends.file"></span><div class="section" id="file-backends">
<h3>File Backends<a class="headerlink" href="#file-backends" title="Permalink to this headline">¶</a></h3>
<p>Provides backends that deal with local filesystem access.</p>
<dl class="class">
<dt id="dogpile.cache.backends.file.DBMBackend">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.file.</tt><tt class="descname">DBMBackend</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.file.DBMBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>A file-backend using a dbm file to store keys.</p>
<p>Basic usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="kn">import</span> <span class="n">make_region</span>

<span class="n">region</span> <span class="o">=</span> <span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
    <span class="s">&#39;dogpile.cache.dbm&#39;</span><span class="p">,</span>
    <span class="n">expiration_time</span> <span class="o">=</span> <span class="mi">3600</span><span class="p">,</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&quot;filename&quot;</span><span class="p">:</span><span class="s">&quot;/path/to/cachefile.dbm&quot;</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>DBM access is provided using the Python <tt class="docutils literal"><span class="pre">anydbm</span></tt> module,
which selects a platform-specific dbm module to use.
This may be made to be more configurable in a future
release.</p>
<p>Note that different dbm modules have different behaviors.
Some dbm implementations handle their own locking, while
others don&#8217;t.  The <a class="reference internal" href="#dogpile.cache.backends.file.DBMBackend" title="dogpile.cache.backends.file.DBMBackend"><tt class="xref py py-class docutils literal"><span class="pre">DBMBackend</span></tt></a> uses a read/write
lockfile by default, which is compatible even with those
DBM implementations for which this is unnecessary,
though the behavior can be disabled.</p>
<p>The DBM backend by default makes use of two lockfiles.
One is in order to protect the DBM file itself from
concurrent writes, the other is to coordinate
value creation (i.e. the dogpile lock).  By default,
these lockfiles use the <tt class="docutils literal"><span class="pre">flock()</span></tt> system call
for locking; this is only available on Unix
platforms.</p>
<p>Currently, the dogpile lock is against the entire
DBM file, not per key.   This means there can
only be one &#8220;creator&#8221; job running at a time
per dbm file.</p>
<p>A future improvement might be to have the dogpile lock
using a filename that&#8217;s based on a modulus of the key.
Locking on a filename that uniquely corresponds to the
key is problematic, since it&#8217;s not generally safe to
delete lockfiles as the application runs, implying an
unlimited number of key-based files would need to be
created and never deleted.</p>
<p>Parameters to the <tt class="docutils literal"><span class="pre">arguments</span></tt> dictionary are
below.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; path of the filename in which to
create the DBM file.  Note that some dbm backends
will change this name to have additional suffixes.</li>
<li><strong>rw_lockfile</strong> &#8211; the name of the file to use for
read/write locking.  If omitted, a default name
is used by appending the suffix &#8221;.rw.lock&#8221; to the
DBM filename.  If False, then no lock is used.</li>
<li><strong>dogpile_lockfile</strong> &#8211; the name of the file to use
for value creation, i.e. the dogpile lock.  If
omitted, a default name is used by appending the
suffix &#8221;.dogpile.lock&#8221; to the DBM filename. If
False, then dogpile.cache uses the default dogpile
lock, a plain thread-based mutex.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="dogpile.cache.backends.file.FileLock">
<em class="property">class </em><tt class="descclassname">dogpile.cache.backends.file.</tt><tt class="descname">FileLock</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#dogpile.cache.backends.file.FileLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Use lockfiles to coordinate read/write access to a file.</p>
<p>Only works on Unix systems, using
<a class="reference external" href="http://docs.python.org/library/fcntl.html">fcntl.flock()</a>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-dogpile.cache.plugins.mako_cache">
<span id="plugins"></span><h2>Plugins<a class="headerlink" href="#module-dogpile.cache.plugins.mako_cache" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mako-integration">
<h3>Mako Integration<a class="headerlink" href="#mako-integration" title="Permalink to this headline">¶</a></h3>
<p>dogpile.cache includes a <a class="reference external" href="http://www.makotemplates.org">Mako</a> plugin that replaces <a class="reference external" href="http://beaker.groovie.org">Beaker</a>
as the cache backend.
Setup a Mako template lookup using the &#8220;dogpile.cache&#8221; cache implementation
and a region dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">dogpile.cache</span> <span class="kn">import</span> <span class="n">make_region</span>
<span class="kn">from</span> <span class="nn">mako.lookup</span> <span class="kn">import</span> <span class="n">TemplateLookup</span>

<span class="n">my_regions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&quot;local&quot;</span><span class="p">:</span><span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="s">&quot;dogpile.cache.dbm&quot;</span><span class="p">,</span>
                <span class="n">expiration_time</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span>
                <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;filename&quot;</span><span class="p">:</span><span class="s">&quot;file.dbm&quot;</span><span class="p">}</span>
            <span class="p">),</span>
    <span class="s">&quot;memcached&quot;</span><span class="p">:</span><span class="n">make_region</span><span class="p">()</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="s">&quot;dogpile.cache.pylibmc&quot;</span><span class="p">,</span>
                <span class="n">expiration_time</span><span class="o">=</span><span class="mi">3600</span><span class="p">,</span>
                <span class="n">arguments</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;url&quot;</span><span class="p">:[</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">]}</span>
            <span class="p">)</span>
<span class="p">}</span>

<span class="n">mako_lookup</span> <span class="o">=</span> <span class="n">TemplateLookup</span><span class="p">(</span>
    <span class="n">directories</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;/myapp/templates&quot;</span><span class="p">],</span>
    <span class="n">cache_impl</span><span class="o">=</span><span class="s">&quot;dogpile.cache&quot;</span><span class="p">,</span>
    <span class="n">cache_args</span><span class="o">=</span><span class="p">{</span>
        <span class="s">&#39;regions&#39;</span><span class="p">:</span><span class="n">my_regions</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To use the above configuration in a template, use the <tt class="docutils literal"><span class="pre">cached=True</span></tt> argument on any
Mako tag which accepts it, in conjunction with the name of the desired region
as the <tt class="docutils literal"><span class="pre">cache_region</span></tt> argument:</p>
<div class="highlight-python"><pre>&lt;%def name="mysection()" cached="True" cache_region="memcached"&gt;
    some content that's cached
&lt;/%def&gt;</pre>
</div>
<dl class="class">
<dt id="dogpile.cache.plugins.mako_cache.MakoPlugin">
<em class="property">class </em><tt class="descclassname">dogpile.cache.plugins.mako_cache.</tt><tt class="descname">MakoPlugin</tt><big>(</big><em>cache</em><big>)</big><a class="headerlink" href="#dogpile.cache.plugins.mako_cache.MakoPlugin" title="Permalink to this definition">¶</a></dt>
<dd><p>A Mako <tt class="docutils literal"><span class="pre">CacheImpl</span></tt> which talks to dogpile.cache.</p>
</dd></dl>

</div>
</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<tt class="descclassname">dogpile.cache.util.</tt><tt class="descname">function_key_generator</tt><big>(</big><em>namespace</em>, <em>fn</em><big>)</big></dt>
<dd><p>Return a function that generates a string
key, based on a given function as well as
arguments to the returned function itself.</p>
<p>This is used by <a class="reference internal" href="#dogpile.cache.region.CacheRegion.cache_on_arguments" title="dogpile.cache.region.CacheRegion.cache_on_arguments"><tt class="xref py py-meth docutils literal"><span class="pre">CacheRegion.cache_on_arguments()</span></tt></a>
to generate a cache key from a decorated function.</p>
<p>It can be replaced using the <tt class="docutils literal"><span class="pre">function_key_generator</span></tt>
argument passed to <a class="reference internal" href="#dogpile.cache.region.make_region" title="dogpile.cache.region.make_region"><tt class="xref py py-func docutils literal"><span class="pre">make_region()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="dogpile.cache.util.sha1_mangle_key">
<tt class="descclassname">dogpile.cache.util.</tt><tt class="descname">sha1_mangle_key</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#dogpile.cache.util.sha1_mangle_key" title="Permalink to this definition">¶</a></dt>
<dd><p>a SHA1 key mangler.</p>
</dd></dl>

<dl class="function">
<dt id="dogpile.cache.util.length_conditional_mangler">
<tt class="descclassname">dogpile.cache.util.</tt><tt class="descname">length_conditional_mangler</tt><big>(</big><em>length</em>, <em>mangler</em><big>)</big><a class="headerlink" href="#dogpile.cache.util.length_conditional_mangler" title="Permalink to this definition">¶</a></dt>
<dd><p>a key mangler that mangles if the length of the key is
past a certain threshold.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API</a><ul>
<li><a class="reference internal" href="#module-dogpile.cache.region">Region</a></li>
<li><a class="reference internal" href="#backend-api">Backend API</a></li>
<li><a class="reference internal" href="#module-dogpile.cache.backends.memory">Backends</a><ul>
<li><a class="reference internal" href="#memory-backend">Memory Backend</a></li>
<li><a class="reference internal" href="#memcached-backends">Memcached Backends</a></li>
<li><a class="reference internal" href="#redis-backends">Redis Backends</a></li>
<li><a class="reference internal" href="#file-backends">File Backends</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-dogpile.cache.plugins.mako_cache">Plugins</a><ul>
<li><a class="reference internal" href="#mako-integration">Mako Integration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="usage.html"
                        title="previous chapter">Usage Guide</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="changelog.html"
                        title="next chapter">Changelog</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/api.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Changelog"
             >next</a> |</li>
        <li class="right" >
          <a href="usage.html" title="Usage Guide"
             >previous</a> |</li>
        <li><a href="index.html">dogpile.cache 0.4.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2013 Mike Bayer.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>