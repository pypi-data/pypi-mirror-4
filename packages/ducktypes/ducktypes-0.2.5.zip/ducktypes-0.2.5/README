.. -*- restructuredtext -*-

=========
ducktypes
=========
Duck typing support library
---------------------------

Rationale
=========

Allows working with objects depending on their current behaviour, not their type or their registered (ABC-like) interface.

Quick example::

    from ducktypes.ducktype import Duck

    class MyObject(object):
        def some_method(self, a, b):
            pass
        def another_method(self, x):
            pass


    class AnotherObject(object):
        def some_method(self, a, b):
            pass
        def another_method(self, a):
            pass

    class AnotherDifferentObject(object):
        def some_method(self, a, b, c):
            pass
        def another_method(self, a):
            pass

    duck = Duck(MyObject())

    print "AnotherObject instances implement MyObject interface: ", duck.maybe_implemented_by(AnotherObject())
    print "AnotherDifferentObject instances implement MyObject interface:", duck.maybe_implemented_by(AnotherDifferentObject())

Output::
    
    AnotherObject instances implement MyObject interface:  True
    AnotherDifferentObject instances implement MyObject interface: False


Gotchas
=======

 * positional arguments are supposed to be called as positional arguments, and keyword arguments  are supposed to be called as positional arguments. If your client code calls keyword arguments as positional ones, signature matching may fail.
 * proxy-everything methods, i.e. ``(*args, **kwargs)``-like signature, will of course deceive our signature detection system.


Todo
====
 * __getattr__ / __getattribute__ overriding functions
 * subclasses exposing special methods with different signature
 * C-declared functions that don't expose their signature.
 * implement optional strict checking.


