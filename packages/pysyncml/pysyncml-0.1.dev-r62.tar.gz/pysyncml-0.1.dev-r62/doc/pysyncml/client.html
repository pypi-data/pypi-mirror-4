

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementing a SyncML Client &mdash; pysyncml 0.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="pysyncml 0.1 documentation" href="../index.html" />
    <link rel="next" title="Implementing a SyncML Server" href="server.html" />
    <link rel="prev" title="Sample Implementation: sync-notes" href="cli/notes.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>pysyncml 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>Implementing a SyncML Client</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="cli/notes.html">Sample Implementation: sync-notes</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="server.html">Implementing a SyncML Server</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="implementing-a-syncml-client">
<h1><a class="toc-backref" href="#id1">Implementing a SyncML Client</a><a class="headerlink" href="#implementing-a-syncml-client" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#implementing-a-syncml-client" id="id1">Implementing a SyncML Client</a><ul>
<li><a class="reference internal" href="#define-an-agent" id="id2">Define an Agent</a></li>
<li><a class="reference internal" href="#create-an-adapter" id="id3">Create an Adapter</a></li>
<li><a class="reference internal" href="#connect-the-adapter" id="id4">Connect the Adapter</a></li>
<li><a class="reference internal" href="#scan-for-local-changes" id="id5">Scan for Local Changes</a></li>
<li><a class="reference internal" href="#invoke-a-synchronization" id="id6">Invoke a Synchronization</a></li>
<li><a class="reference internal" href="#real-world-application" id="id7">Real-World Application</a></li>
</ul>
</li>
</ul>
</div>
<p>The general approach to implementing a SyncML client with pysyncml is
to create an agent (which interfaces with your data) and an adapter
(which will interface with the SyncML peers), connect the two, scan
the local datastore and notify the adapter of any <cite>local</cite> changes and
then invoke the synchronization.</p>
<p>For command-line interfaces, there are helper classes to make this
significantly easier to implement, by providing automatic storage
management, standard command-line options and simple server-side
support. Please see <a class="reference internal" href="cli/engine.html"><em>Implementing a SyncML Command-Line Interface</em></a> for details on how to implement a
command-line interface (CLI).</p>
<div class="section" id="define-an-agent">
<h2><a class="toc-backref" href="#id2">Define an Agent</a><a class="headerlink" href="#define-an-agent" title="Permalink to this headline">¶</a></h2>
<p>A pysyncml Agent is the interface between the SyncML
framework/protocol and your local data storage, and therefore is what
you, the pysyncml caller, must provide by implementing the
<a class="reference internal" href="agents/index.html#pysyncml.agents.base.Agent" title="pysyncml.agents.base.Agent"><tt class="xref py py-class docutils literal"><span class="pre">pysyncml.Agent</span></tt></a> interface. At its
simplest, it must support fetching, updating, deleting and listing
items. These items must implement the <a class="reference internal" href="items/index.html#pysyncml.items.base.Item" title="pysyncml.items.base.Item"><tt class="xref py py-class docutils literal"><span class="pre">pysyncml.Item</span></tt></a> interface, which essentially only means
that it provides the <cite>id</cite> attribute which does not have to be any
particular type, but must be convertable to a string via a call to
<tt class="docutils literal"><span class="pre">str()</span></tt>. For conceptual simplicity, <cite>Item`s should also know how to
serialize/deserialize themselves, but technically this is only
required at the `Agent</cite> interface.</p>
<p>The stripped-down minimal API is listed here &#8212; see
<a class="reference internal" href="items/index.html"><em>Module: pysyncml.items</em></a> and <a class="reference internal" href="agents/index.html"><em>Module: pysyncml.agents</em></a> for details:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pysyncml</span>

<span class="k">class</span> <span class="nc">MyItem</span><span class="p">(</span><span class="n">pysyncml</span><span class="o">.</span><span class="n">Item</span><span class="p">):</span>
  <span class="c"># Items must have an agent-unique ID that can be converted via `str()`</span>
  <span class="nb">id</span> <span class="o">=</span> <span class="o">...</span>
  <span class="c"># Items should be able to serialize and deserialize themselves</span>
  <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="o">...</span>
  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">MyAgent</span><span class="p">(</span><span class="n">pysyncml</span><span class="o">.</span><span class="n">Agent</span><span class="p">):</span>
  <span class="c"># An agent must declare what content types it can de/serialize,</span>
  <span class="c"># which must be a list of pysyncml.ContentTypeInfo objects.</span>
  <span class="n">contentTypes</span> <span class="o">=</span> <span class="o">...</span>
  <span class="c"># An agent must be able to serialize and deserialize items</span>
  <span class="k">def</span> <span class="nf">dumpItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># Usually, just invokes the item&#39;s dump method:</span>
    <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">loadItem</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c"># Usually, just invokes the item&#39;s load method:</span>
    <span class="k">return</span> <span class="n">MyItem</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">contentType</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
  <span class="c"># An agent must be able to list, add, fetch, modify and delete items</span>
  <span class="k">def</span> <span class="nf">getAllItems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">addItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">getItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itemID</span><span class="p">):</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">replaceItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">reportChanges</span><span class="p">):</span> <span class="o">...</span>
  <span class="k">def</span> <span class="nf">deleteItem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itemID</span><span class="p">):</span> <span class="o">...</span>

<span class="c"># Now create an instance of the agent --- note that this could</span>
<span class="c"># potentially be done at any point, not necessarily before the</span>
<span class="c"># adapter instance has been created.</span>

<span class="n">agent</span> <span class="o">=</span> <span class="n">MyAgent</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>See the <a class="reference internal" href="items/index.html#pysyncml.items.note.NoteItem" title="pysyncml.items.note.NoteItem"><tt class="xref py py-class docutils literal"><span class="pre">pysyncml.NoteItem</span></tt></a>
class for an example Item
implementation. <a class="reference internal" href="ctype.html#pysyncml.ctype.ContentTypeInfo" title="pysyncml.ctype.ContentTypeInfo"><tt class="xref py py-class docutils literal"><span class="pre">pysyncml.ContentTypeInfo</span></tt></a> for details on the
Agent.contentTypes objects.</p>
</div>
<div class="section" id="create-an-adapter">
<h2><a class="toc-backref" href="#id3">Create an Adapter</a><a class="headerlink" href="#create-an-adapter" title="Permalink to this headline">¶</a></h2>
<p>A pysyncml Adapter is the object that encapsulates the entire SyncML
interaction with a remote SyncML peer. An adapter requires several
pieces of information, such as the local devices type and
capabilities, as well as a repository to store contextual information
(using <a class="reference external" href="http://www.sqlalchemy.org">sqlalchemy</a> as database abstraction engine). This is primarily
necessary so that future &#8220;update&#8221; synchronizations do not need to
re-transmit all the information, but instead do a differential sync,
which is much faster.</p>
<p>The stripped-down minimal API is as follows &#8212; see <a class="reference internal" href="context.html"><em>Module: pysyncml.context</em></a> and
<a class="reference internal" href="model/adapter.html"><em>Module: pysyncml.model.adapter</em></a> for details:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pysyncml</span>

<span class="c"># Create a &quot;Context&quot; object, which primarily tells pysyncml where to</span>
<span class="c"># store synchronization state information. In this example, the</span>
<span class="c"># storage is a sqlite file in /tmp/sync.db:</span>

<span class="n">context</span> <span class="o">=</span> <span class="n">pysyncml</span><span class="o">.</span><span class="n">Context</span><span class="p">(</span><span class="n">storage</span><span class="o">=</span><span class="s">&#39;sqlite:////tmp/sync.db&#39;</span><span class="p">)</span>

<span class="c"># Now create the local Adapter instance, which will (if previously</span>
<span class="c"># created, load lots of information from the storage backend):</span>

<span class="n">adapter</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">Adapter</span><span class="p">()</span>

<span class="c"># Check to see if the local device information has been set, and if</span>
<span class="c"># not, provide all relevant information (note that this should only</span>
<span class="c"># happen the first time the adapter is created):</span>

<span class="k">if</span> <span class="n">adapter</span><span class="o">.</span><span class="n">devinfo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
  <span class="n">adapter</span><span class="o">.</span><span class="n">name</span>    <span class="o">=</span> <span class="s">&#39;My Example SyncML Device&#39;</span>
  <span class="n">adapter</span><span class="o">.</span><span class="n">devinfo</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">DeviceInfo</span><span class="p">(</span>
    <span class="n">devID</span>             <span class="o">=</span> <span class="s">&#39;IMEI:57471724140229&#39;</span><span class="p">,</span>
    <span class="n">devType</span>           <span class="o">=</span> <span class="n">pysyncml</span><span class="o">.</span><span class="n">DEVTYPE_SMARTPHONE</span><span class="p">,</span>
    <span class="n">softwareVersion</span>   <span class="o">=</span> <span class="s">&#39;0.1&#39;</span><span class="p">,</span>
    <span class="n">manufacturerName</span>  <span class="o">=</span> <span class="s">&#39;Example Manufacturer, Inc.&#39;</span><span class="p">,</span>
    <span class="n">modelName</span>         <span class="o">=</span> <span class="s">&#39;EX-RD42&#39;</span><span class="p">,</span>
    <span class="c"># if synchronizing with funambol, add the following as funambol</span>
    <span class="c"># does not support hierarchical data structures yet (as of</span>
    <span class="c"># 10.0.3), such as the new OMADS 1.2.2 files and folders. A</span>
    <span class="c"># future pysyncml framework work-around will allow it to</span>
    <span class="c"># auto-detect this limitation.</span>
    <span class="n">hierarchicalSync</span>  <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
    <span class="p">)</span>

<span class="c"># Next, check to see if the remote SyncML peer (i.e. SyncML server)</span>
<span class="c"># information has been set, and if not, provide all relevant</span>
<span class="c"># information to be able to connect to that SyncML server:</span>

<span class="k">if</span> <span class="n">adapter</span><span class="o">.</span><span class="n">peer</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
  <span class="n">adapter</span><span class="o">.</span><span class="n">peer</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">RemoteAdapter</span><span class="p">(</span>
    <span class="n">url</span>      <span class="o">=</span> <span class="s">&#39;https://www.example.com/funambol/ds&#39;</span><span class="p">,</span>
    <span class="n">auth</span>     <span class="o">=</span> <span class="n">pysyncml</span><span class="o">.</span><span class="n">NAMESPACE_AUTH_BASIC</span><span class="p">,</span>
    <span class="n">username</span> <span class="o">=</span> <span class="s">&#39;guest&#39;</span><span class="p">,</span>
    <span class="n">password</span> <span class="o">=</span> <span class="s">&#39;guest&#39;</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>See the <a class="reference internal" href="context.html#pysyncml.context.Context" title="pysyncml.context.Context"><tt class="xref py py-class docutils literal"><span class="pre">pysyncml.Context</span></tt></a>
class for details on the <cite>Adapter</cite> and <cite>RemoteAdapter</cite> methods.</p>
</div>
<div class="section" id="connect-the-adapter">
<h2><a class="toc-backref" href="#id4">Connect the Adapter</a><a class="headerlink" href="#connect-the-adapter" title="Permalink to this headline">¶</a></h2>
<p>Now that the adapter is configured, it must be connected to the agent.
This is done by creating a <tt class="docutils literal"><span class="pre">Store</span></tt> which primarily provides a local
URI (relative to the adapter) that the agent is connected to. This
allows a single adapter to synchronize multiple datastores, such as
contacts, agendas and notes, all as part of the same transaction.</p>
<p>Currently, there is a limitation within <cite>pysyncml</cite> which does not
allow the registration of the same datastore multiple times, and as a
result you must first check to see if the datastore has already been
registered. In the future, this restriction will be removed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Check to see if the store with URI &#39;example&#39; already exists,</span>
<span class="c"># and if so, get a reference to it, otherwise create a new Store:</span>

<span class="k">if</span> <span class="s">&#39;example&#39;</span> <span class="ow">in</span> <span class="n">adapter</span><span class="o">.</span><span class="n">stores</span><span class="p">:</span>
  <span class="n">store</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">stores</span><span class="p">[</span><span class="s">&#39;example&#39;</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">store</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">.</span><span class="n">addStore</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">Store</span><span class="p">(</span>
    <span class="n">uri</span>         <span class="o">=</span> <span class="s">&#39;example&#39;</span><span class="p">,</span>
    <span class="n">displayName</span> <span class="o">=</span> <span class="s">&#39;My Local Example Datastore&#39;</span><span class="p">,</span>
    <span class="c"># if synchronizing with funambol, add the following as funambol</span>
    <span class="c"># does not &quot;appreciate&quot; a Datastore having a different maximum</span>
    <span class="c"># object size than the adapter. A future pysyncml framework</span>
    <span class="c"># work-around will allow it to auto-detect this limitation.</span>
    <span class="n">maxObjSize</span>  <span class="o">=</span> <span class="bp">None</span><span class="p">))</span>

<span class="c"># Then attach the agent to the adapter&#39;s store:</span>

<span class="n">store</span><span class="o">.</span><span class="n">agent</span> <span class="o">=</span> <span class="n">agent</span>
</pre></div>
</div>
</div>
<div class="section" id="scan-for-local-changes">
<h2><a class="toc-backref" href="#id5">Scan for Local Changes</a><a class="headerlink" href="#scan-for-local-changes" title="Permalink to this headline">¶</a></h2>
<p>For adapters that have been synchronized before, you now need to
notify the adapter of any local changes (unless you don&#8217;t want to
notify the server of local client modifications &#8212; see
<a class="reference internal" href="#section-invoke"><em>Invoke a Synchronization</em></a> for details):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># In this example, we will assume that &#39;MyAgent&#39; implements a method</span>
<span class="c"># &#39;getAllLocalChanges()&#39; that returns a list of lists where the</span>
<span class="c"># first element is the item, and the second element indicates how</span>
<span class="c"># the item changed, i.e. it is one of the following constants</span>
<span class="c"># defined in pysyncml:</span>
<span class="c">#   - pysyncml.ITEM_ADDED</span>
<span class="c">#   - pysyncml.ITEM_MODIFIED</span>
<span class="c">#   - pysyncml.ITEM_DELETED</span>
<span class="c"># eventually, pysyncml will support soft-deletes, in which case the</span>
<span class="c"># latter can also be pysyncml.ITEM_SOFTDELETED.</span>

<span class="c"># store.peer will be None if the adapter has no record of having</span>
<span class="c"># synchronized this datastore, in which case you do not need to scan</span>
<span class="c"># for changes since a complete non-incremental synchronization will</span>
<span class="c"># be necessary.</span>

<span class="k">if</span> <span class="n">store</span><span class="o">.</span><span class="n">peer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">changeType</span> <span class="ow">in</span> <span class="n">agent</span><span class="o">.</span><span class="n">getAllLocalChanges</span><span class="p">():</span>
    <span class="n">store</span><span class="o">.</span><span class="n">registerChange</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">changeType</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="invoke-a-synchronization">
<span id="section-invoke"></span><h2><a class="toc-backref" href="#id6">Invoke a Synchronization</a><a class="headerlink" href="#invoke-a-synchronization" title="Permalink to this headline">¶</a></h2>
<p>When the client is ready to execute a synchronization, it should call
the <tt class="xref py py-meth docutils literal"><span class="pre">pysyncml.api.Adapter.sync</span></tt>
method, which accepts several different modes to override the default:</p>
<p><strong>pysyncml.SYNCTYPE_AUTO</strong>:</p>
<blockquote>
<div>The default sync type, which specifies that the Adapter should
try to determine the best applicable synchronization type to apply.
In general, this means using <strong>pysyncml.SYNCTYPE_TWO_WAY</strong>.</div></blockquote>
<p><strong>pysyncml.SYNCTYPE_TWO_WAY</strong>:</p>
<blockquote>
<div>The standard sync type, which allows both client and server to send
and receive modifications. After such a sync type has completed
successfully, both SyncML peers will have the exact same local
datastores.</div></blockquote>
<p><strong>pysyncml.SYNCTYPE_SLOW_SYNC</strong>:</p>
<blockquote>
<div>Invoked when the SyncML peers have not synchronized before or a data
or protocol corruption has occurred. This forces the server to
perform an in-depth analysis of all items in both local and remote
datastores to merge them with as few duplicates and conflicts as
possible. As the identifier implies, the larger the dataset, the
slower this sync type is.</div></blockquote>
<p><strong>pysyncml.SYNCTYPE_ONE_WAY_FROM_CLIENT</strong>:</p>
<blockquote>
<div>Similar to <tt class="docutils literal"><span class="pre">pysyncml.SYNCTYPE_TWO_WAY</span></tt>, except only client
modifications are sent to the server. Server modifications are
postponed.</div></blockquote>
<p><strong>pysyncml.SYNCTYPE_REFRESH_FROM_CLIENT</strong>:</p>
<blockquote>
<div>All server items are deleted and replaced by the items in the
client. This is generally only used when a different client is known
to have been corrupted and accidentally synchronized with the
server, thus potentially deleting valid data from the server. This
mode will cause all local items to overwrite the server&#8217;s items &#8212;
use with extreme caution.</div></blockquote>
<p><strong>pysyncml.SYNCTYPE_ONE_WAY_FROM_SERVER</strong>:</p>
<blockquote>
<div>Similar to <tt class="docutils literal"><span class="pre">pysyncml.SYNCTYPE_TWO_WAY</span></tt>, except only server
modifications are sent to the client. Client modifications are
postponed.</div></blockquote>
<p><strong>pysyncml.SYNCTYPE_REFRESH_FROM_SERVER</strong>:</p>
<blockquote>
<div>All client items are deleted and replaced by the items in the
server. This is generally only used when the client is known to be
corrupted and losing any changes performed locally on the client are
deemed insignificant &#8212; use with caution.</div></blockquote>
<p>The following is the most common (and recommended) form of invoking
a client-side synchronization:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># The following example allows the adapter to determine which</span>
<span class="c"># synchronization type to perform, which generally speaking will</span>
<span class="c"># default to two-way sync:</span>

<span class="n">adapter</span><span class="o">.</span><span class="n">sync</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="real-world-application">
<h2><a class="toc-backref" href="#id7">Real-World Application</a><a class="headerlink" href="#real-world-application" title="Permalink to this headline">¶</a></h2>
<p>Although this guide has distilled the task of creating a SyncML client
down to a few critical steps:</p>
<ol class="arabic simple">
<li>provide Agent and Item subclasses,</li>
<li>create a context and Adapter,</li>
<li>register local datastore changes, and</li>
<li>invoking the synchronization</li>
</ol>
<p>The details, however, can get significantly more complex.</p>
<p>For example, a client may or may not be able to determine what local
changes have occurred since the last sync. The pysyncml framework has
no way to differentiate between a client that has no changes and a
client that cannot detect changes, so it is critical that agents in
such a scenario do <strong>NOT</strong> use the default sync method and instead use
the <tt class="docutils literal"><span class="pre">pysyncml.SYNCTYPE_SLOW_SYNC</span></tt> mode.</p>
<p>For this reason, pysyncml also provides some helper classes for
implementing a command-line SyncML peer. See <a class="reference internal" href="cli/engine.html"><em>Implementing a SyncML Command-Line Interface</em></a> which
details that process as well as using the <tt class="docutils literal"><span class="pre">sync-notes</span></tt> real-world
application as an example. Although it synchronizes a relatively
simple object type (notes, which are simply an octet stream), it does
demonstrate some of the key concepts of pysyncml.</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="cli/notes.html">Sample Implementation: sync-notes</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="server.html">Implementing a SyncML Server</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012-2012, UberDev, No Rights Reserved.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>